<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE spec SYSTEM "../../support/dtd/v3m.dtd">
<spec>
	<header>
		<title> GELLO: A Common Expression Language</title>
		<subtitle> Response to the HL7 CDS TC comments from Membership Level Ballot 1 (January, 2005)</subtitle>
		<version>1.2</version>
		<date>July, 2005</date>
		<authlist>
			<author>
				<role>Principal Contributor</role>
				<name key="Sordo, Margarita">Margarita Sordo, Ph.D</name>
				<affiliation>Decision Systems Group, Brigham &amp; Women’s Hospital, 
				Harvard Medical School, Boston, MA</affiliation>
				<email href="msordo@dsg.harvard.edu">msordo@dsg.harvard.edu</email>
			</author>
			<author>
				<role>Principal Contributor</role>
				<name key="Ogunyemi, Omolola">Omolola Ogunyemi, Ph.D.</name>
				<affiliation>Decision Systems Group, Brigham &amp; Women’s Hospital, 
				Harvard Medical School, Boston, MA</affiliation>
				<email href="oogunyem@dsg.harvard.edu">oogunyem@dsg.harvard.edu</email>
			</author>
			<author>
				<role>Principal Contributor</role>
				<name key="Boxwala, Aziz A.">Aziz A. Boxwala, M.B.B.S., Ph.D.</name>
				<affiliation>Eclipsys</affiliation>
				<email href="Aziz.Boxwala@eclipsys.com">Aziz.Boxwala@eclipsys.com</email>
			</author>
			<author>
				<role>Principal Contributor</role>
				<name key="Greenes, Robert A.">Robert A. Greenes, M.D., Ph.D.</name>
				<affiliation>Decision Systems Group, Brigham &amp; Women’s Hospital, 
				Harvard Medical School, Boston, MA</affiliation>
				<email href="greenes@harvard.edu">greenes@harvard.edu</email>
			</author>
			<author>
				<role>Contributor</role>
				<name key="Tu, Samson">Samson Tu</name>
				<affiliation>SMI, Stanford University School of Medicine, Stanford, CA</affiliation>
				<email href="tu@SMI.Stanford.EDU">tu@SMI.Stanford.EDU</email>
			</author>
		</authlist>
	</header>
	<front>
		<div1 id="prefChange">
			<head>Changes from Previous Release</head>
			<p>
			Many thanks to all CDS TC members and all the people from other HL7 TCs for their valuable comments.
			</p>
			<div2 id="IssuesAddressedAfterJan2005">
				<head>Issues Addressed after January 2005 Membership Ballot</head>
				<anchor id="RevHistory"/>
				<table id="RevHistTable">
					<tr>
						<th>Issue</th>
						<th>Action</th>
					</tr>
					<tr>
						<td>Change title of Section 2.1 from functional requirements to technical requirements</td>
						<td>Section 2.1 title changed to nonfunctional requirements</td>
					</tr>
					<tr>
						<td>Section 2.2 include researcher, epidemiologist, health economist as potential actors for use cases</td>
						<td>Actors included and use cases expanded.</td>
					</tr>
					<tr>
						<td>Typos in Section 2.4 and 4</td>
						<td>Corrected</td>
					</tr>
					<tr>
						<td>Section 5.4.1 last expression needs explanation</td>
						<td>Explanation added</td>
					</tr>
					<tr>
						<td>Request for adding String/date functions: tochar(), todate(), LPAD(), RPAD(), RTRIM(), LTRIM(), Replace(), Translate(), Length(), AddMonths(), AddDate(), LastDay(), NextDay(), MonthsBetween(). Statistical functions. Trigonometric functions. Logaritmic functions. Other mathematical functions: Ceiling(), Floor(), Abs(), Sqt(). Other functions: NULL(), Like(), NotLIke(), Difference(), Any(), InBetween().</td>
						<td>The requested functions were added to GELLO syntax. All these operations are side-effect free. If needed, the resulting value must be bound to a variable. Further requests for adding operators should follow the mechanisms outlined in the document "Mechanisms for adding functions to GELLO language", that was approved by the CDS TC in February 2005 - See link below immediately after this table.   
							<list role="unordered">
								<item>GELLO already supports the NULL() operator (See Section 5.1.1.5). </item>
								<item>The added mathematical (includes mathematical, trigonometric and logaritmic) functions are in Sections 5.9.6 to 5.9.21.  </item>
								<item>Although statistical operators are supported by the RIM, they were added to GELLO as built in operators for collections. See Sections 5.10.28  to 5.10.32.  </item>
								<item>Various string functions were added in Section 5.9.24. the operator lenght() was not added because is equivalent to the string operator size().</item>
								<item>Date/time operators were added to Section 5.12. Note that several requested operations are supported by the RIM, so they were not added to GELLO.</item>
								<item> operations "any" and "in" already exist in GELLO as part of the collection operators "exists" and "includes" respectively</item>
								<item>like(), notlike(), distinct(), between() were added to the collection operators. Sections 5.10.33 to 5.10.36</item>
							</list>
						</td>
					</tr>
					<tr>
						<td>Section 5.11.4 replace "the following example returns 3" with "the following example returns 2"</td>
						<td>Replaced</td>
					</tr>
					<tr>
						<td>Section 5.11.5 replace "getElemType(3)" with  "getElemType(2)"</td>
						<td>Replaced</td>
					</tr>
					<tr>
						<td>Section 6.3.7 too many ""</td>
						<td>Corrected</td>
					</tr>
					<tr>
						<td>Section 7.1 replace "lastPhosphate..value" with "lastPhosphate.value"</td>
						<td>Corrected</td>
					</tr>
					<tr>
						<td>Section 7.3 correct "SNOMED-CT, 1182007" with "SNOMED-CT", "1182007"</td>
						<td>Corrected</td>
					</tr>
					<tr>
						<td>Section 7.4 correct ""SNOMED-CT" with "SNOMED-CT"</td>
						<td>Corrected</td>
					</tr>
					<tr>
						<td>Suggestion: GELLO should progress as a DSTU pending further collaborative work with OMG.In particular, GELLO's combined subsetting and extension of OCL is a situation that requires resolution in collaboration with OMG. A solution must be found that provides a well-defined conformance level for GELLO applications with respect to OMG standard OCL.</td>
						<td>The general consensus among voters is that it is best first to standarize GELLO and then work OMG so OCL and GELLO will evolve together through a working relationship. This issue is being pursued by members of the CDS TC and other TC and SIG groups within HL7.</td>
					</tr>
				</table>
				<p></p>
				<p>For "Mechanisms for adding functions to GELLO" document <loc href="Mechanisms for adding functions to GELLO1.pdf">[CLICK HERE]</loc></p>
			</div2>
			<div2 id="IssuesAddressedAfterAug2004">
				<head>Issues Addressed after August 2004 Ballot</head>
				<table>
					<tr>
						<th>Issue</th>
						<th>Action</th>
					</tr>
					<tr>
						<td>User-defined 'macros'</td>
						<td>Section "Grouping GELLO expressions into Model Processes" added explaining how to define such user-defined  processes.</td>
					</tr>
					<tr>
						<td>HL7 has just signed an organizational affiliate agreement with OMG, and as part of this agreement we (HL7) can interact directly with the authors of the UML and OCL specifications. So one question that GELLO could ask is: can the non-OCL parts of the GELLO specification be added to OCL so that GELLO becomes a strict subset of OCL? This would enhance the interoperability of the two.</td>
						<td>We will seek to identify points of contact and pursue. We are looking to align with OMG standards as a future continuing activity.</td>
					</tr>
					<tr>
						<td>Minor comments</td>
						<td>Direct response to contributors</td>
					</tr>
				</table>
			</div2>
			<div2 id="IssuesAddressedAfterMay2004">
				<head>Issues Addressed after May 2004 Ballot</head>
				<p>
					<anchor id="IssuesMay04"/>
				</p>
				<table id="individual_issues">
					<tr>
						<th>From: Samson Tu</th>
						<th>Action</th>
						<th>Section</th>
					</tr>
					<tr>
						<td>• GELLO can be used with any OO data model</td>
						<td>Rephrased</td>
						<td>1.2, 2.3 </td>
					</tr>
					<tr>
						<td>• Distinction between query and expression </td>
						<td>Removed</td>
						<td>1, 1.2, 2.1</td>
					</tr>
					<tr>
						<td>• No specific reference to the vMR</td>
						<td>All references removed</td>
						<td>‎2.3‎, 3</td>
					</tr>
					<tr>
						<td>• Definition of variables </td>
						<td>Rephrased</td>
						<td>‎5.5</td>
					</tr>
					<tr>
						<td>• Reference to Factory methods rephrased</td>
						<td>Rephrased</td>
						<td>‎5.5.1</td>
					</tr>
					<tr>
						<td>• Use cases </td>
						<td>Revised</td>
						<td>‎2.2</td>
					</tr>
					<tr>
						<td>• Distinction between method and operation </td>
						<td>Clarified</td>
						<td>‎5.3.2</td>
					</tr>
					<tr>
						<td>• Clarification of context condition</td>
						<td>Clarified</td>
						<td>‎5.4</td>
					</tr>
					<tr>
						<td>• Examples of operators </td>
						<td>Revised</td>
						<td>‎5.9, ‎5.10, ‎5.11</td>
					</tr>
					<tr>
						<td>• Time interval definition </td>
						<td>Revised</td>
						<td>‎5.12</td>
					</tr>
					<tr>
						<td>• GELLO BNF </td>
						<td>Revised</td>
						<td>‎6.3</td>
					</tr>
					<tr>
						<td>• OWL wording </td>
						<td>Revised</td>
						<td>‎4.1</td>
					</tr>
					<tr>
						<td>• Context statements</td>
						<td>Added and revised</td>
						<td>5.4</td>
					</tr>
					<tr>
						<td>• Query section merged into Expression section</td>
						<td>Removed</td>
						<td>7</td>
					</tr>
					<tr>
						<th>From: Samson Tu: Requested after reviewing the document sent for revision (July 26, 2004)</th>
						<th>Action</th>
						<th>Section</th>
					</tr>
					<tr>
						<td>• Change IsQuery to true</td>
						<td>Done</td>
						<td>2.4</td>
					</tr>
					<tr>
						<td>• Remove refs to MLMs in Figure 1 and caption</td>
						<td>Removed</td>
						<td>3</td>
					</tr>
					<tr>
						<td>• Rephrase "Why OCL?" section</td>
						<td>Done</td>
						<td>4.1</td>
					</tr>
					<tr>
						<td>• Rephrase "Why GELLO?"</td>
						<td>Done</td>
						<td>4.1, 5.1</td>
					</tr>
					<tr>
						<td>• Rephrase GELLO "basic" types into "predefined" types</td>
						<td>Done</td>
						<td>5.1</td>
					</tr>
					<tr>
						<td>• "Predefined types include basic, collection and tuple"</td>
						<td>Added</td>
						<td>5.1</td>
					</tr>
					<tr>
						<td>• Basic types</td>
						<td>Rephrased</td>
						<td>5.1.1</td>
					</tr>
					<tr>
						<td>• Names decription</td>
						<td>Rephrased</td>
						<td>5.2</td>
					</tr>
					<tr>
						<td>• Attributes description</td>
						<td>Rephrased</td>
						<td>5.3.1</td>
					</tr>
					<tr>
						<td>• Properties description</td>
						<td>Rephrased</td>
						<td>5.3</td>
					</tr>
					<tr>
						<td>• Operations description</td>
						<td>Rephrased</td>
						<td>5.3.2</td>
					</tr>
					<tr>
						<td>• Variable declaration</td>
						<td>Rephrased</td>
						<td>5.5</td>
					</tr>
					<tr>
						<td>• Remove reference to Arden Syntax from Scope of declaration section</td>
						<td>Removed</td>
						<td>5.5.2</td>
					</tr>
					<tr>
						<td>• Change "basic" type for "built-in" type</td>
						<td>Changed</td>
						<td>5.8</td>
					</tr>
					<tr>
						<td>• Explain context in select example</td>
						<td>Done</td>
						<td>5.10.3</td>
					</tr>
					<tr>
						<td>• Collect notation</td>
						<td>Rephrased</td>
						<td>5.10.5</td>
					</tr>
					<tr>
						<td>• Collect example</td>
						<td>Modified</td>
						<td>5.10.5</td>
					</tr>
					<tr>
						<td>• ForAll definition</td>
						<td>Rephrased</td>
						<td>5.10.6</td>
					</tr>
					<tr>
						<td>• Iterate definition</td>
						<td>Rephrased</td>
						<td>5.10.7</td>
					</tr>
					<tr>
						<td>• Iterate example</td>
						<td>Modified</td>
						<td>5.10.7</td>
					</tr>
					<tr>
						<td>• Exists definition</td>
						<td>Rephrased</td>
						<td>5.10.8</td>
					</tr>
					<tr>
						<td>• Flatten definition</td>
						<td>Rephrased</td>
						<td>5.10.9</td>
					</tr>
					<tr>
						<td>• Count example</td>
						<td>Modified</td>
						<td>5.10.11</td>
					</tr>
					<tr>
						<td>• Includes example</td>
						<td>Modified</td>
						<td>5.10.13</td>
					</tr>
					<tr>
						<td>• IncludesAll example</td>
						<td>Modified</td>
						<td>5.10.14</td>
					</tr>
					<tr>
						<td>• FirstN defintion</td>
						<td>Rephrased</td>
						<td>5.10.18</td>
					</tr>
					<tr>
						<td>• Intersection example</td>
						<td>Modified</td>
						<td>5.10.23</td>
					</tr>
					<tr>
						<td>• Union definition </td>
						<td>Rephrased</td>
						<td>5.10.24</td>
					</tr>
					<tr>
						<td>• Including definition</td>
						<td>Rephrased</td>
						<td>5.10.25</td>
					</tr>
					<tr>
						<td>• Join example</td>
						<td>Modified</td>
						<td>5.10.27</td>
					</tr>
					<tr>
						<td>• GetValue definition</td>
						<td>Rephrased</td>
						<td>5.11.2</td>
					</tr>
					<tr>
						<td>• GetElem definition</td>
						<td>Rephrased</td>
						<td>5.11.4</td>
					</tr>
					<tr>
						<td>• Temporal Ops section</td>
						<td>Moved to Annex E</td>
						<td>Annex E</td>
					</tr>
					<tr>
						<td>• Inferring type of rules fro expressions</td>
						<td>Rephrased</td>
						<td>6.1</td>
					</tr>
					<tr>
						<td>• Collection literal</td>
						<td>Added to GELLO BNF</td>
						<td>6.3.2, 6.3.8</td>
					</tr>
					<tr>
						<td>• Tuple literal</td>
						<td>Added to GELLO BNF</td>
						<td>6.3.8</td>
					</tr>
					<tr>
						<td>• Type of an expression</td>
						<td>Rephrased</td>
						<td>7.1</td>
					</tr>
					<tr>
						<td>• Remove MLM into GELLO example</td>
						<td>Not Done. Example added at Eclipsys </td>
						<td>8.1</td>
					</tr>
					<tr>
						<td>• Example: presence of Azotemia… change "equal" for "implies"</td>
						<td>Changed</td>
						<td>8.3</td>
					</tr>
					<tr>
						<td>• Example: Number of current… change "equal" for "implies"</td>
						<td>Changed</td>
						<td>8.4</td>
					</tr>
					<tr>
						<td>• Example: 3rd dose… change "equal" for "implies</td>
						<td>Changed</td>
						<td>8.5</td>
					</tr>
					<tr>
						<th>From: Grahame Grieve</th>
						<th>Action</th>
						<th>Section</th>
					</tr>
					<tr>
						<td>• Document format in accordance with HL7 requirements: including copyright </td>
						<td>This is on its way with the collaboration of the HL7 V3 publishing people</td>
						<td> </td>
					</tr>
					<tr>
						<td>• OCL specification removed</td>
						<td>All section removed</td>
						<td> </td>
					</tr>
					<tr>
						<td>• Remove all references to a vMR </td>
						<td>Removed. No reference vMR documentation is included because there’s no such formal document yet</td>
						<td>2.3, 3 </td>
					</tr>
					<tr>
						<td>• Add self and Implicit references to objects </td>
						<td>Added and in compliance with OCL specification</td>
						<td>5.4.1</td>
					</tr>
					<tr>
						<td>• Add Package context </td>
						<td>Added and in compliance with OCL specification</td>
						<td>5.4.2</td>
					</tr>
					<tr>
						<td>• Add Enumeration types </td>
						<td>Added and in compliance with OCL specification</td>
						<td>5.1.5</td>
					</tr>
					<tr>
						<td>• Add definition constraints</td>
						<td>Added and in compliance with OCL specification</td>
						<td>5.6</td>
					</tr>
					<tr>
						<td>• Add Pathnames for packages</td>
						<td>Added and in compliance with OCL specification</td>
						<td>5.4.2</td>
					</tr>
					<tr>
						<td>• Add Associations </td>
						<td>Added and in compliance with OCL specification</td>
						<td>5.4.3</td>
					</tr>
					<tr>
						<td>• Instances of classes and Factory method</td>
						<td>It is assumed that the RIM will provide the mechanisms for creating instances of classes, through 
					the Factory method, which takes a list of arguments as a string literal –as discussed with Gunther Schadow.</td>
						<td>5.5 </td>
					</tr>
					<tr>
						<td>• Literal format for tuples </td>
						<td>Reviewed</td>
						<td>5.1.4</td>
					</tr>
					<tr>
						<td>• Name definition</td>
						<td>Reviewed</td>
						<td>5.2</td>
					</tr>
					<tr>
						<td>• Method and operation </td>
						<td>Clarified</td>
						<td>5.3.2</td>
					</tr>
					<tr>
						<td>• Context definition </td>
						<td>Reviewed</td>
						<td>5.4</td>
					</tr>
					<tr>
						<td>• Variable declaration </td>
						<td>Reviewed</td>
						<td>5.5</td>
					</tr>
					<tr>
						<td>• Examples for operators </td>
						<td>Reviewed</td>
						<td>5.9, ‎5.10‎, 5.11</td>
					</tr>
					<tr>
						<td>• he wording for definition of operators </td>
						<td>Reviewed</td>
						<td>5.3.2</td>
					</tr>
					<tr>
						<td>• 'Temporal' classes and the RIM </td>
						<td>It is assumed that 'temporal' classes in the RIM will provide the necessary temporal operators. 
					This might need to be further discussed with Gunther</td>
						<td>5.12</td>
					</tr>
					<tr>
						<td>• Correct UML diagram in appendix</td>
						<td>Diagram changed</td>
						<td>Appendix C</td>
					</tr>
					<tr>
						<td>• GELLO BNF </td>
						<td>Revised</td>
						<td>‎6</td>
					</tr>
					<tr>
						<td>• Join operator   </td>
						<td>Need to be further discussed. Some people requested such operator although it’s procedural in nature</td>
						<td>5.10.27</td>
					</tr>
					<tr>
						<td>• Data model used for examples</td>
						<td>Included for simple illustration purposes.</td>
						<td>Appendix D</td>
					</tr>
					<tr>
						<th>From: Mark Shafarman</th>
						<th>Action</th>
						<th>Section</th>
					</tr>
					<tr>
						<td>• Cover page, copyright under review for compliance with HL7 format and requirements</td>
						<td>Copyright has been assigned to HL7.</td>
						<td/>
					</tr>
					<tr>
						<td>• RIM is an information model </td>
						<td>Wording corrected</td>
						<td>3, ‎4.1, ‎Appendix B</td>
					</tr>
					<tr>
						<td>• GELLO-and-OCL functionality lost/gained </td>
						<td>Described</td>
						<td>5</td>
					</tr>
					<tr>
						<td>• Binding GELLO to a vMR. References removed since GELLO can refer to any OO data model</td>
						<td>All  references in document removed</td>
						<td/>
					</tr>
					<tr>
						<td>• Navigation through specific paths </td>
						<td>Added</td>
						<td>5.4.3</td>
					</tr>
					<tr>
						<td>• Appendix D reference to patient/person </td>
						<td>Included for simple illustration purposes.</td>
						<td>Appendix D</td>
					</tr>
					<tr>
						<th>From: Eclipsys Corporation</th>
						<th>Action</th>
						<th>Section</th>
					</tr>
					<tr>
						<td>• Remove comments to Arden Syntax  not supporting OO syntax </td>
						<td>Removed from document</td>
						<td>‎1</td>
					</tr>
					<tr>
						<td>• Paragraph stating GELLO is not intended to substitute Arden Syntax but to support HL7 efforts for a standard OCL-based syntax expression language. </td>
						<td>Added</td>
						<td/>
					</tr>
					<tr>
						<td>• Explanation for GELLO being strongly-typed</td>
						<td>This was included as a request of the CDS TC group as an extra step to ensure consistency /compatibility in data. It is also consistent with OCL.</td>
						<td>2, ‎4</td>
					</tr>
					<tr>
						<td>• Add GELLO and Arden Syntax examples. </td>
						<td>Added</td>
						<td>‎8</td>
					</tr>
					<tr>
						<th>From: Eclipsys Co. Requested after reviewing the document sent for revision (July 26, 2004)</th>
						<th>Action</th>
						<th>Section</th>
					</tr>
					<tr>
						<td>List requests for changes under "Eclipsys Corporation"</td>
						<td>Done</td>
						<td>1.1, 7, 8</td>
					</tr>
					<tr>
						<td>Remove MLM examples. </td>
						<td>Done</td>
						<td>7</td>
					</tr>
				</table>
			</div2>
		</div1>
	</front>
	<body>
		<div1 id="CTSIntro" ballotStatus="NormativeStandard" ballotNumber="1">
			<head>Introduction</head>
			<p>
				<anchor id="Intro"/>
                                GELLO is intended to be a standard expression language for decision support. 
                                Its specification has been developed in coordination with the HL7 Clinical Decision Support TC (CDSTC). 
                                The effort, begun in 2001, has been carried out with input from other TCs and SIGs as well, in order to take 
                                account of common needs for constraint specification and query formulation, and the following groups 
                                have been consulted in developing the specification: Control/Query, Modeling and Methodology, and Templates.
</p>
			<p>
This document presents the full specification of the GELLO language, and addresses issues discussed at previous HL7 WG 
meetings, through the January, 20054, meeting in Atlanta, GA when it was submitted and approved in membership balloting round 1. 
See prior documents and presentations: [<loc href="http://dsg.bwh.harvard.edu/~msordo/GELLO/Arden_GLIF_May_2001_AB.ppt">TC1</loc>,  
<loc href="http://dsg.bwh.harvard.edu/~msordo/GELLO/gello.ppt">TC2</loc>, 
<loc href="http://www.hl7.org/library/committees/dss/minutes/expr-lang-boxwala-10-2001.ppt">TC3</loc>, 
<loc href="  http://www.hl7.org/library/committees/dss/minutes/gelloupdate2-W2002.ppt">TC4</loc>, 
<loc href="http://dsg.bwh.harvard.edu/~msordo/gello/GELLO_may02.ppt">TC5</loc>, 
<loc href="http://cslxinfmtcs.csmc.edu/hl7/arden/HL7GELLOUpdate_1002.ppt">TC6</loc>].  An earlier BNF specification 
of the language is available at <loc href="http://dsg.bwh.harvard.edu/~msordo/gello/GELLClassesBNF.rtf">[DSG02-01] </loc>.  </p>
			<p>
The syntax of the GELLO language can be used with any object-oriented data model. In the context of clinical decision support, 
such an OO data model can be any R-MIM view of the HL7 RIM.  An example -- out of many possible-- of an R-MIM view of the HL7 RIM is 
the "virtual medical record" (or vMR), as it is referred to in the CDSTC.  The vMR functions as a limited view of the multiple classes 
in the HL7 RIM, showing only those classes relevant to a clinical decision support application. </p>
			<p>
Based on the premise that GELLO can fully provide expression support for any properly defined view of the HL7 RIM, it has 
been possible for us to develop GELLO regardless of any particular specification of an OO data model. It is 
thus only necessary, when producing a set of decision support applications using GELLO to specify the particular object-oriented model used.
</p>
			<p>
As discussed further below, GELLO is based on the Object Constraint Language <loc href=" http://www.omg.org/cgi-bin/doc?ptc/03-10-14.pdf "> (OCL)</loc>.  
OCL is well-developed as a constraint language and has a number of features that make it desirable for use as an expression language.  
GELLO incorporates most of OCL functionality with the exception of some unneeded capabilities which have been removed:  
a) pre and post conditions for constraints – not used in GELLO and b) invariants – also for constraints. The UML ITS implements 
the semantics of the HL7 Abstract Data Types in such a way that HL7 data types are mapped into the core UML and OCL 
kernel data types where such mappings are appropriate. Hence, GELLO, plus the functionality provided by UML ITS for handling 
HL7 Abstract Data Types, is intended to provide full expression support inasmuch as it is intended to use only standard features wherever possible.
</p>
			<p>
In regard to existing standards for decision support, the evolution of Arden Syntax data references to compatibility with GELLO is already under way. GELLO is not intended to be a substitute for Arden Syntax, although it could be used to write MLMs.  In addition, however, GELLO can be used to support a variety of specifications of expressions in decision support settings other than MLMs.  Further details regarding possible uses of GELLO, and how it can be used in conjunction with various applications, is provided in the companion manuscript, <loc href="GELLOWhitePaperV1.2.pdf">GELLO: An Introduction to its Use for Decision Support</loc>.
</p>
			<div2 id="WhatIsGello">
				<head>What is GELLO?</head>
				<p>GELLO is a class-based, object-oriented (OO) language that is built on existing standards. GELLO expression language is based on the Object Constraint Language <loc href="http://www.omg.org/cgi-bin/doc?ptc/03-10-14.pdf">(OCL)</loc>, developed by the Object Management Group. Relevant components of OCL have been selected and integrated into the GELLO to provide a suitable framework for manipulation of clinical data for decision support in health care.  </p>
				<p>The GELLO language can be used to: </p>
				<list role="unordered">
					<item>Build up expressions to extract and manipulate data from medical records.</item>
					<item>Construct decision criteria by building up expressions to reason about particular data features/values. These criteria can be used in decision-support knowledge bases such as those designed to provide alerts and reminders, guidelines, or other decision rules.</item>
					<item>Create expressions, formulae, etc. for other applications.</item>
				</list>
				<p>GELLO has been designed in the context of a guideline execution model proposed in the HL7 CDSTC <loc href="http://www.dmi.columbia.edu/homepages/wandong/homepage20030805_files/GESDOR.htm"> (GeM)</loc>. The guideline execution model consists of a series of steps: actions, decisions, patient-state, branches and synchronization. GELLO perfectly fits in this execution model, providing a standard interface to medical record systems and other data or knowledge sources, specifying decision criteria, and abstracting or deriving summary values. The object-oriented approach for the language has the flexibility and extensibility that is needed for implementation in a broad range of applications.  </p>
				<p>The expression language is strongly typed and object-oriented.  In order to facilitate the process of encoding and evaluation of expressions and more importantly, to maximize the ability to share such expressions, GELLO includes basic built-in data types (§‎5.1), while providing the necessary syntactic mechanisms to manipulate an OO  data model compatible with the HL7 RIM, and access all the data model associated classes and methods.  This is especially important in enabling decision rules and guidelines to successfully support different data models, inasmuch as classes and relationships specified could vary from one data model to another. </p>
				<p>This document contains the full software specification for GELLO expression language. It is organized as follows:</p>
				<p>Section ‎2 describes the requirements for an expression language for clinical use. Section ‎3 describes the main goals and properties of GELLO to meet such requirements. Section ‎4 briefly describes the Object Constraint Language (OCL) features. </p>
				<p>Section ‎5 describes OCL features included in GELLO expression language, including basic data types in §‎5.1.1, model types in §‎5.1.2 (classes in the data model), collection types in §‎5.1.3, properties of model types (attributes and methods) in §‎5.3, and variables in §‎5.4. Variables are named GELLO expressions with a predefined, limited scope that can be used anywhere a GELLO expression can be used (see §‎5.5.2).  In order to preserve GELLO as a side-effect-free language, the mechanisms for creating variables as instances of classes is delegated to the underlying data model. This section also describes GELLO built-in operators (see §‎5.9), and their syntax and semantics, and discusses the tuple type as an aggregation type (see §‎5.1.4) and tuple operators (see §‎5.11) supported by GELLO. </p>
				<p>Section ‎6 describes the syntax of the GELLO grammar. Section ‎7 gives examples of GELLO expressions for retrieving information. It also describes GELLO expressions used to build decision criteria, perform abstraction or derive summary values. Finally, appendices A, B and C contain reference diagrams of the HL7 v3 Data Types, HL7 RIM, UML OCL core kernel declarations. Appendix D depicts a simple data model used to illustrate examples along the document.</p>
			</div2>
		</div1>
		<div1 id="ReqsForExpLang">
			<head>Requirements for an Expression Language in the Clinical Context</head>
			<div2 id="NonFuncReq">
				<head>Non-Functional Requirements</head>
				<p/>
				<p>This section summarizes the non-functional requirements which the GELLO expression language meet.</p>
				<list role="ordered">
					<item>The syntax of the expression language is object-oriented (OO). </item>
					<item>The expression language is the means for accessing and manipulating data retrieved from an object-oriented data model. In the clinical context, such data model may be a RMIM – a refined view of the HL7 RIM. </item>
					<item>Expressions can be used to retrieve information from data sources, build decision criteria, and reason about specific data/values. Expressions are text strings that must conform to the definition of an expression in the GELLO language specification (section ‎6).</item>
					<item>Temporal data can be handled by expressions containing time-related relationships. Temporal operators are part of the HL7 RIM and can be referred to using the specified notation as described in section ‎5.12 of this document. </item>
					<item>The object-oriented approach allows modularity, encapsulation and extensibility. Thus use of GELLO:
						<list role="ordered">
							<item>Provides platform-independent support for mapping to any standard OO data model used. Therefore eliminating the need for implementation-specific encoding methods for information retrieval as part of knowledge content (guidelines, alerts, etc.).</item>
							<item>Simplifies the evaluation of clinical data objects.</item>
							<item>Facilitates sharing of decision logic and other computer expressions. </item>
						</list>
					</item>
				</list>
			</div2>
			<div2 id="UseCases">
				<head>Use Cases</head>
				<p>The following use cases define a goal-oriented set of interactions between GELLO and external actors. Actors are users and/or other systems that interact with GELLO. A use case is initiated by a user with a particular goal in mind, and complete successfully when such goal is satisfied. Use cases are defined in terms of actors (who) interacting with the system (what) for a particular purpose (goal) without dealing with system internals.</p>
				<p>User profiles: </p>
				<list role="unordered">
					<item>
						<emph role="strong">Medical experts</emph> not familiar with computer languages, with some basic experience with computers (e.g. word-processing, software packages)</item>
					<item>
						<emph role="strong">Researchers</emph> not familiar with computer languages, with string scientific knowledge and some basic experience with computers (e.g. word-processing, software packages)</item>
					<item>
						<emph role="strong">Health Economists</emph> with expertise in health economics and communication with health care providers, though not familiar with computer languages, with some basic experience with computers (e.g. word-processing, software packages)</item>
					<item>
						<emph role="strong">Epidemiologist</emph> with expertise in public health issues. S/he may not familiar with computer languages, with some basic experience with computers (e.g. word-processing, software packages)</item>
					<item>
						<emph role="strong">Knowledge engineers</emph> with programming experience and some basic medical knowledge.</item>
					<item>
						<emph role="strong">Programmers</emph> with ample programming experience and no medical expertise.</item>
				</list>
				<p>Scenarios:</p>
				<list role="unordered">
					<item>i. To write implementation-independent expressions that can be embedded in multiple clinical applications (guidelines, RIM derivation expression, template constraints, etc.) to retrieve patient information from an OO data model.</item>
					<item>ii. To write implementation-independent expressions that can be embedded in multiple clinical applications (guidelines, RIM derivation expression, template constraints, etc.) for representing knowledge and decision logic in a medical context.</item>
					<item>iii. To enable existing clinical applications ( guidelines, RIM derivation expression, template constraints, etc.)  to be made executable and populate them with data from electronic patient records (derives from (i) and (ii))</item>
					<item>iv. To allow researchers, health economists, epidemiologists and clinical and health care providers  to implement expressions that can be embedded in research, clinical, public health protocols, templates, or any application that requires expressions  that requires retrieval and evaluation of data from an OO data model</item>
					<item>v. To ease the evaluation of clinical data objects (derives from (i) and (ii)).</item>
					<item>vi. To facilitate sharing of decision logic and other computer-based expressions.</item>
				</list>
				<table id="usecase1">
					<caption>Use Case 1</caption>
					<tbody>
						<tr>
							<th>
								<emph role="strong">Use Case 1 </emph>
							</th>
							<th>
								<emph role="strong">Expressions  into clinical applications to retrieve patient-related data </emph>
							</th>
						</tr>
						<tr>
							<td>Description</td>
							<td>Map clinical knowledge into multiple clinical applications by embedding implementation-independent GELLO expressions to retrieve patient information from an OO data model</td>
						</tr>
						<tr>
							<td>Actors</td>
							<td>Clinicians, researchers, epidemiologists, knowledge engineers, programmers</td>
						</tr>
						<tr>
							<td>Assumptions</td>
							<td>
								<list role="unordered">
									<item>Expressions are strings that comply with the GELLO specification for expressions</item>
									<item>The general structure of the clinical application is correct, or there is a mechanism that validates it</item>
									<item>Patient and other clinical data sources are available and in an OO format compatible with the HL7 RIM</item>
								</list>
							</td>
						</tr>
						<tr>
							<td>Steps</td>
							<td>
								<list role="unordered">
									<item>GELLO expressions are embedded in the appropriate locations in the clinical application</item>
									<item>GELLO expressions satisfy the GELLO  syntax</item>
									<item>GELLO expressions are validated by a parser</item>
								</list>
							</td>
						</tr>
						<tr>
							<td>Variations</td>
							<td>
								<list role="unordered">
									<item>Parser detects errors and highlights them</item>
									<item>User corrects errors</item>
								</list>
							</td>
						</tr>
					</tbody>
				</table>
				<table id="usecase2">
					<caption>Use Case 2</caption>
					<tbody>
						<tr>
							<th>
								<emph role="strong">Use Case 2 </emph>
							</th>
							<th>
								<emph role="strong">Expressions in clinical applications for decision logic </emph>
							</th>
						</tr>
						<tr>
							<td>Description</td>
							<td>Represent knowledge and decision logic in multiple clinical applications by embedding implementation-independent GELLO expressions that can be evaluated.</td>
						</tr>
						<tr>
							<td>Actors</td>
							<td>Clinicians, researchers, epidemiologists, knowledge engineers, programmers</td>
						</tr>
						<tr>
							<td>Assumptions</td>
							<td>
								<list role="unordered">
									<item>Expressions are strings that comply with the GELLO specification for expressions</item>
									<item>The general structure of the clinical application is correct, or there is a mechanism that validates it</item>
									<item>Patient data sources are available and in an OO format compatible with the HL7 RIM</item>
								</list>
							</td>
						</tr>
						<tr>
							<td>Steps</td>
							<td>
								<list role="unordered">
									<item>GELLO expressions are embedded in the appropriate locations in the clinical application</item>
									<item>GELLO expressions satisfy the GELLO  syntax</item>
									<item>GELLO expressions are validated by a parser</item>
								</list>
							</td>
						</tr>
						<tr>
							<td>Variations</td>
							<td>
								<list role="unordered">
									<item>Parser detects errors and highlights them</item>
									<item>User corrects errors</item>
								</list>
							</td>
						</tr>
					</tbody>
				</table>
				<table id="usecase3">
					<caption>Use Case 3</caption>
					<tbody>
						<tr>
							<th>
								<emph role="strong">Use Case 3 </emph>
							</th>
							<th>
								<emph role="strong">Automatic population and execution of applications </emph>
							</th>
						</tr>
						<tr>
							<td>Description</td>
							<td>Derived from Use cases 1 and 2, clinical applications that contain GELLO expressions can be populated and executed independently of the environment.</td>
						</tr>
						<tr>
							<td>Actors</td>
							<td>Clinicians, researchers, epidemiologists, health economists</td>
						</tr>
						<tr>
							<td>Assumptions</td>
							<td>
								<list role="unordered">
									<item>Expressions have been previously validated and they conform to the GELLO syntax</item>
									<item>The general structure of the  application is correct, or there is a mechanism that validates it</item>
									<item>Data sources are available and in an OO format compatible with the HL7 RIM</item>
								</list>
							</td>
						</tr>
						<tr>
							<td>Steps</td>
							<td>
								<list role="unordered">
									<item>Execution engine enacts clinical application</item>
								</list>
							</td>
						</tr>
						<tr>
							<td>Variations</td>
							<td>
								<list role="unordered">
									<item>Validation to detect mismatched data types, classes</item>
								</list>
							</td>
						</tr>
					</tbody>
				</table>
				<table id="usecase4">
					<caption>Use Case 4</caption>
					<tbody>
						<tr>
							<th>
								<emph role="strong">Use Case 4 </emph>
							</th>
							<th>
								<emph role="strong">Evaluation of clinical objects </emph>
							</th>
						</tr>
						<tr>
							<td>Description</td>
							<td>Derived from Use cases 1 and 2, clinical data objects can be easily evaluated independently of the environment using GELLO expressions.</td>
						</tr>
						<tr>
							<td>Actors</td>
							<td>Clinicians, researchers, epidemiologists, knowledge engineers, programmers</td>
						</tr>
						<tr>
							<td>Assumptions</td>
							<td>
								<list role="unordered">
									<item>Expressions have been previously validated and they conform to the GELLO syntax</item>
									<item>The general structure of the clinical application is correct, or there is a mechanism that validates it</item>
									<item>Patient data sources are available and in an OO format compatible with the HL7 RIM</item>
								</list>
							</td>
						</tr>
						<tr>
							<td>Steps</td>
							<td>
								<list role="unordered">
									<item>Evaluate previously populated clinical data objects</item>
								</list>
							</td>
						</tr>
						<tr>
							<td>Variations</td>
							<td>
								<list role="unordered">
									<item>Validation to detect mismatched data types, classes</item>
								</list>
							</td>
						</tr>
					</tbody>
				</table>
				<table id="usecase5">
					<caption>Use Case 5</caption>
					<tbody>
						<tr>
							<th>
								<emph role="strong">Use Case 5</emph>
							</th>
							<th>
								<emph role="strong">Sharing decision logic and computer-based expressions</emph>
							</th>
						</tr>
						<tr>
							<td>Description</td>
							<td>To facilitate sharing of decision logic and other computer-based expressions independently of the  application.</td>
						</tr>
						<tr>
							<td>Actors</td>
							<td>Clinicians, researchers, epidemiologists, helath economists, knowledge engineers, programmers</td>
						</tr>
						<tr>
							<td>Assumptions</td>
							<td>
								<list role="unordered">
									<item>Expressions have been previously validated and they conform to the GELLO syntax</item>
									<item>Patient/medical data sources are available and in an OO format compatible with the HL7 RIM</item>
								</list>
							</td>
						</tr>
						<tr>
							<td>Steps</td>
							<td>
								<list role="unordered">
									<item>Reuse decision logic among applications</item>
								</list>
							</td>
						</tr>
						<tr>
							<td>Variations</td>
							<td>
								<list role="unordered">
									<item>Validation to detect mismatched data types, classes</item>
								</list>
							</td>
						</tr>
					</tbody>
				</table>
			</div2>
			<div2 id="ClinicalDataModel">
				<head>A Clinical Decision Support Data Model</head>
				<p>GELLO can provide full expression support for any properly defined object-oriented data model in general. In a clinical context, GELLO can interact with any HL7 RIM-based OO data model serving as intermediary to heterogeneous medical record systems.  </p>
				<p>Although this approach represents a paradigm shift in data representation, moving from time-stamped atomic data types to an object-oriented data model, it is an ongoing effort towards a standard for exchange, management and integration of clinical data much needed by the community.  </p>
			</div2>
			<div2 id="ExpressionsAndGuidelines">
				<head>Expressions and Clinical Guidelines</head>
				<p>The need for a language to formulate expressions to extract and manipulate clinical data is clear.  Ideally such a language should be (Click <loc href="http://smi-web.stanford.edu/people/tu/HL7/HL7SanDiegoJan2002.txt"> here</loc>to go to appropriate reference):</p>
				<list role="unordered">
					<item>vendor-independent</item>
					<item>platform-independent</item>
					<item>object-oriented and compatible with the HL7 RIM</item>
					<item>easy to read/write</item>
					<item>side-effect free. The result of an operation leaves the state of the system unchanged. The UML attribute isQuery will always return true for any GELLO expression.</item>
					<item>flexible</item>
					<item>extensible</item>
				</list>
				<p>The following section describes how GELLO complies with the above requirements and provides the mechanisms for handling clinical data stored in any OO compatible data model. </p>
			</div2>
		</div1>
		<div1 id="GELLOgoalsProp">
			<head>GELLO: Goals and Properties</head>
			<p>We propose GELLO as a platform-independent standard expression language for sharing and manipulating knowledge in a medical context. Specifically:</p>
			<list role="unordered">
				<item>GELLO is targeted to clinical applications that need an expression language for decision support. </item>
				<item>GELLO is vendor-independent by relying on a language specification that is not vendor-specific.</item>
				<item>GELLO is platform-independent.</item>
				<item>GELLO provides the mechanisms to access data through an OO data model, with strongly-typed expressions, via general purpose expression language.</item>
				<item>GELLO is a declarative language; expressions have no side effects.</item>
				<item>GELLO is extensible by adding new user-defined classes to the underlying OO data model.</item>
				<item>GELLO can refer to any data manipulation methods explicitly defined in the OO data model. The purpose of GELLO is to provide a robust syntax for expressions so data can be easily handled.</item>
				<item>GELLO expression evaluation is compatible with the v.3 RIM; hence each decision rule or guideline need not provide a separate mechanism for translation of data elements to/from host environments. </item>
				<item>The object-oriented approach allows modularity, encapsulation and extensibility. </item>
			</list>
			<p>Thus use of GELLO: </p>
			<list role="ordered">
				<item>provides platform-independent support for mapping to an OO data model, compatible with the v.3 HL7 RIM therefore eliminating the need for implementation-specific encoding methods for information retrieval as part of knowledge content (guidelines, alerts, etc.).</item>
				<item>simplifies the creation and updating of clinical data objects, and their evaluation.</item>
				<item>facilitates sharing of decision logic and other computer expressions. </item>
			</list>
			<p>
				<exhibit role="figure">
					<caption>GELLO and its relation to GLIF, RIM and other DSs and KBs. GELLO expression language can be embedded into various applications to provide the mechanisms for access and manipulation of OO data. The RMIM can be any view derived from the HL7 reference information model (RIM).</caption>
					<graphic source="GELLOandAppsWithoutMLM.gif"/>
				</exhibit>
			</p>
		</div1>
		<div1 id="OCL">
			<head>OCL</head>
			<p>OCL is the expression language used for specifying invariant constraints and pre- and –post-conditions in object models in the Unified Modeling Language (UML).  OCL is a strongly-typed pure expression language without any side effects. Although the evaluation of an OCL expression returns a value, the state of the underlying data model cannot change because of the evaluation of such an expression.  OCL is the result of a consensus effort towards a standard in object-oriented modeling and design. Since OCL is not a programming language, it does not rely on a specific platform.  All implementation issues are out of the scope of the language.  The OCL expression language satisfies the requirements we have outlined above for GELLO, namely:</p>
			<list role="unordered">
				<item>vendor-independent</item>
				<item>platform-independent</item>
				<item>object-oriented </item>
				<item>easy to read/write</item>
				<item>side-effect free</item>
				<item>flexible</item>
				<item>extensible.</item>
			</list>
			<p>In addition, OCL is:</p>
			<list role="unordered">
				<item>concise </item>
				<item>declarative.</item>
			</list>
			<p>The latest version of OCL documentation can be found at the <loc href=" http://www.omg.org/cgi-bin/doc?ptc/03-10-14.pdf "> Object Management Group website. </loc>
			</p>
			<div2 id="WhyOCL">
				<head>Why OCL?</head>
				<p>Besides OCL, we considered XQL, OWL and Java as options for defining a query and expression language. XQL is a query language designed specifically for XML documents. XML documents are unordered, labeled trees, with nodes representing the document entity, elements, attributes, processing instructions and comments. The implied data model behind XML neither matches that of a relational data model nor that of an object-oriented data model. XQL is a query language for XML in the same sense as SQL is a query language for relational tables. Since the HL7 RIM information model and the vMR data model are both object-oriented, it is clear that XQL is not an appropriate approach for an object-oriented query and expression language.</p>
				<p>The Web Ontology Language <loc href="http://www.w3.org/TR/2003/WD-owl-ref-20030221/">(OWL)</loc> is an ongoing effort by W3C to specify a language for publishing and sharing ontologies on the Web. OWL is intended to provide a language that can be used to describe entities and inherent relations between them in Web documents and applications. OWL can be used in applications that need to understand the content. In other words, OWL is more focused on machine interpretable definitions of concepts, rather than on the evaluation of expressions that include arithmetic and user-defined operators.  Given that OWL has focused on Web applications and the semantics of Web documents, we did not consider OWL a suitable approach for a language focused on query and computation of complex  clinical information.  (A list of current W3C recommendations and techincal documents can be found at the <loc href="http://www.w3.org/TR/">W3C website).        </loc>
				</p>
				<p>We also considered Java as an option for an expression language. Java meets most of the requirements in §‎2. Java is platform-independent, and object-oriented; it is relatively easy to read and write, and is flexible and extensible. However, Java is a full-fledged programming language with side-effects, and it is controlled by a single vendor. </p>
				<p>As noted above, OCL has arisen as a consensus effort at creating a standard approach to object-oriented modeling and design. OCL meets all our requirements and, importantly, OCL is already been used by various TCs and SIGs within HL7. </p>
				<p>A complete description of the OCL language can be found at the <loc href=" http://www.omg.org/cgi-bin/doc?ptc/03-10-14.pdf "> OMG website.</loc>
				</p>
				<p>In summary, GELLO removes some OCL unneeded capabilities as a language to be used as an expression language, plus the inclusion of particular UML data types and the HL7 types to enable it to reference instances of patient-specific data rather than just model types.</p>
			</div2>
		</div1>
		<div1 id="GELLO">
			<head>GELLO</head>
			<p>GELLO was conceived as a pure, declarative, strongly-typed expression language.  GELLO is free of side effects; it provides the mechanisms to access medical data through an OO data model compatible with the v.3 RIM. Several features of OCL have been incorporated into GELLO to make it a robust and flexible platform-independent language. </p>
			<p>GELLO follows the same conventions as OCL in relationship with the UML metamodel. In other words, every GELLO expression is written in the context of a specific type. Although GELLO is a subset of OCL, not all GELLO features are OCL features. We have preserved consistency as much as possible. The majority of GELLO operators are part of OCL, with the exception of some collection operators (firstN §‎5.10.18, lastN §‎5.10.19, and join §‎5.10.27) which have been added to support the requested functionality. As for data types, all GELLO built-in data types are part of OCL including the Tuple data type §‎5.1.4 (the abstract specification for OCL data types can be found at the <loc href="http://www.omg.org/cgi-bin/doc?ptc/03-10-14.pdf">OMG website</loc>). In this section, the use of HL7 classes as a data model is introduced. All basic data types are provided by GELLO (§‎5.1), while model types –or classes- are defined in the underlying HL7 data model (§‎5.1.2). Variables (§‎5.4) are strongly typed named GELLO expressions that can be used at any place a GELLO expression ca be used (§‎5.5.2).  In order to preserve GELLO as a side-effect free language, the creation of objects as instances of HL7 classes is delegated to the HL7 RIM.  This will allow any UML based framework with a full reference implementation of RIM and data types to perform these functions as required </p>
			<p>In summary, </p>
			<p>GELLO incorporates most of OCL functionality with the exception of some unneeded capabilities have been removed a)pre and post conditions for constraints -not used in GELLO and b) invariants -also for constraints. The UML ITS implements the semantics of the HL7 Abstract Data Types in such a way that HL7 data types are mapped into the core UML and OCL kernel data types where such mappings are appropriate. Such functionality compatible with the HL7 RIM is used by GELLO, hence enabling it to reference instances of patient-specific data independent of platform, vendor, and data model.</p>
			<div2 id="GELLOtypes">
				<head>GELLO Types</head>
				<p>GELLO is a strongly-typed language. This means that every expression must have a known type. There are two type categories: predefined types and model (user-defined) types.</p>
				<p>Predefined types include basic types, collection types and tuple type.</p>
				<div3 id="BasicTypes">
					<head>Basic Types</head>
					<p>A primitive data type is named by its reserved word. They are: Boolean, integer, real, string.</p>
					<p/>
					<p>Having basic data types allows us to create literals of the form:</p>
					<list role="unordered">
						<item>let aNum : integer = 5</item>
						<item>let xNum: real = 5.6</item>
						<item>let aString: string = ‘abc’         (note single quotes)</item>
						<item>let aBoolean: Boolean = true</item>
					</list>
					<div4 id="Boolean">
						<head>Boolean</head>
						<p>The Boolean type in GELLO is a three-valued type. A GELLO Boolean type can have one of three possible values: true, false, and unknown.  GELLO Boolean operators are described in §‎5.9.6.  </p>
					</div4>
					<div4 id="Integer">
						<head>Integer</head>
						<p>Integer represents the mathematical natural numbers. Integer is a subtype of real. Arithmetic operators are described in §‎5.9.</p>
					</div4>
					<div4 id="Real">
						<head>Real</head>
						<p>Real represents the mathematical concept of real values. Arithmetic operators are described in §‎5.9.</p>
					</div4>
					<div4 id="String">
						<head>String</head>
						<p>Strings are sequences of characters. Literal strings are enclosed with single quotes. The available operations for strings are described in §‎5.9.7.</p>
					</div4>
					<div4 id="UnknownBoolean">
						<head>Unknown and Null as third Boolean value</head>
						<p>In the previous versions of this specification there was a discrepancy between GELLO unknown and HL7 RIM Null as third Boolean value. This discrepancy has been resolved by the <xspecref spec="datatypes-its-uml" alt="UML ITS data types"/>, which map unknown into Null and vice versa.</p>
					</div4>
					<div4 id="TypeHierarchy">
						<head>Basic Type Hierarchy and Type Conformance Rules </head>
						<p>Integer is a subtype of real. Hence, integer conforms to real. </p>
					</div4>
				</div3>
				<div3 id="ModelTypes">
					<head>Model Types</head>
					<p>Model types refer to user-defined classes in the underlying data model. References to such types include either a full description name, e.g. PhysicalQuantity or its alias, e.g. PQ. Both examples refer to the model type PhysicalQuantity as defined in the HL7 RIM. </p>
					<div4 id="ModelTypeHierarchy">
						<head>Model Type Hierarchy</head>
						<p>For any given class in the data model, if class B is a subtype of class A, then class B conforms to class A. </p>
					</div4>
				</div3>
				<div3 id="CollectionTypes">
					<head>Collection Types</head>
					<p>A GELLO collection is an abstract type with concrete collection types as subtypes. As in OCL, a GELLO collection has three types: Set, Bag and Sequence.</p>
					<list role="unordered">
						<item>A <emph role="strong">Set</emph>is the mathematical set. It does not contain any duplicate elements. All elements have the same type.</item>
						<item>A <emph role="strong">Bag </emph> is a collection of elements. Duplicates are allowed. All elements in a Bag have the same type.</item>
						<item>A <emph role="strong">Sequence </emph> is a collection with ordered elements. Duplicates are allowed. All elements in a Sequence must have the same type.</item>
					</list>
					<p>Notation for collections is as follows:</p>
					<list role="unordered">
						<item>typeOfCollection {element1, …, elementn}, </item>
					</list>
					<p>Where </p>
					<list role="unordered">
						<item>typeOfCollection is one of Set, Bag, Sequence; and {element1, …, elementn} is a list of the elements –all with the same type- separated by commas. </item>
					</list>
					<p>When creating a sequence of integers, the list of elements can be replaced by an interval specification consisting of two literals of type integer intLiteral1 and intLiteral2 separated by ‘..’: Sequence{1..5} is equivalent to Sequence{1,2,3,4,5}.</p>
					<p>Collections can be specified by a literal –as defined above- or as a result of an operation over a collection. See §‎5.10 for collection operators.</p>
					<div4 id="CollColl">
						<head>Collections of Collections</head>
						<p>Collections of collections are not flattened automatically. Flattening is carried out by means of an explicit function making the effect of the flattening process clear. Flattening in OCL applies to all collection types. The indicated rules for flattening can be applied recursively until the element type of the result is a non-collection type.</p>
					</div4>
					<div4 id="CollHierarchy">
						<head>Collection Type Hierarchy and Type Conformance Rules</head>
						<p>Set, Bag and Sequence are all subtypes of Collection. </p>
					</div4>
				</div3>
				<div3 id="TupleType">
					<head>Tuple Type</head>
					<p>The tuple type is part of OCL and hence of the GELLO grammar. A tuple combines elements with different types into an aggregate type. Each tuple part has a name, a type and a value. A tuple part can be a single element or a collection. The type of a tuple part can be of a basic or a model type. </p>
					<p>The syntax of a tuple is as follows:  Tuple{ label1: type1= value1, …, labeln: typen = valuen}, Where labeli is the label of the element <emph>ith</emph>, typei and valuei  are the valid type and value respectively. </p>
					<p>Tuples can be used as a return type from expressions that retrieve information from more than one source such as joins (§‎5.10.27). GELLO provides some tuple operators to access the information returned by an expression. These operators are described in §‎5.11.</p>
				</div3>
				<div3 id="EnumTypes">
					<head>Enumeration Types</head>
					<p>Enumeration are datatypes in UML. They define a number of literals as possible values of the enumeration.</p>
				</div3>
			</div2>
			<div2 id="Names">
				<head>Names</head>
				<p>Names may be used in expressions to bind domain elements to values. If the name of an attribute or an operation appears in an expression, the class it belongs to must be explicitly referred to.</p>
			</div2>
			<div2 id="Properties">
				<head>Properties</head>
				<p>A property of a class can be an attribute (§‎5.3.1) or an operation (§‎5.3.2). The syntax for referring to a property of an instance of class is: InstanceOfClass.property, which is consistent with the ‘dot’ notation of an OO data model.</p>
				<div3 id="Attributes">
					<head>Attributes</head>
					<p>Attributes are named properties of class that describe the characteristics that instances of such class can have.  For example, aPerson is an instace of the class Person with an attribute FirstName, we refer to a person’s name by writing aPerson.FirstName, where aPerson is an instace of the Person class and FirstName is an attribute of that class.</p>
				</div3>
				<div3 id="Operations">
					<head>Operations</head>
					<p>An operation is the specification of a service that can be requested from an object of the class. The name of an operation may appear in a GELLO expression only as a part of a full method invocation expression. That is, along with the name of the operation and its arguments, the class or object it belongs to must be explicitly referred to. Operations are side effect-free, they do not change the state of any object.</p>
					<p/>
					<p>The HL7 data model provides classes and associated operations. These operations provide the functionality for handling the clinical data stored in the data model.</p>
					<div4 id="OperationParam">
						<head>Operation Parameters</head>
						<p>Parameters are name argument values passed to an operation or method in a method call. If required, arguments must be included in the invocation separated by commas. The type of each value must match the type of the expected argument in each position in the argument list. </p>
					</div4>
				</div3>
			</div2>
			<div2 id="ContextRefs">
				<head>Context and References to Contextual Instances</head>
				<div3 id="ContextSelf">
					<head>Context, Self and Implicit References to Contextual Instances</head>
					<p>Evaluation of expressions requires a contextual instance of a specific type. The context of an expression is explicitly defined using the context expression. 
					The syntax is as follows: context [alias:] Class.  Where class indicates the ‘primary’ class in the data model from which the following expression 
					will be evaluated. Context Statements cannot be nested. The notation is as follows:</p>
					<p/>
					<exhibit role="example">
						<pre>Context [alias: ]Class 
GELLO expressions with a reference to either alias or class name
						</pre>
					</exhibit>
					<p>The ‘primary’ class is the class that defines the context where the given expressions are to be evaluated. 
					For example (using the data model depicted in Figure 6):</p>
					<exhibit role="example">
						<pre>Context Patient
…  GELLO expressions with Patient
						</pre>
					</exhibit>
					<p>Sets up the context as all the instances of the ‘primary’ class Patient in the data model.:</p>
					<p/>
					<p>The following context definition:</p>
					<exhibit role="example">
						<pre>Context p: Patient
p.age&gt; 50
						</pre>
					</exhibit>
					<p>sets the context over which later expressions will be evaluated against as all patients older than 50 years of age.</p>
					<exhibit role="example">
						<pre>Context Patient
Self. ID = "123abc"
						</pre>
					</exhibit>
					<p>sets the context of a single patient with a patient ID = "123abc"over which later expressions will be evaluated against.</p>
					<p/>
					<p>Note the use of self as an implicit reference to Patient.   </p>
					<p>Thus, for example, an expression such as:</p>
					<exhibit role="example">
						<pre>ProblemList → exists(Code.equals(Factory.CodedValue("Asthma")))
within the previously defined patient context, this expression is equivalent to:
					
ProblemList → exists(Code.equals(Factory.CodedValue("Asthma")) and PatientID="123abc")
						</pre>
					</exhibit>
				</div3>
				<div3 id="PackContext">
					<head>Package Context and Pathname</head>
					<p>Package context can be used to group classes, while Pathnames can be used to refer to the classes contained in them. The notation is ad follows:</p>
					<p/>
					<exhibit role="example">
						<pre>Package packageName ::
   Context contextName :
      GELLOexpressions
EndPackage</pre>
					</exhibit>
					<p/>
					<p>For PathName:</p>
					<exhibit role="example">
						<pre>packageName :: [packageNamei ::]* TypeName
						</pre>
					</exhibit>
				</div3>
				<div3 id="NavAssoc">
					<head>Navigation through Associations</head>
					<p>Access to objects and their properties  can be performed by navigating through associations of objects. The notation is as follows:</p>
					<exhibit role="example">
						<pre>context Object :
   self.associatedObject
						</pre>
					</exhibit>
					<p>For example:</p>
					<exhibit role="example">
						<pre>context Patient:
   self.Medications
					   </pre>
					</exhibit>
					<p>returns all the medications a patient is taking, while:</p>
					<exhibit role="example">
						<pre>context Patient:
   self.Medications["aspirin"]
						</pre>
					</exhibit>
					<p>returns all the instances of medication = aspirin for a given patient.</p>
				</div3>
			</div2>
			<div2 id="VarDec">
				<head>Variable Declaration</head>
				<p>A variable declaration declares a variable name and binds it to a type. A variable can only hold a value of the same type. A declaration defines the name for a variable inside a program. Each variable declaration must have a scope (§‎5.5.2). </p>
				<p/>
				<p>Variables  are declared using the let OCL expression. The type of the variable can be either one of the basic built-in GELLO data types §‎5.1.1, 
				GELLO collection types §‎5.1.3, GELLO tuple type §‎5.1.4, or a class from the underlying data model §‎5.1.2.. The type of the return value of an 
				expression must match the type of the variable to which such a value is to be assigned. Once an expression is bound to a variable, it cannot be 
				changed. The syntax for let expressions is as follows:</p>
				<exhibit role="example">
					<pre>let varName: type = Expression.
					</pre>
				</exhibit>
				<p>Where varName is a string that is the name of the variable with type type, and Expression is a valid GELLO expression. </p>
				<p>An example of a variable of basic type:</p>
				<exhibit role="example">
					<pre>let threshold_for_osteodystrophy : integer = 70 			         …(1)
					</pre>
				</exhibit>
				<p>If a variable references an instance of a model type, the Expression must include the Factory static method as in: 
				Factory.class("argument list"),where class is a class in model class. Factory takes only one string literal as argument list. 
				As a result, it binds a name varName to an object of type class. The full notation:</p>
				<exhibit role="example">
					<pre>let  variableName: type = Factory.class("argument list")
An example:
   let potassium: PhysicalQuantity = Factory.PhysicalQuantity("76 kg")   	…(2)
				   </pre>
				</exhibit>
				<p>An example when a variable references a collection type:</p>
				<exhibit role="example">
					<pre>let Myobservations: set = observation(select(coded_concept= ‘abc’)		…(3)
					</pre>
				</exhibit>
				<p>An example when the variable is a tuple:</p>
				<exhibit role="example">
					<pre>let variousPatientData : tuple = patient(join(paramList1; paramList2; CondExp; ParamList3) 	…(4)
					</pre>
				</exhibit>
				<p>In (1) threshold_for_osteodystrophy is a GELLO built-in basic type and hence we create the variable and assign the value of 70 in the same operation. </p>
				<p>In (2), potassium has a type PhysicalQuantity which is a class in the data model, and we need to create a reference to an instance of that class before assigning it to the variable.</p>
				<p>In (3) Myobservations is a set, which is a GELLO collection type. Observations contains all the instances of the class observation with a coded concept = ‘abc’.</p>
				<p>In (4) variousPatientData is a tuple containing information related to the current patient. Such information is from different sources and has different types, hence it is grouped into an aggregated type tuple. See §‎5.10.27 for the full notation of the join operator.</p>
				<p/>
				<p>In summary, to create a variable with a basic data type, the syntax is:</p>
				<exhibit role="example">
					<pre>let variable : type = expression
					</pre>
				</exhibit>
				<div3 id="RefsClass">
					<head>Declaring References to Instances of Classes</head>
					<p>Declaring a new reference to class is an operation implemented from an external factory. Although the functionality of this 
					approach is beyond the scope of this document, below we describe the syntax of the operation. This approach 
					satisfies both the HL7 RIM abstract specification and the UML ITS specification, and is similar to that approved by the Java-SIG.</p>
					<p>A static factory method "Factory" takes only one string literal as argument list. As a result it binds a name (variableName) to an 
					object of type class, where class is a model class. The notation is as follows:</p>
					<exhibit role="example">
						<pre>let  variableName: type = Factory.class("argument list")
						</pre>
					</exhibit>
					<p>An example:</p>
					<exhibit role="example">
						<pre>let aQuantity: PhysicalQuantity = Factory.PhysicalQuantity("76 kg")
						
Where "76 kg" is the literal form of an instance of PhysicalQuantity, 
with 76 being the value and "kg" being the code for kilogram 
in the Unified Code for Units of Measure (UCUM).
						</pre>
					</exhibit>
				</div3>
				<div3 id="Scope">
					<head>Scope of Declarations</head>
					<p>The scope of a declaration is the portion of a program where the declared entity is valid and can be referred to. 
					The scoping rules must be defined separately by each standard. </p>
				</div3>
			</div2>
			<div2 id="DefConst">
				<head> &lt;&lt;definition&gt;&gt; Constraint</head>
				<p>&lt;&lt;definition&gt;&gt; constraints must be attached to a classifier and may only contain let definitions. 
				All variables and operations defined in the &lt;&lt;definition&gt;&gt; constraint are known in the same context as if they 
				were properties of the classifier, and can be used in the same manner. In a way, these &lt;&lt;definition&gt;&gt; constraints 
				become pseudo-attributes and –operations of the classifier, and can be used in a GELLO expression in the same way 
				attributes of a classifier are used. The notation for &lt;&lt;definition&gt;&gt; is as follows. Note the use of ‘def’ keyword:</p>
				<exhibit role="example">
					<pre>context Patient def:
   let varName: type = Expression.
				   </pre>
				</exhibit>
			</div2>
			<div2 id="Reflection">
				<head>Reflection</head>
				<p>Within OCL, there are properties that apply to all objects in the underlying data model. Reflection properties can be used to determine:</p>
				<p/>
				<list role="unordered">
					<item>The direct type of an object/variable</item>
					<item>The supertype of an object</item>
				</list>
				<p/>
				<p>The following operations from OCL have been incorporated into GELLO:</p>
				<list role="unordered">
					<item>object.oclTypeOf(t: OclType): Boolean</item>
					<item>The evaluation of oclTypeOf returns true if the direct type of the object and t are the same:  
					aPerson.oclTypeOf(t: Person)  returns true if Person is the direct type of aPerson.</item>
					<item>object.oclKindOf(t: OclType): Boolean</item>
				</list>
				<p/>
				<p>Similarly, the evaluation of oclKindOf returns true if the t is either the direct type or one of the supertypes of
				 an object: aPatient.oclKindOf(t: Person) returns true if Person is either a direct type or a supertype of aPatient.</p>
			</div2>
			<div2 id="Casting">
				<head>Casting</head>
				<p>Every expression written in GELLO must have a type that is matched to a built-in or a model type. It is possible 
				however, to change the type of an expression into another type depending on the context in which such an expression 
				occurs. A specific conversion from type A to type B allows an expression of type A to be treated as type B. This is called 
				casting and OCL provides an operation that has been incorporated into GELLO:  oclAsType. </p>
			</div2>
			<div2 id="BuiltInOps">
				<head>Built-in Operators</head>
				<p>Infix operators are allowed in GELLO. Operator precedence is as defined in §‎5.12 and the OCL specification (see page 2.8  <loc href="http://www.omg.org/cgi-bin/doc?ptc/03-10-14.pdf">OCL</loc>).  The following arithmetic operators are supported by GELLO. Other infix operators are allowed if and only if the used model type defines those operators with the correct signature.</p>
				<div3 id="ArithOps">
					<head>Arithmetic Operators "+", "-", "*"</head>
					<p>This section presents the evaluation function for "+" and the allowed types. The types for "-", and "*" are the same as those for "+", and so is the evaluation function (see page 5.11 <loc href="http://www.omg.org/cgi-bin/doc?ptc/03-10-14.pdf"> OCL</loc>). The evaluation function for "+" is defined as follows:</p>
					<exhibit role="example">
						<pre>	
F+(V1,V2)= V1 + V2     If V1 and V2 are both integers or reals
         = undefined   otherwise 

Types for "+":
• (integer x integer) → integer
• (integer x real) → real
• (real x integer) → real
• (real x real) → real
						</pre>
					</exhibit>
				</div3>
				<div3 id="divOp">
					<head>Arithmetic Operator "/"</head>
					<p>The result of a division is always a real number even if the arguments are integers.</p>
					<exhibit role="example">
						<pre>
		
F/ (V1,V2)= V1 / V2     If V1 and V2 are either integers or reals, and V2 &lt;&gt; 0
          = undefined   otherwise 

Types for "/":
• (integer x integer) → real
• (integer x real) → real
• (real x integer) → real
• (real x real) → real
</pre>
					</exhibit>
				</div3>
				<div3 id="modOp">
					<head>Arithmetic Operators "div" and "mod"</head>
					<p>The result of integer division "div", and modulus "mod" operations is always an integer number. The arguments must both be integers. The following is the evaluation function and allowed types for integer division. The same applies for modulus. </p>
					<exhibit role="example">
						<pre>
Fdiv(V1,V2)= V1 div V2     If V1 and V2 are both integers and V2 &lt;&gt; 0
           = undefined     otherwise 

Type "div" and "mod":
• (integer x integer) → integer	
					</pre>
					</exhibit>
				</div3>
				<div3 id="unaryMinusOp">
					<head>Arithmetic Operator unary minus "-"  </head>
					<p>The following are the evaluation function and allowed types for unary minus.</p>
					<exhibit role="example">
						<pre>
					
F-(V1)= -V1         If V1 is either an integer or a real 
      = undefined   otherwise 

Types for unary minus "-":
• (integer) → integer
• (real) → real
					</pre>
					</exhibit>
				</div3>
				<div3 id="compOps">
					<head>Comparison Operators "=", "&gt;", "&lt;", "&gt;=", "&lt;=", "&lt;&gt;"</head>
					<p>The allowed types and evaluation rule for the operators "=", "&gt;", "&lt;", "&gt;=", "&lt;=", "&lt;&gt;" are as follows. All these operators return undefined if one or both of the comparands is undefined.</p>
					<exhibit role="example">
						<pre>
					
Types for "=", "&gt;", "&lt;", "&gt;=", "&lt;=", "&gt;&lt;":
• (real x real)→ truth_value   
• (real x integer)→ truth_value   
• (integer x real)→  truth_value   
• (integer x integer)→ truth_value
• (string x string)→ truth_value       Only valid for "=" and &lt;&gt; 
• (boolean x boolean)→ truth_value     Only valid for "=" and &lt;&gt;  
					</pre>
					</exhibit>
					<p>Definition of the evaluation function F&gt; (V1, V2). The evaluation function is the same for the other operators:</p>
					<exhibit role="example">
						<pre>
F&gt;(V1,V2)= true        If V1 and V2  are both either integers or reals and V1 &gt; V2 
         = false       Else if V1 and V2 are both either integers or reals and V1 ≤ V2
         = undefined   otherwise 
					</pre>
					</exhibit>
					<p>Note: for the cases (real x integer) and (integer x real) there is an implicit casting of integer to real, hence both cases are evaluated as (real x real) after casting.</p>
					<p>Definition of the evaluation function F= (V1, V2). The evaluation function is the same for F&lt;&gt; (V1, V2) when the operators are both strings of Booleans.</p>
					<exhibit role="example">
						<pre>
F=(V1,V2)= true         If V1 and V2  are both strings or Booleans  and V1 = V2 
         = false        Else if V1 and V2  are both strings or Booleans  and V1 &lt;&gt; V2
         = undefined    otherwise 
					</pre>
					</exhibit>
				</div3>
				<div3 id="absMathOp">
					<head> Mathematical Operator "abs"</head>
					<p>The mathematical operator "abs" returns the absolute value of a number.</p>
					<exhibit role="example">
						<pre>
Fabs(V1)= V1          If V1 is  a positive integer or real number
	= -V1         Else if V1 is a negative integer or real number
        = undefined   otherwise 

Type "abs"
• (integer) → integer	
• (real) → real	</pre>
					</exhibit>
				</div3>
				<div3 id="acosMathOp">
					<head> Mathematical Operator "acos"</head>
					<p>The mathematical operator "acos" returns the arc cosine of an angle in the range of 0.0 through pi. If the argument is not a number, is undefined or its absolute value is "&gt;" 1, the the returning value is undefined</p>
					<exhibit role="example">
						<pre>
Facos(V1)= acos(V1)    If V1 is  an  integer or real number and abs(V1) ≤ 1
         = undefined   otherwise 

Type "acos"
• (integer) → real	
• (real) → real	</pre>
					</exhibit>
				</div3>
				<div3 id="asinMathOp">
					<head> Mathematical Operator "asin"</head>
					<p>The mathematical operator "asin" returns the arc sine of an angle, in the range of -pi/2 through pi/2.</p>
					<exhibit role="example">
						<pre>
Fasin(V1)= asin(V1)    If V1 is  an  integer or real number and abs(V1) ≤ 1
         = 0           Else if V1 = 0
         = undefined   otherwise 

Type "asin"
• (integer) → real	
• (real) → real	</pre>
					</exhibit>
				</div3>
				<div3 id="atanMathOp">
					<head> Mathematical Operator "atan"</head>
					<p>The mathematical operator "atan" returns the arc tangent of an angle, in the range of -pi/2 through pi/2.</p>
					<exhibit role="example">
						<pre>
Fatan(V1)= atan(V1)    If V1 is  an  integer or real number and abs(V1) ≤ 1
         = 0           Else if V1 = 0
         = undefined   otherwise 

Type "atan"
• (integer) → real	
• (real) → real	</pre>
					</exhibit>
				</div3>
				<div3 id="ceilingMathOp">
					<head> Mathematical Operator "ceiling"</head>
					<p>The mathematical operator "ceiling" returns the smallest integer value that is not less than the argument.</p>
					<exhibit role="example">
						<pre>
Fceiling(V1)= ceiling(V1) If V1 is  a real
            = V1          Else if V1 an  integer 
            = 0           Else if V1 = 0
            = -0          Else if V1 &lt; 0 and V1 &gt; -1.0
            = undefined   otherwise 

Type "ceiling"
• (integer) → integer	
• (real) → integer	</pre>
					</exhibit>
				</div3>
				<div3 id="cosMathOp">
					<head> Mathematical Operator "cos"</head>
					<p>The mathematical operator "cos" returns the trigonometric cosine of an angle.</p>
					<exhibit role="example">
						<pre>
Fcos(V1)= cos(V1)    If V1 is  an  integer or real number and V1 is the value of an angle in radians
        = undefined  otherwise 

Type "cos"
• (integer) → real	
• (real) → real	</pre>
					</exhibit>
				</div3>
				<div3 id="expMathOp">
					<head> Mathematical Operator "exp"</head>
					<p>The mathematical operator "exp" returns the value e^a, where e is the base of the natural logarithms..</p>
					<exhibit role="example">
						<pre>
Fexp(V1)= e^(V1)       If V1 is  an  integer or real number 
         = + infinity  Else if V1 is positive infinity
         = 0           Else if V1 is negative infinity
         = undefined   otherwise 

Type "exp"
• (integer) → real	
• (real) → real	</pre>
					</exhibit>
				</div3>
				<div3 id="floorMathOp">
					<head> Mathematical Operator "floor"</head>
					<p>The mathematical operator "floor" returns the largest integer value that is not greater than the argument.</p>
					<exhibit role="example">
						<pre>
Ffloor(V1)= floor(V1)   If V1 is a real number
          = V1          Else if V1 an integer number
          = V1          Else if V1= 0 or V1= infinity
          = undefined   otherwise 

Type "floor"
• (integer) → integer	
• (real) → integer	</pre>
					</exhibit>
				</div3>
				<div3 id="logMathOp">
					<head> Mathematical Operator "log"</head>
					<p>The mathematical operator "log" returns the natural logarithm (base e) of a number.</p>
					<exhibit role="example">
						<pre>
Flog(V1)= log(V1)      If V1 is  an  integer or real number &gt; 0
        = + infinity   Else if V1 is positive infinity
        = - infinity   Else if V1 = 0
        = undefined    otherwise 

Type "log"
• (integer) → real	
• (real) → real	</pre>
					</exhibit>
				</div3>
				<div3 id="maxMathOp">
					<head> Mathematical Operator "max"</head>
					<p>The mathematical operator "max" returns the greater of two numbers.</p>
					<exhibit role="example">
						<pre>
Fmax(V1,V2)= V1          If V1 &gt; V2
           = V1          Else if V1 = V2
           = V2          Else if V2 &gt; V1
           = undefined   otherwise 

Type "max"
• (integer x integer) → integer
• (integer x real) → real
• (real x integer) → real
• (real x real) → real	</pre>
					</exhibit>
				</div3>
				<div3 id="minMathOp">
					<head> Mathematical Operator "min"</head>
					<p>The mathematical operator "min" returns the smaller of two numbers.</p>
					<exhibit role="example">
						<pre>
Fmin(V1,V2)= V1          If V1 &lt; V2
           = V1          Else if V1 = V2
           = V2          Else if V2 &lt; V1
           = undefined   otherwise 

Type "min"
• (integer x integer) → integer
• (integer x real) → real
• (real x integer) → real
• (real x real) → real	</pre>
					</exhibit>
				</div3>
				<div3 id="powMathOp">
					<head> Mathematical Operator "power"</head>
					<p>The mathematical operator "power" returns the value of the first argument raised to the power of the value of the second argument</p>
					<exhibit role="example">
						<pre>
Fpower(V1,V2)= V1^V2         If V1 and V2 are valid arguments
             = 1             Else if V2= 0
             = V1            Else if V2= 1
             = abs(V1)^V2    Else if V1&lt; 0 and V2 is a finite even integer
             = -(abs(V1)^V2) Else if V1&lt; 0 and V2 is a finite odd integer
             = undefined     Else if V1&lt; 0 and V2 finite and not an integer
             = undefined     Else if V2 is undefined
             = undefined     Else if V1 is undefined and V2!= 0
             = + infinity    Else if abs(V1)&gt; 1 and V2= + infinity 
             = + infinity    Else if V1= 0 and V2&lt; 0 or V1= + infinity and V2&gt; 0
             = + infinity    Else if V1= -0 and V2&lt; 0 and V2 is negative finite odd integer  or  
                             V1= -infinity and V2&gt; 0 and V2 != finite odd integer  
             = - infinity    Else if V1=-0 and V2 is a negative finite odd integer  or V1= -infinity and 
                             V2 is a positive finite odd integer                     
             = 0             Else if abs(V1)&gt; 1 and V2 = -infinity or abs(V1)&lt; 1 and V2 = +infinity
             = 0             Else if V1=0 and V2&gt; 0 or V1=+ infinity and V2&lt; 0
             = 0             Else if V1= -0 and V2&gt; 0 and V2!= finite odd number  or V1= -infinity 
                             and V2&lt; 0 and V2!= finite odd integer 
             = -0            Else if V1=-0 and  V2= positive odd number or V1= -infinity  and V2  is  
                             a negative odd integer                  
             = V2            Else if V2&lt; V1
             = undefined     otherwise 

Type "power"
• (integer x integer) → integer
• (integer x real) → real
• (real x integer) → real
• (real x real) → real	</pre>
					</exhibit>
				</div3>
				<div3 id="randMathOp">
					<head> Mathematical Operator "rand"</head>
					<p>The mathematical operator "rand" returns a positive real number in the range [0.0, 1.0).</p>
					<exhibit role="example">
						<pre>
Frand()= V1   Where 0.0 ≤ V1 &lt; 1.0

Type "rand"
• () → real</pre>
					</exhibit>
				</div3>
				<div3 id="sinMathOp">
					<head> Mathematical Operator "sin"</head>
					<p>The mathematical operator "sin" returns the trigonometric sine of an angle.</p>
					<exhibit role="example">
						<pre>
Fsin(V1)=  sin(V1)    If V1 is an integer or real number representing the value of an angle in radians
        = 0           Else if V1 = 0
        = undefined   otherwise 

Type "sin"
• (integer) → real
• (real) → real	</pre>
					</exhibit>
				</div3>
				<div3 id="sqrtMathOp">
					<head> Mathematical Operator "sqrt"</head>
					<p>The mathematical operator "sqrt" returns the square root of a number.</p>
					<exhibit role="example">
						<pre>
Fsqrt(V1)=  +sqrt(V1)  If V1 is an integer or real number and V1 &gt;= 0
         = 0           Else if V1 = 0
         = undefined   Else if V1 &lt; 0
         = undefined   otherwise 

Type "sqrt"
• (integer) → real
• (integer) → integer
• (real) → real	</pre>
					</exhibit>
				</div3>
				<div3 id="tanMathOp">
					<head> Mathematical Operator "tan"</head>
					<p>The mathematical operator "tan" returns the trigonometric tangent of an angle.</p>
					<exhibit role="example">
						<pre>
Ftan(V1)=  tan(V1)    If V1 is an integer or real number representing the value of an angle in radians
        = 0           Else if V1 = 0
        = undefined   otherwise 

Type "tan"
• (integer) → real
• (real) → real	</pre>
					</exhibit>
				</div3>
				<div3 id="BooleanOps">
					<head>Boolean Operators</head>
					<p>The valid types and evaluation functions for Boolean operators "and", "or", "xor" and "not" are given as follows:</p>
					<exhibit role="example">
						<pre>
Types for "and", "or", "xor"and "implies":
(truth_value x truth_value) → truth_value

Types for "not":
(truth_value) → truth_value
					</pre>
					</exhibit>
					<p>Values of the evaluation functions (as in <loc href="http://www.omg.org/cgi-bin/doc?ptc/03-10-14.pdf">OCL p5.12</loc>):</p>
					<table id="truthValues">
						<caption>Truth Values for Logic Operators</caption>
						<tbody>
							<tr>
								<th>V1</th>
								<th>V2</th>
								<th>V1 and V2</th>
								<th>V1 or V2</th>
								<th>V1 xor V2</th>
								<th>not V1</th>
								<th>V1 implies V2</th>
							</tr>
							<tr>
								<td>false</td>
								<td>false</td>
								<td>false</td>
								<td>false</td>
								<td>false</td>
								<td>true</td>
								<td>true</td>
							</tr>
							<tr>
								<td>false</td>
								<td>true</td>
								<td>false</td>
								<td>true</td>
								<td>true</td>
								<td>true</td>
								<td>true</td>
							</tr>
							<tr>
								<td>true</td>
								<td>false</td>
								<td>false</td>
								<td>true</td>
								<td>true</td>
								<td>false</td>
								<td>false</td>
							</tr>
							<tr>
								<td>true</td>
								<td>true</td>
								<td>true</td>
								<td>true</td>
								<td>false</td>
								<td>false</td>
								<td>true</td>
							</tr>
							<tr>
								<td>false</td>
								<td>unknown</td>
								<td>false</td>
								<td>unknown</td>
								<td>unknown</td>
								<td>true</td>
								<td>true</td>
							</tr>
							<tr>
								<td>true</td>
								<td>unknown</td>
								<td>unknown</td>
								<td>true</td>
								<td>unknown</td>
								<td>false</td>
								<td>unknown</td>
							</tr>
							<tr>
								<td>unknown</td>
								<td>false</td>
								<td>false</td>
								<td>unknown</td>
								<td>unknown</td>
								<td>unknown</td>
								<td>unknown</td>
							</tr>
							<tr>
								<td>unknown</td>
								<td>true</td>
								<td>unknown</td>
								<td>true</td>
								<td>unknown</td>
								<td>unknown</td>
								<td>true</td>
							</tr>
							<tr>
								<td>unknown</td>
								<td>unknown</td>
								<td>unknown</td>
								<td>unknown</td>
								<td>unknown</td>
								<td>unknown</td>
								<td>unknown</td>
							</tr>
						</tbody>
					</table>
					<p>A note on truth values and Boolean operators: GELLO is intended to support extended truth values: true, false and unknown, while HL7 Boolean values in the HL7 RIM data model are true, false and NULL. The discrepancy between unknown and NULL is resolved by the UML ITS.</p>
				</div3>
				<div3 id="StringOps">
					<head>String Operators "size", "concat", "toUpper", "toLower" "substring", "=" and "&lt;&gt;"</head>
					<p>The types and evaluation functions for string operators are given as follows:</p>
					<exhibit role="example">
						<pre>Type for "size"
• (string) →  integer

Definition of evaluation function for Fsize(V)
Fsize(V)= integer       If V is a string  
        = undefined 	otherwise

Type for "concat"
• (string x string) →  string

Definition of evaluation function for Fconcat(V1, V2)
Fconcat(V1, V2)= string      If V1 and V2 are both strings  
               = undefined   otherwise

Type for "toUpper", "toLower" 
• (string) →  string

Definition of evaluation function for FtoUpper(V). The same applied for "toLower" operator.
FtoUpper(V)= string all in upper characters     If V is a string  
           = undefined      otherwise

Type for "substring"
• (string x integer x iinteger) →  string

Definition of evaluation function for Fsubstring(V1,V2,V3)
Fsubstring(V1,V2,V3)=  returns a substring of length V3, at a given starting point V2. 
                     •  V1 is a string and V2 and V3 are integers
               If    •  0 ≤ V2 &lt; size(v1)
                     •  0 ≤ V3 &lt; size(v1)
                     •  V2 + V3 ≤ size(V1)
                    = undefined     otherwise
	                
Type for "=" and "&lt;&gt;"
• (string x string) →  truth_value     

Definition of the evaluation function F= (V1, V2). The evaluation function is the same for
F&lt;&gt; (V1, V2) when the operands are both strings.

F=(V1,V2) = true         If V1 and V2  are both strings and V1 = V2 
          = false        Else if V1 and V2 are both strings and V1 &lt;&gt; V2
          = undefined    otherwise
							</pre>
					</exhibit>
				</div3>
				<div3 id="StringOps2">
					<head>String Operators "tochar", "lpad", "rpad", "rtrim", "ltrim" and "replace"</head>
					<p>The types and evaluation functions for string operators are given as follows:</p>
					<exhibit role="example">
						<pre>Type for "tochar"
• (integer) →  string
• (real) →  string

Definition of evaluation function for Ftochar(V)
Fsize(V)= string       If V is an integer or a real number 
        = undefined    otherwise

Type for "lpad", "rpad" 
• (string x integer x string) →  string

Definition of evaluation function for Flpad(V). The same applies for "rpad" operator.
Flpad(V1, V2, V3)= string     If V1 is a string that could be padded on its left, 
                              V2 is an integer denoting the length to pad the text to, 
                              and V3 is a string to path with  
                 = undefined  otherwise

Type for "ltrim", "rtrim"
• (string x string) →  string

Definition of evaluation function for Fltrim(V1,V2). The same applies for "rtrim" operator.
Fltrim(V1,V2)= string     If V1 and V2 are strings. The resulting string 
                          has all the ocurrences of V2 that appear on 
                          the left removed
             = undefined  otherwise
	                
Type for "replace"
• (string x string x string) →  string    

Definition of the evaluation function Freplace (V1, V2,V3). 

F=(V1,V2,V3) = string       If V1, V2 and V3  are strings. The function returns a new 
                            string resulting from replacing in V1 all the ocurrences 
                            of V2 with V3
             = undefined    otherwise
							</pre>
					</exhibit>
				</div3>
			</div2>
			<div2 id="CollOps">
				<head>Collection Operators</head>
				<p>GELLO incorporates from OCL standard operations to handle elements in collections. These operations take the 
				elements in a collection and evaluate a GELLO expression on each of them. These operators are described in the following 
				sections: select (§‎5.10.3), reject (§‎5.10.4), collect (§‎5.10.5), forAll (§‎5.10.6), iterate (§‎5.10.7), exists (§‎5.10.8) and flatten (§‎5.10.9).</p>
				<div3 id="ArrowNotation">
					<head>The ‘Arrow’ Notation</head>
					<p>All operations on collections in GELLO are denoted with the ‘arrow’ →  notation. The ‘arrow’ notation distinguishes a 
					collection operation from a model type operation. Hence the notation is as follows:</p>
					<exhibit role="example">
						<pre>
   collection → collectionOperator(parameters)
						</pre>
					</exhibit>
				</div3>
				<div3 id="SingleInstances">
					<head>Single Instances as Collections</head>
					<p>GELLO treats a single instance as a collection with only one element. This allows us to apply collection operators to instances. 
					The type definition for collection operators will treat a single instance as a collection with one element, as specified in this section. 
					The notation is the same as in (§‎5.10.1):</p>
					<exhibit role="example">
						<pre>
   singleInstance → collectionOperator(parameters)
						</pre>
					</exhibit>
				</div3>
				<div3 id="OpSelect">
					<head>Operator Select</head>
					<p>Select is an operator to specify a selection from a specific collection. Select returns all the elements in a collection that satisfy a criterion. 
					There are three different forms, of which the simplest one is: </p>
					<exhibit role="example">
						<pre>
   collection → select( boolean-expression ) 
						</pre>
					</exhibit>
					<p>The result of the select operation, in the context of a complete repository of patient records, is a 
					collection of problem list instances with problem code = "123":</p>
					<exhibit role="example">
						<pre>
   patient.problemList → select(code = "123")			

This results in a collection that contains all the elements from collection for which the 
boolean-expression evaluates to true. For each element in collection the expression 
boolean-expression evaluates over a property of the elements in the collection. 
						</pre>
					</exhibit>
					<p>A more general syntax for the select expression:</p>
					<exhibit role="example">
						<pre>
   collection → select( v | boolean-expression-with-v )

The variable v, called the iterator, is a reference to an object in the collection. v iterates over 
the collection and the boolean-expression-with-v is evaluated for each v. The third form is an 
extension of the latest, where the type of the variable v can be specified. The notation is:

collection → select( v : Type | boolean-expression-with-v)
						</pre>
					</exhibit>
					<p>The notation for all variants is:</p>
					<exhibit role="example">
						<pre>
collection(select x BooleanExpression)
collection → select( v | boolean-expression-with-v)
collection →select( v : Type | boolean-expression-with-v)

Type for "select"
   (collection x Boolean Expression) → collection

Definition of evaluation function for Fselect(V,E)
Fselect(V,E)= collection     If V is a collection  and E is a valid GELLO Boolean expression. 
                             The resulting collection contains all the elements from V for which the 
                             Boolean expression E evaluates to true
            = undefined      otherwise

collection → select(v | BooleanExpression-with-v)

Type for "select"
   (collection x Iterator x Boolean Expression) → collection
   
Definition of evaluation function for Fselect(V,I,E)
Fselect(V,I,E)= collection     If V is a collection, I is the iterator referring to the object from 	
                               the collection and E is a valid GELLO Boolean expression. 	
                               The resulting collection contains all the elements from V for which the 
                               Boolean expression E evaluates to true
              = undefined      otherwise

collection → select(v:Type | BooleanExpression-with-v)

Type for "select"
(collection x  Iterator x Type x Boolean Expression)  → collection

Definition of evaluation function for Fselect(V,I,T,E)
Fselect(V,I,E)= collection      If V is a collection, I is the iterator with Type T referring to 	
                                the object from the collection and E is a valid GELLO Boolean 
                                expression. 
                                The resulting collection contains all the elements from V for which 
                                the Boolean expression E evaluates to true
              = undefined       otherwise
					 </pre>
					</exhibit>
				</div3>
				<div3 id="OpReject">
					<head>Operator Reject  </head>
					<p>The Boolean expression evaluates over a property of the elements in the collection, returning all the elements that do not satisfy such condition (all elements that evaluate to False).</p>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection→ reject(BooleanExpression)
   collection→ reject( v : Type | boolean-expression-with-v )
   collection→ reject( v | boolean-expression-with-v )

Type for "reject"
 (collection x Boolean Expression)→ collection

Definition of evaluation function for Freject(V,E)
Freject(V,E)= collection      If V is a collection  and E is a valid GELLO Boolean 
                              expression. The resulting collection contains all the elements
                              from V for which the Boolean expression E evaluates to false
            = undefined	      otherwise

collection→ reject(v | BooleanExpression-with-v)

Type for "reject"
 (collection x Iterator x Boolean Expression)→ collection

Definition of evaluation function for Freject(V,I,E)
Freject(V,I,E)= collection      If V is a collection, I is the iterator referring to the object 
                                from the collection and E is a valid GELLO Boolean expression. 	
                                The resulting collection contains all the elements
                                from V for which the Boolean expression E evaluates to false
              = undefined       otherwise

collection → reject(v:Type | BooleanExpression-with-v)

Type for "reject"
  (collection x Iterator x Type(Boolean Expression) → collection

Definition of evaluation function for Freject(V,I,T,E)
Freject(V,I,E)= collection      If V is a collection, I is the iterator with Type T referring to
                                the object from the collection and E is a valid 
                                GELLO Boolean expression. The resulting collection contains all 
                                the elements from V for which the Boolean expression E evaluates 
                                to false                
              = undefined 	otherwise
						</pre>
					</exhibit>
					<p>The result of reject in the following example is a collection of patients who do not have problem code = "123" in their problem list:</p>
					<exhibit role="example">
						<pre>
   patient.problemList→ reject(code = "123")
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpCollect">
					<head>Operator Collect </head>
					<p>Collect iterates over a collection, computes a value for each element of the collection, and gathers the evaluated values into a new collection. The type of the elements of the resulting collection is usually different from the type of the elements in the original collection over which the operator is applied. The collect operation uses the same syntax as the select and reject operators.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection→ collect(Expression)
   collection→ collect( v | expression-with-v )
   collection→ collect( v : Type | expression-with-v )

Type for "collect"
   (set x Expression)→ bag
   (bag x Expression) → bag
   (sequence x Expression)→ sequence

Definition of evaluation function for Fcollect(V,E)
Fcollect(V,E)= collection     If V is a collection  and E is an expression that is 
                              evaluated for each element in to collection.
             = undefined      otherwise

Type for "collect"
   (set x Iterator x Expression) → bag
   (bag x Iterator x Expression) → bag
   (sequence x Iterator x Expression)→ sequence

Definition of evaluation function for Fcollect(V,I,E)
Fcollect(V,I,E)= collection     If V is a collection, I is the iterator referring to the 
                                object from the collection and E is a valid GELLO expression. 
                                The resulting collection contains the results of evaluating E 
                                for each element of V.
               = undefined      otherwise
     
   collection→ collect(v:Type | Expression-with-v)
 
 Type for "collect"
   (set x Iterator x Type x Expression)→ bag
   (bag x Iterator x Type x Expression)→ bag
   (sequence x Iterator x Type x Expression)→ sequence
 
 Definition of evaluation function for Fcollect(V,I,T,E)
 Fcollect(V,I,E)= collection   If V is a collection, I is the iterator with Type T referring 
                               to the object from the collection and E is a valid GELLO 
                               Expression. The resulting collection contains the result of 
                               evaluating E for each element of V.
                = undefined    otherwise
				 </pre>
					</exhibit>
					<p>The following example returns a collection lab result values for creatinine:</p>
					<exhibit role="example">
						<pre>	
   LabResult→ select(code = "CRE")→ collect(value)
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpForAll">
					<head>Operator ForAll  </head>
					<p>ForAll is used to specify a Boolean expression that evaluates the value of a property over all the elements of a collection. The result of the Boolean expression is true if all the elements of the collection evaluate to true. If the Boolean expression is false for one or more elements of the collection, then the complete expression evaluates to false. </p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection→ forAll(Boolean Expression) 
   collection→ forAll( v | boolean-expression-with-v )
   collection→ forAll( v : Type | boolean-expression-with-v )

Type for "forAll"
    (collection x Boolean Expression)→ truth_value

Definition of evaluation function for FforAll(V,E)
FforAll(V,E) = true       If V is a collection  and E is a valid GELLO Boolean expression 
                          containing a property of the elements, and this expression evaluates 
                          to true for all elements in the collection
             = false      If V is a collection and E is a valid GELLO Boolean expression containing
                          a property of the elements, and there is at least one element for which 
                          the expression E evaluates to false. 
             = undefined  otherwise

   collection→ forAll(v | BooleanExpression-with-v) 
 
Type for "forAll"
   (collection x Iterator x Boolean Expression)→ truth_value

Definition of evaluation function for FforAll(V,I,E)
FforAll(V,I,E)= true       If V is a collection, I is the iterator referring to the object from the 
                           collection and E is a valid GELLO Boolean expression containing a 
                           property of the elements, and this expression evaluates to true for all
                           elements in the collection.
              = false      If V is a collection I is the iterator referring to the object from the 
                           collection and E is a valid GELLO Boolean expression containing a property 
                           of the elements, and there is at least one element for which the expression 
                           E evaluates to false. 
              = undefined  otherwise

collection → forAll(v:Type | BooleanExpression-with-v)

Type for "forAll"
   (collection x Iterator x Type(Boolean Expression) → truth_value

Definition of evaluation function for FforAll(V,I,T,E)
FforAll(V,I,E)= true         If V is a collection, I is the iterator with type T referring to the object 
                             from the collection and E is  a valid GELLO Boolean expression containing 
                             a property of the elements, and this expression evaluates to true for all 
                             elements in the collection.
              = false        If V is a collection I is the iterator referring to the object from the 
                             collection and E is a valid GELLO Boolean expression containing a 
                             property of the elements, and there is at least one element for which 
                             the expression E evaluates to false.
              = undefined    otherwise 
						</pre>
					</exhibit>
					<p>The following example returns true if all the lab results are for creatinine:</p>
					<exhibit role="example">
						<pre>	
   LabResult → forAll(code = "CRE")
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpIterate">
					<head>Operator Iterate</head>
					<p>Iterate is a generic operator. It iterates over a collection of elements elem evaluating each element against a valid GELLO expression expression-with-elem-and-result. The result of the expression-with-elem-and-result is stored in result. The initial value of result is defined by expression. Once iterate goes through the whole collection, it returns result.  </p>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection  → iterate(elem: Type; result: Type = expression | 
                         expression-with-elem-and-result)

Type for "iterate"
   (collection x elementName x elementType x resultName x resultType x expression x  
                         expression-with-elem-and-result)  → resultType

Definition of evaluation function for Fiterate(V,S,T1,R,T2,E1,E2)
Fiterate(V,S,T1,R,T2,E1,E2)= DataType      If V is a collection, S is an iterator variable of type T1, 
                                           R is a variable of type T2, E1 is a valid GELLO expression 
                                           defining the initial value of R and E2 is a valid GELLO 
                                           expression that is evaluated for each element S in the 
                                           collection. The evaluated value of E2 is stored in R. 
                                           The final result once the iteration is over is the value of R.
                           = undefined     otherwise
						</pre>
					</exhibit>
					<p>The following example returns the number of times creatinine occurs in the collection LabResult:</p>
					<exhibit role="example">
						<pre>	
   LabResult  → iterate(code, acc: Integer = 0 | if code = "CRE" then acc + 1 else acc endif)
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpExists">
					<head>Operator Exists</head>
					<p>Exists returns true if there is at least one element in the collection that satisfies the Boolean expression.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection → exists(BooleanExpression)
   collection → exists( v | boolean-expression-with-v )
   collection → exists( v : Type | boolean-expression-with-v)
 
 Type for "exists" 
    (collection x BooleanExpression) → truth_value 
 
Definition of evaluation function for Fexists(V,E)
Fexists(V,E)= true        If V is a collection E is a valid GELLO Boolean expression containing 
                          a property of the elements, and there is al least  one element
                          in the collection V that satisfies E.
            = false       If V is a collection E is a valid GELLO Boolean expression containing a 
                          property of the elements, and none of the elements in the collection V 
                          satisfies E.
            = undefined   otherwise

Type for "exists"
 (collection x Iterator x Boolean Expression) →  truth_value

Definition of evaluation function for Fexists(V,I,E)
Fexists(V,I,E) = true          If V is a collection, I is the iterator referring to the object 
                               from the collection and E is a valid GELLO Boolean expression 
                               containing a property of the elements and there is at least one 
                               element in the collection V for which E evaluates to true.
               = false         If V is a collection I is the iterator referring to the object from 
                               the collection and E is a valid GELLO and  there is no element in 
                               the collection V such that E evaluates to true for that element 
               = undefined     otherwise 
 
 collection → existsl(v:Type | BooleanExpression-with-v) 
 
 Type for "exists" 
     (collectionIterator x Type x Boolean Expression) → truth_value 
 
 Definition of evaluation function for Fexists(V,I,T,E) 
 Fexists(V,I,E)= true          If V is a collection, I is the iterator with type T referring 
                              to the object from the collection and E is a valid GELLO Boolean 
                              expression containing a property of the elements and there is 
                              at least one element in the collection V for which E evaluates to true.
               = false          If V is a collection I is the iterator referring to the object 
                               from the collection and E is a valid GELLO Boolean expression 
                               containing a property of the elements, and there is no element 
                               in the collection V such that E evaluates to true for that element
               = undefined     otherwise
						</pre>
					</exhibit>
					<p>The following example returns true if there is at least one lab result for creatinine:</p>
					<exhibit role="example">
						<pre>	
   LabResult → exists(code = "CRE")
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpFlatten">
					<head>Operator Flatten</head>
					<p>Flatten returns a collection without any nested elements. If the resulting type is a collection, the operator is applied recursively until the return type is a collection without nested collections.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection → flatten()

Type for "flatten" 
   (collection)  → collection 

Definition of evaluation function for Fflatten(V) 
Fflatten(V) = collection     If V is a collection, the result is a collection containing all the 
                             elements of V.  If V is a set, bag, or sequence, then Fflatten(V) is 
                             a set, bag, or sequence respectively.
            = element        If V is not a collection.
						</pre>
					</exhibit>
					<p>	The result of using flatten in the following example is the collection {1, 2, 3, 4, 5}:</p>
					<exhibit role="example">
						<pre>
						
   {1, 2, {3}, {{4},{5}} → flatten()
						</pre>
					</exhibit>
				</div3>
				<div3 id="OpSize">
					<head>Operator Size</head>
					<p>The operator size returns the number of elements in a collection. </p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection → size()

Types for "size"
   (collection) → integer

Definition of evaluation function for Fsize(V)
Fsize(V) = integer          If V is a collection 
         = undefined        otherwise
						</pre>
					</exhibit>
					<p>The following example returns the number problems the patient has in his problem list:</p>
					<exhibit role="example">
						<pre>
						
   patient.problemList → size()
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpCount">
					<head>Operator Count</head>
					<p>Count returns the number of occurrences of object in a collection.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection → count(object)

Type for "count"
   (collection x object)  → integer

Definition of evaluation function for Fcount(V,O)
Fcount(V,O) = integer           If V is a collection  and O is a defined object
            = undefined 	otherwise
						</pre>
					</exhibit>
					<p>The following example returns the number of times the patient has had fever :</p>
					<exhibit role="example">
						<pre>	
   patient.problemList  → collect(code) → count("fever")
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpMinMax">
					<head>Operators "Max" and "Min"</head>
					<p>Max and min return the biggest and smallest value respectively in a collection. The collection must contain numbers. The following also applies for the min operator. </p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection → max()

Type for "max"
   (collection)  → number

Definition of evaluation function for Fmax(V)
Fmax(V) = number        If V is a collection of numbers (integers or reals)
        = undefined 	otherwise
						</pre>
					</exhibit>
					<exhibit role="example">
						<pre>	
   {2,5,1} → max()        returns 5
   {2,5,1} →  min()       returns 1
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpIncludes">
					<head>Operator Includes</head>
					<p>Includes operator returns a true if the object is an element of the collection.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection → includes(object)

Type for "includes"
   (collection x object) → truth_value 
 
Definition of evaluation function for Fincludes(V,O) 
Fincludes(V,O) = true         If V is a collection  and O is an element in the collection.  
               = false        Else if V is a collection and O is not an element V.  
               = undefined    otherwise 
						 </pre>
					</exhibit>
					<p>The following example returns true if the patient has "fever" in problem list:</p>
					<exhibit role="example">
						<pre>	
   patient.problemList →  collect(code) → includes("fever")
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpIncludesAll">
					<head>Operator IncludesAll</head>
					<p>IncludesAll returns true if all the elements in the parameter collection are in the current collection.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection → includesAll(parameterCollection)

Types for "includesAll"
   (collection x singleInstance) → truth_value
   (collection x collection ) → truth_value
 
Definition of evaluation function for FincludesAll(V,C)
FincludesAll(V,C)= true         If both V and C are collections and all the elements in C 
                                 appear in V. 
                 = false         Else if V is a collection and there is at least one element in C 
                                 that does not appear in V.
                 = undefined     otherwise
						</pre>
					</exhibit>
					<p>The following example returns true if the patient has "fever"and "rash" in problem list:</p>
					<exhibit role="example">
						<pre>	
   patient.problemList → collect(code) → includesAll( SET{"fever", "rash"})
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpIsEmpty">
					<head>Operator IsEmpty</head>
					<p>isEmpty returns true if the collection contains no elements.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection → isEmpty()

Type for "isEmpty"
   (collection) → truth_value 

Definition of evaluation function for FisEmpty(V) 
 FisEmpty(V) = true          If V is a collection  with no elements
             = false         Else if V is a collection with one or more elements 
             = undefined     otherwise 
						</pre>
					</exhibit>
					<p>The following example returns true if the patient has no problems in problem list:</p>
					<exhibit role="example">
						<pre>	
   patient.problemList → isEmpty()
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpNotEmpty">
					<head>Operator notEmpty</head>
					<p>notEmpty returns true if the collection contains one or more elements.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection → notEmpty()

Type for "notEmpty" 
   (collection) → truth_value 
 
Definition of evaluation function for FnotEmpty(V) 
FnotEmpty(V) = true          If V is a collection  with one or more elements 
             = false	     Else if V is a collection with no elements 
             = undefined     otherwise 
						</pre>
					</exhibit>
					<p>The following example returns true if the patient has at least one problem in problem list:</p>
					<exhibit role="example">
						<pre>
						
   patient.problemList → notEmpty()
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpSum">
					<head>Operator Sum</head>
					<p>Sum adds up all the elements in a collection. The elements must be of type integer or real.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection  → sum()
 
Types for "sum"
   (collection_of_integers)  → integer 
   (collection_of_reals)  → real 
 
Definition of evaluation function for Fsum(V) 
Fsum(V) = V1+…+Vn           If V is a non-empty collection of n integer or 
                            real values &lt; V1 , … , Vn &gt; with (1&lte; i &lte; n) 
        = 0	            Else if V is an empty collection  
        = undefined 	    otherwise 
						</pre>
					</exhibit>
					<p>The following example returns 15, the sum of all the values in the collection:</p>
					<exhibit role="example">
						<pre>
						
   {1, 2, 3, 4, 5}  → sum()
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpFirstN">
					<head>Operator FirstN</head>
					<p>firstN returns a sequence with the first n elements from the current sequence (a collection with ordered elements). firstN returns the first n elements. </p>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   sequence → firstN(numberOfElements)

Type for "firstN"
   (sequence x integer)  → sequence

Definition of evaluation function for FfirstN(V,N)
FfirstN(V,N)= sequence        If V is an non-empty sequence and N is an integer 
                              such that 1&lte; N &lte; size of V. The resulting sequence
                              is of the same type as V
            = undefined       otherwise
						</pre>
					</exhibit>
					<p>The following example returns the first 3 elements in a sequence:</p>
					<exhibit role="example">
						<pre>	
   {1,2,3,4,5}  → firstN(3)      returns {1,2,3}
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpLastN">
					<head>Operator LastN</head>
					<p>Returns the last  n elements from the current sequence. The elements are returned as a sequence of n elements.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
    sequence  → lastN(numberOfElements)

Type for "lastN"
    (sequence x integer)  → sequence

Definition of evaluation function for FlastN(V,N)
FlastN(V,N)= sequence      If V is an non-empty sequence and N is an integer 
                           such that 1 &lte; N &lte; size of V.  The resulting sequence 
                           is of the same type as V 
           = undefined     otherwise 
						</pre>
					</exhibit>
					<p>The following example returns the last 3 elements in a collection:</p>
					<exhibit role="example">
						<pre>	
   {1,2,3,4,5}  → lastN(3)      returns {3,4,5}
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpElemAt">
					<head>Operator ElemAt</head>
					<p>Returns the element at the Nth position from the current sequence. </p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
    sequence → elemAt(ElementPosition)


Type for "elemAt"
   (sequence x integer) → element

Definition of evaluation function for FelemAt(V,N)
FelemAt(V,N) = element     If V is an non-empty sequence and N is an integer 
                           such that 1 &lte; N &lte; size of V. The result is the  
                           element at the Nth position.
             = undefined   otherwise
						</pre>
					</exhibit>
					<p>The following example returns the element in the third position in the sequence. The positions go from 1 to size of sequence -1:</p>
					<exhibit role="example">
						<pre>	
   {a, f, g, k, z} → elemAt(3)      returns g
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpReverse">
					<head>Operator Reverse</head>
					<p>Reverse returns a sequence in reversed order. E.g. the first element of the current sequence is returned as the last and so on. </p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   sequence → reverse()

Type for "reverse" 
   (sequence) → sequence 

Definition of evaluation function for Freverse(V) 
Freverse(V) = sequence       If V is a single instance or a sequence. 
                             The resulting sequence is of the same 
                             type as V. 
            = undefined      otherwise 
						 </pre>
					</exhibit>
					<p>The following example returns a sequence in a reversed order: </p>
					<exhibit role="example">
						<pre>	
   {a, f, g, k, z} → reverse()      returns {z, k, g, f, a}
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpSortBy">
					<head>Operator SortBy</head>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection  → sortBy(orderByExpression)

Types for "sortBy"
    (collection x ListOfProperties)  →sequence

Definition of evaluation function for FsortBy(V,E)
FsortBy(V,E) = sequence          If V is a single instance or a collection  
                                 and E is a GELLO expression specifying the 
                                 properties by which the current collection 
                                 should be ordered by. The result is a 
                                 sequence. 
             = undefined 	 otherwise 
						</pre>
					</exhibit>
					<p>The following example returns a collection of medications sorted in ascending order by effective time:</p>
					<exhibit role="example">
						<pre>	
   Patient.Medication  → sortBy(effectiveTime.high())
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpIntersec">
					<head>Operator Intersection</head>
					<p>The intersection operator returns a collection with the elements that appear in both the current collection and the parameter collection. This operation is valid for any combination set and bag, but is not defined for sequences. The return type is a set. Set does not allow duplicates.</p>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection → intersection(parameterCollection)

Types for "intersection" 
   (set x set) → set 
   (bag x bag) → set 
   (set x bag) → set 
   (bag x set) → set 

Definition of evaluation function for Fintersection(V1,V2) 
Fintersection(V1,V2) = set         If V1 and V2 are either sets or bags with 
                                   elements &lt; V1,1, … , V1,n &gt;  and 
                                   &lt; V2,1, … ,V2,n &gt;  respectively. The 
                                   resulting set contains all the elements from 
                                   V1 that also are elements of V2  (V1,i = V2,j). 
                                   If there are not common elements in V1 and V2
                                   the intersection returns an empty set. 
                     = undefined   otherwise 
						</pre>
					</exhibit>
					<exhibit role="example">
						<pre>
   
   TDrug: a variable holding a collection of drugs, each of which has a 
   "compellingIndication" property.  aPatient is a variable referencing a 
   particular patient’s medical record:

   Drug → exists(aDrug: not(aDrug.compellingIndication → 
                            intersection(aPerson.problemList) → isEmpty))
						</pre>
					</exhibit>
				</div3>
				<div3 id="OpUnion">
					<head>Operator Union</head>
					<p>The union operation combines two collections into a new one. The union operation can combine a set and a bag, but a sequence only can be combined with another sequence.</p>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection union(parameterCollection)

Types for "union"
   (set x bag) → bag 
   (bag x set)  → bag 
   (set x set) → bag 
   (bag x bag) → bag 
   (sequence x sequence) → sequence 

 Definition of evaluation function for Funion(V1,V2) 
 Funion(V1,V2) = set             If V1 and V2 are both sets. The resulting set contains 
                                 the values   that are either in V1 or in V2. Duplicate 
                                 elements are not added. 
               = bag             If V1 and V2 are either sets or bags. The resulting bag 
                                 contains the values &lt;  V1,1, … , V1,n &gt; from V1 
                                 and &lt; V2,1, … , V2,n &gt;  from V2. 
               = sequence        Else if  V1 and V2 are both sequences. The resulting 
                                 sequence contains the values &lt;  V1,1, … , V1,n , 
                                 V2,1, … , V2,n &gt; such that &lt;  V1,1, … , V1,n &gt; are
                                 from V1 and &lt; V2,1, … , V2,n &gt;  are from V2
               = undefined	 otherwise 
						</pre>
					</exhibit>
					<p>The following example returns a collection times when a patient has taken any medication and has had problems:</p>
					<exhibit role="example">
						<pre>
						
   Patient.problemList → exist(problemList : medication.AllInstances → 
                              exist( medication.effectiveTime → union(effectiveTime))
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpIncluding">
					<head>Operator Including</head>
					<p>The operator including returns a collection containing all the elements of the current collection plus an element (which is added at the end if the collection is a sequence). </p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection →  including(element)

Types for "including" 
   (set x element) → set 
   (bag x element) → bag 
   (sequence x element) → set
   (sequence → element) → bag 
 
Definition of evaluation function for Fincluding(V,E)
Fincluding(V,E)= set              If V is a set and E is an element that does not exist in V. 
                                  E must be of the same type as the elements in V. The 
                                  returning result is a set V→union(Set{E}).
Fincluding(V,E)= bag              If V is a bag, the returning type of the collection is a 
                                  bag with E added to V.
Fincluding(V,E)= sequence         If V is a sequence and E is an element that does 
                                  not exist in V.  The resulting sequence has E added to the 
                                  end of V.  E must be of the same type as the elements in V.
Fincluding(V,E)= bag              If V is a sequence and E is an element that does 
                                  exist in V.  E must be of  the same type as the elements in V.
               = undefined        otherwise
						</pre>
					</exhibit>
					<p>The following example returns a set with the appended element:</p>
					<exhibit role="example">
						<pre>	
   Set{7, 2, 8, 4}→ including(5)     returns  Set{7, 2, 8, 4, 5}
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpExcluding">
					<head>Operator Excluding</head>
					<p>The operator excluding returns a collection containing all the elements of the current collection minus all the occurrences of element. </p>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection → excluding(element)

Types for "excluding" 
   (set x element) → set   
   (bag x (element) → bag 
   (sequence x element) → sequence 
 
Definition of evaluation function for Fexcluding(V,E) 
>Fexcluding(V,E)= collection       If V is either a set, bag or sequence and E 
                                   is an element  in V.   
                = undefined        otherwise 
						</pre>
					</exhibit>
					<p>The following example returns a bag with the deleted element:</p>
					<exhibit role="example">
						<pre>	
   Bag{7, 2, 5, 8, 4, 5} → excluding(5)     returns Bag{7, 2, 8, 4}
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpJoin">
					<head>Operator Join</head>
					<p>The join operator brings together data from two or more collections. The result is a collection of tuples. Each tuple contains data from each element in the specified collections where the values of the specified conditions match.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   currentCollection  → join(namesOfCollections; namesOfProperties; booleanExpression; 
         orderByExpression)

Where:
• namesOfCollections is a list of strings separated by commas, where each  
  string represents the name of a collection from where data is retrieved. 
• The name of the current collection currentCollection must appear in the list. 

Notation for namesOfCollections:
• Collection1, collection2,…collectionn;                
   E.g.   patient, labTest, …, treatment
• Alias1 in collection1, alias2 in collection2, …, aliasn in collectionn;               
   E.g.   p in patient, lt in labTest, …, t in treatment
 
• namesOfProperties is a list of strings separated by commas, where each 
  string is the full description of the properties from the objects in the
  collections we want to get in the result.  

The notation is: object.property.  E.g. [patient.ID, labTest.ID, labTest.result, 
labTest.date, treatment.ID, treatment.description].  
Or using aliases: p.ID, lt.ID, etc. 

 • booleanExpression is a valid GELLO Boolean expression containing the 
   conditions the elements from the collections defined in listOfCollections 
   must satisfy in order to be included in the result. For each pair of 
   collections there must be at least one condition related to these 
   collections in the booleanExpression. In general, the number of conditions 
   must be at least equal to the number of collections in listOfCollections-1.

• orderByExpression is a valid GELLO expression specifying the properties 
  by which the result should be ordered.   E.g. patient.ID, treatmentID or
  using aliases  p.ID, t.ID, will sort the result by patientID and 
  treatment ID. 

Types for "join"
   (collection x  parameterList x parameterList x booleanExpression x 
         OrderExpression) → bag_of_tuples  
                     *: for any type of collection if OrderExpression is 
                         not specified. 
                         
   (collection x parameterList x parameterList x booleanExpression x 
         OrderExpression) → sequence_of_tuples 
                    +: for any type of collection if OrderExpression is 
                        specified. 

 Definition of evaluation function for Fjoin(V,S1,S2,E1,E2) 
 Fjoin(V,S1,S2,E1,E2) = bag of tuples  	       If V is collection, S1 is a parameter list of 
                                               strings with the names of the collections from 
                                               where  data will be retrieved, S2 is a parameter
                                               list of strings with the full names of the properties 
                                               to be included in the result, E1 is a boolean
                                               expression containing the conditions C &lt;C1 booleanOP 
                                               C2 … booleanOP Cn &gt;    the returning elements must 
                                               satisfy. The number of conditions Ci in
                                                E1 ≥ [S1(size()-1].  E2 is an optional 
                                               parameter that specifies the criteria for ordering the
                                               resulting elements. If  E2 is not specified, the 
                                               result is a bag.
 Fjoin(V,S1,S2,E1,E2) = sequence of tuples     If V is collection, S1 is a parameter list of 
                                               strings with the names of the collections from 
                                               where data will be retrieved, S2 is a parameter
                                               list of strings with the full names of the properties 
                                               to be included in the result, E1 is a boolean expression 
                                               containing the conditions Ci &lt; C1 booleanOP 
                                               C2 … booleanOP Cn  &gt; the returning elements 
                                               must satisfy. The number of conditions Ci in 
                                               E1 ≥ [S1(size()-1].  E2 is an optional parameter 
                                               that specifies the criteria for ordering the
                                               resulting elements. If ordering is required, then 
                                               a GELLO expression specifying the  properties 
                                               by which the result should be ordered by
                                               must be defined.  The resulting collection is
                                               a sequence.
                      = undefined              otherwise
						 </pre>
					</exhibit>
					<p>The following example returns a collection of tuples containing Medication code, effective time and value, and Lab Results code, effective time and value, for all the Lab Results performed (effective time) while a patient was taking any Medication effective time):</p>
					<exhibit role="example">
						<pre>	
   LabResults→ join(Medications; Medications.code, Medications.effectiveTime,
                     Medications.value, LabResults.code,  LabResults.effectiveTime, 
                     LabResults.value; Medications.effectiveTime.contains(LabResults.effectiveTime)
						</pre>
					</exhibit>
				</div3>
				<div3 id="OpAverage">
					<head>Operator Average</head>
					<p>Average returns the average (arithmetic mean) of the numerical elements in a collection.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection → average()

Type for "average"
   (collection)  → real

Definition of evaluation function for Faverage(V)
Faverage(V) = real       If V is a collection  and all the elements in the collection 
                         are either real or integer numbers
            = undefined  otherwise
						</pre>
					</exhibit>
					<p>The following example returns the average value of the elements in a collection:</p>
					<exhibit role="example">
						<pre>	
    recorded_temperatures is a collection containing the recorded temperatures 
    of a patient: {97, 98, 98.5, 99, 99, 97, 97}. 

                     So, recorded_temperatures → average()          returns: 97.92 F
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpStdev">
					<head>Operator Stdev</head>
					<p>Stdev returns the standard deviation of the numerical elements in a collection.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection → stdev()

Type for "stdev"
   (collection)  → real

Definition of evaluation function for Fstdev(V)
Fstdev(V) = real        If V is a collection  and all the elements in the collection are 
                        either real or integer numbers
          = undefined 	otherwise
						</pre>
					</exhibit>
					<p>The following example returns the standard deviation of the elements in a collection:</p>
					<exhibit role="example">
						<pre>	
    recorded_temperatures is a collection containing the recorded temperatures 
    of a patient: {97, 98, 98.5, 99, 99, 97, 97}. 

                     So, recorded_temperatures → stdev()          returns: 0.9322
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpVariance">
					<head>Operator Variance</head>
					<p>Variance returns the variance of the numerical elements in a collection.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection → variance()

Type for "variance"
   (collection)  → real

Definition of evaluation function for Fvariance(V)
Fvariance(V) = real         If V is a collection  and all the elements in the collection are 
                            either real or integer numbers
             = undefined    otherwise
						</pre>
					</exhibit>
					<p>The following example returns the variance of the elements in a collection:</p>
					<exhibit role="example">
						<pre>	
    recorded_temperatures is a collection containing the recorded temperatures
    of a patient: {97, 98, 98.5, 99, 99, 97, 97}. 
    
                     So, recorded_temperatures → variance()          returns: 0.8690
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpMedian">
					<head>Operator Median</head>
					<p>Median returns the median of the numerical elements in a collection. The median is the number in the middle of a set of numbers; that is, half the numbers have values that are greater than the median, and half have values that are less. If the number of elements is even, then the median is the average value of the two numbers in the middle.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection → median()

Type for "median"
   (collection)  → real

Definition of evaluation function for Fmedian(V)
Fmedian(V) = integer      If V is a collection and all the elements in the collection are 
                          integer numbers
            = real        Else if V is a collection and all the elements in the collection are 
                          either real or integer numbers
            = undefined   otherwise
						</pre>
					</exhibit>
					<p>The following example returns the median of the elements in a collection:</p>
					<exhibit role="example">
						<pre>	
    recorded_temperatures is a collection containing the recorded temperatures
    of a patient: {97, 98, 98.5, 99, 99, 97, 97}. 
    
                     So,   recorded_temperatures → median()          returns: 98
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpMode">
					<head>Operator Mode</head>
					<p>Mode returns the most frequently occurring value in a collection.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection → mode()

Type for "mode"
   (collection)  → real

Definition of evaluation function for Fmode(V)
Fmode(V) = integer      If V is a collection and all the elements in the collection are 
                        integer numbers
         = real         Else if V is a collection and all the elements in the collection are 
                        either real or integer numbers
         = undefined 	otherwise
						</pre>
					</exhibit>
					<p>The following example returns the median of the elements in a collection:</p>
					<exhibit role="example">
						<pre>	
    recorded_temperatures is a collection containing the recorded temperatures
    of a patient: {97, 98, 98.5, 99, 99, 97, 97}. 
    
                     So,   recorded_temperatures → mode()          returns: 97
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpLike">
					<head>Operator Like</head>
					<p>Like operator searches a collection of strings and returns those  that match a given pattern.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection → like(String)

Type for "like"
   (collection x string) → collection 
 
Definition of evaluation function for Flike(V1,V2) 
Flike(V1,V2) = collection     If V1 is a collection  of strings and V2   
                              is string pattern.The result is a collection of all 
                              strings that matched the given pattern. If there 
                              are no matches, the returning collection is empty.
              = undefined     otherwise 
						 </pre>
					</exhibit>
					<p>The following example returns a collection with problems that are like "ast" (asthma, astigmatism...):</p>
					<exhibit role="example">
						<pre>	
   patient.problemList →  collect(code) → like("ast")
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpNotLike">
					<head>Operator NotLike</head>
					<p>NotLike operator searches a collection of strings and returns those that do not match a given pattern.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection → notlike(String)

Type for "notlike"
   (collection x string) → collection 
 
Definition of evaluation function for Fnotlike(V1,V2) 
Fnotlike(V1,V2) = collection   If V1 is a collection  of strings and V2  
                               is string pattern. The result is a collection of all  
                               strings that did not match the given pattern.  
                               If there are no matches, the returning collection is empty.
                = undefined    otherwise 
						 </pre>
					</exhibit>
					<p>The following example returns a collection with problems that are not like "ast" (e.g. diabetes, COPD):</p>
					<exhibit role="example">
						<pre>	
   patient.problemList →  collect(code) → notlike("ast")
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpBetween">
					<head>Operator Between</head>
					<p>Between operator searches a collection of strings and returns those strings that are between a given range.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection → between(String1, String2)

Type for "between"
   (collection x string x string) → collection 
 
Definition of evaluation function for Fbetween(V1,V2,V3) 
Fbetween(V1,V2,V3) = collection   If V1 is a collection of strings 
                                  and V2 and V3 are both stringsdefining a 
                                  range.  The result is a collection of all  strings 
                                  that are between the given range. If there are 
                                  no matches, the returning collection is empty.
                   = undefined    otherwise 
						 </pre>
					</exhibit>
					<p>The following example returns a collection with problems that are between diabetes and reflux:</p>
					<exhibit role="example">
						<pre>	
   {asthma, copd, diabetes, IRS, meningitis, reflux, UTI} → between(diabetes, reflux) 
   returns: {diabetes, IRS, meningitis, reflux}
					   </pre>
					</exhibit>
				</div3>
				<div3 id="OpDistinct">
					<head>Operator Distinct</head>
					<p>Distinct operator returns a collection (set) with no duplicate elements. Basically is a casting operation, that converts a bag or sequence into a set, hence eliminating duplicates.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   collection → distinct()

Type for "distinct"
   (collection) → set 
 
Definition of evaluation function for Fdistinct(V1) 
Fdistinct(V1) = set         If V1 is a collection  the result is a set 
              = undefined   otherwise 
						 </pre>
					</exhibit>
					<p>The following example returns a set with problems::</p>
					<exhibit role="example">
						<pre>	
   {asthma, copd, diabetes, copd, UTI, IRS, reflux, UTI} → distinct() 
   returns: {asthma, copd, diabetes, UTI, IRS, reflux}
					   </pre>
					</exhibit>
				</div3>
			</div2>
			<div2 id="TupleOps">
				<head>Tuple Operators</head>
				<p>A GELLO tuple is an aggregated data type formed by one or more elements with different types. As described in §‎5.1.4, each tuple part has a name and a type. GELLO provides the following operations to handle and access tuple elements. Since all elements in a tuple have unique values, we use the ‘dot’ notation to access them in the same manner as we access attributes in a class (§‎5.3.1), e.g. tupleName.elemName.</p>
				<div3 id="TupleSize">
					<head>Operator Size</head>
					<p>The operator size returns the number of elements in a tuple. </p>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
						
   Tuple.size()

Types for "size" 
   (tuple) → integer 

Definition of evaluation function for Fsize(T) 
Fsize(T)= integer      If T is a tuple   
        = undefined    otherwise 
						</pre>
					</exhibit>
					<p>For the Tuple personalData{name: String = ‘John Smith’, nickname: String = ‘Johnny’, age: Integer = 10} the following example returns 3:</p>
					<exhibit role="example">
						<pre>
						
   personalData.size()   returns 3 
						</pre>
					</exhibit>
				</div3>
				<div3 id="TupleGetValue">
					<head>Operator getValue</head>
					<p>The operator getValue returns the value of an element with name = elemName in a tuple.</p>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
						
   Tuple.getValue(elemName)

Types for "getValue" 
   (tuple(string) → PredefinedDataTypeValue 
   (tuple(string) → ModelDataTypeObject 
 
Definition of evaluation function for FgetValue(T,S)
FgetValue(T,S) = PredefinedDataTypeValue     If T is a tuple  and S is a string with the name of  
                                             an element in T, and the type of the returning  
                                             value is one of the predefined data types: 
                                             integer, real, boolean, string or one of the 
                                             collection types. 
               = ModelDataTypeObject	     Else if T is a tuple  and S is a string with the name 
                                             of an element in T, and the type of the returning 
                                             value is one of the model data types. 
               = undefined                   otherwise
						</pre>
					</exhibit>
					<p>For the Tuple personalData{name: String = ‘John Smith’, nickname: String = ‘Johnny’, age: Integer = 10} the following example returns Johnny:</p>
					<p/>
					<exhibit role="example">
						<pre>
   personalData.getValue(nickname)     returns ‘Johnny’ 
   
   this is equivalent to:   personalData.nickname 
					   </pre>
					</exhibit>
				</div3>
				<div3 id="TupleGetElemName">
					<head>Operator getElemName</head>
					<p>The operator getElemName returns a string with the name of the element i in the ith position in the tuple.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   Tuple.getElemName(position) 
 
Type for "getElemName"
   (tuple x integer) → string 

Definition of evaluation function for FgetElemName(T,I) 
 FgetElemName(T,I) = string       If T is a tuple  and I is an integer (1 &lte; T.size()). 
                   = undefined    otherwise 
						 </pre>
					</exhibit>
					<p>For the Tuple personalData{name: String = ‘John Smith’, nickname: String = ‘Johnny’, age: Integer = 10} the following example returns 3:</p>
					<exhibit role="example">
						<pre>	
   personalData.getElemName(2)     returns ‘nickname’
						   </pre>
					</exhibit>
				</div3>
				<div3 id="TupleGetElemType">
					<head>Operator getElemType</head>
					<p>The operator getElemType returns a string which represents the basic or model data type associated to an element in a tuple.  GetElemType can be used by giving the position or the name of an element in the tuple.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
   Tuple.getElemType(position)
   Tuple.getElemType(elemName) 
 
Types for "getElemType" 
   (tuple x integer) → string 
   (tuple x string) → string 
 
Definition of evaluation function for FgetElemType(T,I) 
FgetElemType(T,I) = PredefinedDataType     If T is a tuple  and I is an integer (1 &lte; T.size()). 
                                           The returning value is a string referring to a
                                           predefined data type: integer, real, Boolean, 
                                           string or one of the collection types. 
                  = ModelDataType          Else if T is a tuple  and I is an integer (1 &lte; T.size()). 
                                           The returning value is a string referring to a model 
                                           data type. 
                  = undefined              otherwise 
 
 Definition of evaluation function for FgetElemType(T,S)
 FgetElemType(T,S)= PredefinedDataType     If T is a tuple  and S is a string referring to the 
                                           name of an element in the tuple. The returning value 
                                           is a string referring to a basic data type: integer, 
                                           real, Boolean, string, or one of the collection types. 
                  = ModelDataType          Else if T is a tuple and S is a string referring to the 
                                           name of an element in the tuple.  The returning value
                                           is a string referring to a model data type. 
                  = undefined              otherwise 
						 </pre>
					</exhibit>
					<p>For the Tuple personalData{name: String = ‘John Smith’, nickname: String = ‘Johnny’, age: Integer = 10} the following example returns 3:</p>
					<exhibit role="example">
						<pre>	
   personalData.getElemType(2)     returns String

   this is equivalent to:    personalData.getElemType(‘nickname’) 
						</pre>
					</exhibit>
				</div3>
			</div2>
			<div2>id="DateOps">
				<head>Date/Time Operators</head>
				<p>The following operators handle date and time objects.</p>
				<div3 id="ToDate">
					<head>Operator ToDate</head>
					<p>The operator ToDate takes a string and returns a PointInTime object.</p>
					<p/>
					<p>The notation is:</p>
					<exhibit role="example">
						<pre>
Type for "todate" 
• (string) →  PointInTime    (a RIM object)

Definition of evaluation function for Ftodate(V)
Ftodate(V)= PointInTime    If V is a valid string. The result is a PoinInTime object  
          = undefined      otherwise
						 </pre>
					</exhibit>
					<p>The notation for using this operator is as follows. It requires the Factory method because the returning object is an instance of a RIM Class</p>
					<exhibit role="example">
						<pre>
					
	The following expression creates a PointInTime object 
	with the argument string:
	
	              Let aDate: PointInTime = Factory.PointInTime(String)
					</pre>
					</exhibit>
				</div3>
				<div3 id="AddMonthsDateNextDay">
					<head>Operator AddMonths, AddDate and NextDay</head>
					<p>These operations are supported by the RIM PoinInTime Class using the operator plus.</p>
				</div3>
				<div3 id="LastDay">
					<head>Operator LastDay</head>
					<p>This operation is fully supported by the RIM (time) Interval Class using the operator high. </p>
				</div3>
			</div2>
			<div2 id="Precedence">
				<head>Precedence Rules</head>
				<p>The precedence order for operations in GELLO, starting with the highest precedence, is as follows:</p>
				<list role="unordered">
					<item>"dot" (".") and "arrow" ("→ ") operations</item>
					<item>unary "not" and unary "minus"</item>
					<item>"*", "/", "div" and "mod"</item>
					<item>"+" and binary "-"</item>
					<item>"if-then-else-endif"</item>
					<item>‘&lt;’, ‘&gt;’, ‘&lt;=’, ‘&gt;=’</item>
					<item>‘=’, ‘&lt;&gt;’</item>
					<item>‘and’, ‘or’ and ‘xor’</item>
					<item>‘implies’</item>
					<item>Parentheses "(" and ")" can be used to change precedence.</item>
				</list>
			</div2>
			<div2 id="IfExp">
				<head>If Expression</head>
				<p>An IfExpression evaluates a condition and depending on the resulting truth value, the result is one of two possible expressions. Both expressions are mandatory. The IfExpression is not intended for control flow, but as a conditional for the returning value of an expression. The syntax of an IfExpression is as follows:</p>
				<exhibit role="example">
					<pre>
   if condition then 
      expression1 
   else 
      expression2
   endif 
					</pre>
				</exhibit>
				<exhibit role="example">
					<pre>
Definition of the evaluation function Fif(V1, V2, V3), where V1 is the condition, 
a GELLO expression which its evaluation returns a truth value; and V2 and  V3 are 
expression1 and expression2 respectively, both valid GELLO expressions.

Fif(V1,V2,V3) =  V2            If V1 = true 
              =  V3            Else if V1 = false
              =  undefined     otherwise 
					 </pre>
				</exhibit>
				<exhibit role="example">
					<pre>
   let renal_failure :Boolean = 
      if lastCreatinine.oclIsDefined() and
               lastCreatine.value.greaterThan(renal_failure_threshold)  then 
         true
      else
         false
      Endif
			   </pre>
				</exhibit>
			</div2>
		</div1>
		<div1 id="GELLOSyntax">
			<head>GELLO Syntax</head>
			<p>This section describes the grammar used in this specification to define the lexical and syntactic structure of GELLO expressions.  A context-free grammar consists of a number of productions. Each production is formed by two parts: the left-hand side consisting of a nonterminal symbol and a right-hand side formed by a sequence of one or more nonterminal and terminal symbols. </p>
			<p>Starting from a sentence consisting of a single nonterminal, and a set of production rules, the complete grammar is derived by means of a set of possible sequences of terminal symbols that can result from repeatedly replacing any nonterminal symbol in a sequence with its associated right-hand side sequence of a production rule. </p>
			<p>Section §‎6.2 describes the grammar used in this specification to define the lexical and syntactic structure of GELLO expressions. For an expression to be syntactically correct it must conform to:</p>
			<p>The BNF and lexical grammar defined in this section of the document (§‎6.3). </p>
			<p>The context sensitive constraints: </p>
			<p>Every expression must be type-correct. It must comply with the type definitions in §‎5.1.</p>
			<div2 id="InfTypes">
				<head>Inferring Type Rules for Expressions</head>
				<p>Let E be a valid GELLO expression. The type of E is either a basic (Integer, Real, Boolean or String), a model type or one of the collection or tuple types.  The type of E can be inferred by using the rules defined in GELLO lexical grammar §‎6.2 and GELLO BNF §‎6.3.</p>
			</div2>
			<div2 id="LexGram">
				<head>GELLO Lexical Grammar</head>
				<p>GELLO BNF syntax is defined in terms of the following lexical tokens. GELLO grammar is based on the grammar for <loc href="http://www.omg.org/cgi-bin/doc?ptc/03-10-14.pdf">OCL expressions:</loc>
				</p>
				<p/>
				<p>A reserved word is any string that appears in double quotes in the BNF.</p>
				<p>An atom consists of any sequence of alphanumeric characters, which begins with a letter and can contain one or more underscores.</p>
				<p>A number could be either an integer or a real.</p>
				<p>An integer is represented by one or more digits</p>
				<p>A real is represented by  a sequence of one or more digits followed by "." followed by zero or more digits, optionally followed by  "e" or "E"  a sign "+" or  "-"  one or more digits and "d" or "D".</p>
				<p>A single quoted string is a pair of single quote characters enclosing a sequence of zero or more characters other than comments, tabs, newlines and carriage returns.</p>
				<p>A comment is any sequence of characters other than newlines, or carriage returns following two successive dashes -- , e.g.</p>
				<p>-- this is a comment.</p>
			</div2>
			<div2 id="BNF">
				<head>GELLO BNF Syntax</head>
				<p>The Backus-Naur Form (BNF) syntax of GELLO assumes that text defining a GELLO expression has been converted into lexical tokens by the lexical analyzer defined in the previous section.  </p>
				<p/>
				<p>The following notational conventions are used throughout GELLO BNF syntax:</p>
				<list role="unordered">
					<item>The root symbol of the syntax is &lt;GELLOExpression&gt;</item>
					<item>Non-terminal symbols are denoted with underlined text strings, e.g. <emph role="underline"> expression> </emph>
					</item>
					<item>Left-hand side terms in production rules are nonterminal</item>
					<item>Tokens are represented with text strings enclosed in angle brackets, e.g. &lt;atom&gt;. </item>
					<item>Reserved words are represented by text strings enclosed in double quotes.</item>
					<item>The grammar below uses the following conventions:</item>
					<list role="ordered">
						<item>(x)? denotes zero or one occurrences of x.</item>
						<item>(x)* denotes zero or more occurrences of x.</item>
						<item>(x)+ denotes one or more occurrences of x.</item>
						<item>x | y means one of either x or y.</item>
					</list>
				</list>
				<div3 id="RootSymbol">
					<head> Root Symbol</head>
					<exhibit>
						<pre>
							<p>GELLOExpression::=      SpExpression   
                                |   Expression
                                |   LetStatement
                                |   IfStatement
                                |   ContextNavigationStatement</p>
						</pre>
					</exhibit>
				</div3>
				<div3 id="Literals">
					<head>Literals</head>
					<exhibit>
						<pre>
							<p>Literal::=          &lt;STRING_LITERAL&gt;
                                |   &lt;INTEGER_LITERAL&gt; 
                                |   &lt;REAL_LITERAL&gt; 
                                |   &lt;TRUE&gt; 
                                |   &lt;FALSE&gt; 
                                |   &lt;UNKNOWN&gt; 
                                |   &lt;COLLECTION_LITERAL&gt; 
                                |   &lt;TUPLE_LITERAL&gt; 
                                |   "#" &lt;ID&gt;</p>
						</pre>
					</exhibit>
				</div3>
				<div3 id="DataTypes">
					<head>Data Types</head>
					<exhibit>
						<pre>
							<p>DataTypes::=      GELLOTypes
                                |   ModelTypes</p>
							<p/>
							<p>GELLOTypes::=      BasicType 
                                |   CollectionType 
                                |   TupleType 
                                |   EnumerationType 
                                |   Literal </p>
							<p/>
							<p>BasicType::=         &lt;INTEGER&gt; 
                                |   &lt;STRING&gt;
                                |   &lt;REAL&gt;
                                |   &lt;BOOLEAN&gt;</p>
							<p/>
							<p>ModelTypes::=   ClassName</p>
							<p/>
							<p>CollectionType::=   &lt;SET&gt; 
                                |   &lt;BAG&gt;
                                |   &lt;SEQUENCE&gt;</p>
							<p/>
							<p>TupleType::=   &lt;TUPLE&gt;</p>
							<p/>
							<p>EnumerationType::=   &lt;ENUM&gt;</p>
							<p/>
							<p>ClassName::=   Name</p>
						</pre>
					</exhibit>
				</div3>
				<div3 id="Names">
					<head>Names</head>
					<p>Name::=		&lt;ID&gt; ("." &lt;ID&gt;)*</p>
				</div3>
				<div3 id="Expressions">
					<head>Expressions</head>
					<exhibit>
						<pre>
							<p>Expression::=     ConditionalExpression
                                |   ReferenceToInstance
                                |   FunctorExpression</p>
							<p/>
							<p>ConditionalExpression::=     OrExpression</p>
							<p/>
							<p>OrExpression::=     ConditionalAndExpression (&lt;OR&gt; ConditionalAndExpression  | 
                                    &lt;XOR&gt; ConditionalAndExpression)*</p>
							<p/>
							<p>ConditionalAndExpression::=     ComparisonExpression (&lt;AND&gt; ComparisonExpression)*</p>
							<p/>
							<p>ComparisonExpression::=		AddExpression (&lt;EQUAL&gt; AddExpression | 
                                    &lt;NEQ&gt; AddExpression | &lt;LT&gt; AddExpression  | 
                                    &lt;LEQ&gt; AddExpression | &lt;GT&gt;  AddExpression  | 
                                    &lt;GEQ&gt; AddExpression)*</p>
							<p/>
							<p>AddExpression::=     MultiplyExpression (&lt;MINUS&gt; MultiplyExpression | 
                                    &lt;PLUS&gt; MultiplyExpression)*</p>
							<p/>
							<p>MultiplyExpression::=     UnaryExpression (&lt;TIMES&gt; UnaryExpression | 
                                    &lt;DIVIDE&gt; UnaryExpression | &lt;MAX&gt;  UnaryExpression | 
                                    &lt;MIN&gt; UnaryExpression | &lt;INTDIV&gt; UnaryExpression | 
                                    &lt;MOD&gt; UnaryExpression )*</p>
							<p/>
							<p>UnaryExpression::=     UnaryNumber 
                                |   UnaryModDivNum 
                                |   UnaryMinus 
                                |   MinusModDivNum 
                                |   &lt;NOT&gt; UnaryExpression 
                                |   PrimaryExpression</p>
							<p/>
							<p>UnaryNumber::=     Number</p>
							<p>UnaryMinus::=     - Number</p>
							<p/>
							<p>UnaryModDivNum::=     &lt;INTEGER_LITERAL&gt;</p>
							<p/>
							<p>MinusModDivNum::=	- &lt;INTEGER_LITERAL&gt;</p>
							<p/>
							<p>PrimaryExpression::=     Literal
                                |   Name
                                |   "(" Expression ")"</p>
							<p/>
							<p>FunctorExpression::=     FunctorName "(" ExpressionList ")"</p>
							<p/>
							<p>FunctorName::=     Name</p>
							<p/>
							<p>ExpressionList::=     Expression? (&lt;COMMA&gt; ExpressionList)*</p>
						</pre>
					</exhibit>
				</div3>
				<div3 id="Statements">
					<head>Statements</head>
					<exhibit>
						<pre>
							<p>Statement::=     Expression 
                                |   LetStatement 
                                |   IfStatement 
                                |   SpExpression</p>
							<p/>
							<p>LetStatement::=     &lt;LET&gt; &lt;ID&gt; ":" (   (BasicType | GELLOType) &lt;EQUAL&gt; 
                                    ( Expression | SpExpression )   ) 
                                |   (ClassName &lt;EQUAL&gt; ReferenceToClass  )</p>
							<p/>
							<p>IfStatement::=     &lt;IF&gt; Expression &lt;THEN&gt; Statement &lt;ELSE&gt; Statement &lt;ENDIF&gt;</p>
							<p/>
							<p>ContextNavigationStatement::=     ContextStatement 
                                |   PackageStatement 
                                |   PathnameStatement</p>
							<p/>
							<p>ContextStatement::=     &lt;CONTEXT&gt;  ( ContextBody  | DefinitionBody)</p>
							<p/>
							<p>ContextBody::=     ( "[" Alias "]")? ClassName 
                                (  (&lt;SELF&gt;"." Expression   )  |   Expression   )</p>
							<p/>
							<p>DefinitionBody::=     &lt;DEF&gt; ":" TypeName ":" DataTypes &lt;EQ&gt;  
                                Expression</p>
							<p/>
							<p>Alias::=     &lt;ID&gt;</p>
							<p/>
							<p>PackageStatement::=     &lt;PACKAGE&gt; PackageName  
                                       ContextStatement 
                                  &lt;ENDPACKAGE&gt;</p>
							<p/>
							<p>PackageName::=     Name</p>
							<p/>
							<p>TypeName::=     Name</p>
							<p/>
							<p>PathnameStatement::=     PackageName "::" ( PackageName "::")* TypeName </p>
							<p/>
							<p>SpExpression::=     CollectionExp 
                                |   StringOperation 
                                |   TupleExp</p>
							<p/>
							<p>CollectionExp::=     CollectionName "→ " ExpBody</p>
							<p/>
							<p>CollectionName::=     &lt;ID&gt;</p>
							<p/>
							<p>ExpBody::=     NonParamExp   
                                |   SelectionExp   
                                |   QuantifierExp 
                                |   SingleObjExp   
                                |   ListObjExp   
                                |   GetExp 
                                |   SetExp 
                                |   IterateExp 
                                |   JoinExp</p>
							<p/>
							<p>SelectionExp::=     &lt;SELECT&gt; "("CExp")"  
                                |   &lt;REJECT&gt; "("CExp")"   
                                |   &lt;COLLECT&gt; "("CExp")"  </p>
							<p/>
							<p>QuantifierExp::=     &lt;FORALL&gt; "("CExp")"   
                                |   &lt;EXISTS&gt;  "("CExp")"</p>
							<p/>
							<p>CExp::=     ConditionalExpression 
                                |   ConditionalExpressionWithIterator 
                                |   ConditionalExpressionWithIteratorType</p>
							<p/>
							<p>ConditionalExpressionWithIterator::=     Name "|" ConditionalExpression</p>
							<p/>
							<p>ConditionalExpressionWithIteratorType::=      Name ":" DataTypes "|" ConditionalExpression</p>
							<p/>
							<p>NonParamExp::=     &lt;SIZE&gt; "(" ")"   
                                |   &lt;ISEMPTY&gt; "(" ")"  
                                |   &lt;NOTEMPTY&gt; "(" ")" 
                                |   |  &lt;SUM&gt; "(" ")" 
                                |   &lt;REVERSE&gt; "(" ")" 
                                |   | &lt;MIN&gt; "(" ")" 
                                |   | &lt;MAX&gt; "(" ")" 
                                |   | &lt;FLATTEN&gt; "(" ")"</p>
							<p/>
							<p>SingleObjExp::=	     &lt;COUNT&gt; "(" Object ")" 
                                |   &lt;INCLUDES&gt; "(" Object ")" 
                                |   &lt;INCLUDING&gt; "(" Object ")" 
                                |   &lt;EXCLUDING&gt; "(" Object ")"</p>
							<p/>
							<p>ListObjExp::=     &lt;INCLUDESALL&gt; "(" ObjectList ")" 
                                |   &lt;SORTBY&gt; "(" PropertyList ")"</p>
							<p/>
							<p>GetExp::=     &lt;FIRSTN&gt; "(" &lt;INTEGER_LITERAL&gt; ")" 
                                |   &lt;LASTN&gt; "(" &lt;INTEGER_LITERAL&gt; ")"</p>
							<p/>
							<p>SetExp::=     &lt;INTERSECTION&gt; "(" CollectionName ")" 
                                |   &lt;UNION&gt; "(" CollectionName ")"</p>
							<p/>
							<p>IterateExp::=     &lt;ITERATE&gt; "(" IterateParameterList ")"</p>
							<p/>
							<p>JoinExp::=    &lt;JOIN&gt;  "(" ParameterList ";" ParameterList ";" 
                                    ConditionalExpression ";" ParameterList ")"</p>
							<p/>
							<p>StringOperation::=     Expression "." ( StrSize 
                                |   StrConcat 
                                |   StrToUpper 
                                |   StrToLower 
                                |   Substring )</p>
							<p/>
							<p>StrSize::=     &lt;SIZE&gt; "(" ")"</p>
							<p/>
							<p>StrConcat::=     &lt;CONCAT&gt; "(" Expression ")"</p>
							<p/>
							<p>StrToUpper::=     &lt;TOUPPER&gt; "(" ")"</p>
							<p/>
							<p>StrToLower::=     &lt;TOLOWER&gt; "(" ")"</p>
							<p/>
							<p>Substring::=     &lt;SUBSTRING&gt; "(" &lt;INTEGER&gt;, &lt;INTEGER&gt; ")"</p>
							<p/>
							<p>TupleExp::=     TupleName "." (TupleSize  
                                |   TupleGetValue  
                                |   TupleGetElemName   
                                |   TupleGetElemType )</p>
							<p/>
							<p>TupleSize::=     &lt;SIZE&gt; "(" ")"</p>
							<p/>
							<p>TupleGetValue::=     &lt;GETVALUE&gt; "(" TupleElemName ")"</p>
							<p>TupleGetElemName::=     &lt;GETELEMNAME&gt; "(" &lt;INTEGER&gt; ")"</p>
							<p/>
							<p>TupleGetElemType::=     &lt;GETELEMTYPE&gt; ( "(" &lt;INTEGER&gt; ")" 
                                |   "(" &lt;STRING&gt; ")"  )</p>
							<p/>
							<p>TupleName::=     &lt;ID&gt;</p>
							<p/>
							<p>IterateParameterList::=     Name ":" ClassName ";" Name ":" CollectionName 
                                    &lt;EQUAL&gt; Expression " | " Expression</p>
							<p/>
							<p>ParameterList::=     Expression (&lt;COMMA&gt; ParameterList)*</p>
							<p/>
							<p>ObjectList::=    Object (&lt;COMMA&gt; ObjectList)*</p>
							<p/>
							<p>Object::=     Name</p>
							<p/>
							<p>PropertyList::=     Property (&lt;COMMA&gt; PropertyList)*</p>
							<p/>
							<p>Property::=     Name</p>
							<p/>
							<p>TupleElemName::=     Name</p>
						</pre>
					</exhibit>
				</div3>
				<div3 id="RefInstanceClass">
					<head>Reference to an Instance of a  Model Class</head>
					<p>ReferenceToInstance::=		&lt;FACTORY&gt;.ClassName(ParameterList )</p>
				</div3>
				<div3 id="LitAndIDs">
					<head>Literals and Identifiers</head>
					<p>&lt;NUMBER: 	&lt;INTEGER_LITERAL&gt; | &lt;REAL_LITERAL &gt;&gt;</p>
					<p>&lt;INTEGER_LITERAL: 	&lt;DECIMAL_LITERAL &gt;&gt;</p>
					<p>&lt;#DECIMAL_LITERAL: 	["1"-"9"] (["1"-"9"])*&gt;</p>
					<p>&lt;REAL_LITERAL: 	["0"-"9"])+ "." (["0"-"9"])* (&lt;EXPONENT&gt;)? | "." (["0"-"9"])+ (&lt;EXPONENT&gt;)?   | 
                                    (["0"-"9"])+  &gt;</p>
					<p>&lt;#EXPONENT: 	["e", "E"] (["+","-"])? (["0"-"9"])+&gt;</p>
					<p>&lt;STRING_LITERAL: 	"\’"(~["\", "\n", "\r"])*"\’" &gt;</p>
					<p>&lt;ID:		["a"-"z","A"-"Z"] (["a"-"z","A"-"Z","0"-"9"]  |  "_"(["a"-"z","A"-"Z","0"-"9"])+)* &gt;</p>
					<p>&lt;COLLECTION_LITERAL:    "Set" | "Bag" | "Sequence"&gt;</p>
					<p>&lt;TUPLE_LITERAL:      "Tuple&gt;</p>
				</div3>
				<div3 id="ReservedWords">
					<head>Reserved Words</head>
					<p>&lt;BAG: ‘Bag"&gt;</p>
					<p>&lt;BOOLEAN: "Boolean"&gt;</p>
					<p>&lt;ENUM: "Enum"&gt;</p>
					<p>&lt;INTEGER: "Integer"&gt;</p>
					<p>&lt;REAL: "Real"&gt;</p>
					<p>&lt;SEQUENCE: "Sequence"&gt;</p>
					<p>&lt;SET: "Set"&gt;</p>
					<p>&lt;STRING: "String"&gt;</p>
					<p>&lt;SELF:  "Self"&gt;</p>
					<p>&lt;TUPLE: "Tuple" &gt;</p>
				</div3>
				<div3 id="Operators">
					<head>Operators</head>
					<p>&lt;AND: "&amp;"  |  "and" &gt;</p>
					<p>&lt;ARROW: "→ " &gt;</p>
					<p>&lt;COLLECT:  "collect" &gt;</p>
					<p>&lt;COMMA:  "," &gt;</p>
					<p>&lt;CONCAT:  "concat" &gt;</p>
					<p>&lt;COUNT:  "count" &gt;</p>
					<p>&lt;DIVIDE: "/" &gt;</p>
					<p>&lt;EXCLUDING:  "excluding" &gt;</p>
					<p>&lt;EXISTS: "exists" &gt;</p>
					<p>&lt;FACTORY: "factory"&gt;</p>
					<p>&lt;FIRSTN:  "firstN" &gt;</p>
					<p>&lt;FORALL:  "forAll" &gt;</p>
					<p>&lt;EQUAL:  "=" &gt;</p>
					<p>&lt;GEQ: "&gt;=" &gt;</p>
					<p>&lt;GETELEMNAME:  "getElemName" &gt;</p>
					<p>&lt;GETELEMTYPE:  "getElemType" &gt;</p>
					<p>&lt;GETVALUE:  "getValue" &gt;</p>
					<p>&lt;GT: "&gt;" &gt;</p>
					<p>&lt;IMPLIES: "implies" &gt;</p>
					<p>&lt;INCLUDES: "includes" &gt;</p>
					<p>&lt;INCLUDESALL: "includesAll" &gt;</p>
					<p>&lt;INCLUDING: "including" &gt;</p>
					<p>&lt;INTDIV: "div" &gt;</p>
					<p>&lt;INTERSECTION: "intersection" &gt;</p>
					<p>&lt;ISEMPTY:  "isEmpty" &gt;</p>
					<p>&lt;ITERATE: "iterate" &gt;</p>
					<p>&lt;JOIN:  "join" &gt;</p>
					<p>&lt;LASTN:  "lastN" &gt;</p>
					<p>&lt;LEQ: "&lt;=" &gt;</p>
					<p>&lt;LT: "&lt;" &gt;</p>
					<p>&lt;MAX: "max" &gt;</p>
					<p>&lt;MIN: "min" &gt;</p>
					<p>&lt;MINUS: "-" &gt;</p>
					<p>&lt;MOD: "mod" &gt;</p>
					<p>&lt;NEQ:  "!="  |  "&lt;&gt;" &gt;</p>
					<p>&lt;NEW: "new" &gt;</p>
					<p>&lt;NOT:  "!"  |  "not" &gt;</p>
					<p>&lt;NOTEMPTY:  "notEmpty" &gt;</p>
					<p>&lt;OR: "|" |  |or" &gt;</p>
					<p>&lt;REJECT:  "reject" &gt;</p>
					<p>&lt;REVERSE: "reverse" &gt;</p>
					<p>&lt;SELECT:  "select" &gt;</p>
					<p>&lt;SIZE:  "size" &gt;</p>
					<p>&lt;SORTBY: "sortBy" &gt;</p>
					<p>&lt;SUBSTRING: "substring" &gt;</p>
					<p>&lt;SUM: "sum" &gt;</p>
					<p>&lt;TIMES: "*" &gt;</p>
					<p>&lt;TOLOWER: "toLower" &gt;</p>
					<p>&lt;TOUPPER: "toUpper"&gt;</p>
					<p>&lt;UNION:  "union" &gt;</p>
					<p>&lt;XOR: "*|"  | "xor" &gt;</p>
				</div3>
				<div3 id="StatementOps">
					<head>Statements</head>
					<p>&lt;CONTEXT:  "context" | "Context"&gt;</p>
					<p>&lt;ELSE:  "else" &gt;</p>
					<p>&lt;ENDCONTEXT:  "endContext" | "EndContext"&gt;</p>
					<p>&lt;ENDPACKAGE:  "EndPackage" | "endPackage"&gt;</p>
					<p>&lt;ENDIF:  "endif" &gt;</p>
					<p>&lt;IF: "If"  |  "if" &gt;</p>
					<p>&lt;LET: "Let" | "let" &gt;</p>
					<p>&lt;PACKAGE:  "Package" | "package"&gt;</p>
					<p>&lt;THEN:  "then" &gt;</p>
				</div3>
			</div2>
			<div2 id="GELLOexps">
				<head>GELLO Expressions</head>
				<p>A GELLO expression is any text string conforming to the definition of an expression in the GELLO language specification. GELLO expressions can be used to:</p>
				<list role="unordered">
					<item>Access information from a repository</item>
					<item>Build decision criteria</item>
					<item>Abstract or derive summary values</item>
				</list>
				<p/>
				<p>When an expression is evaluated, the result of such evaluation is a value. The type of the result is the type of the expression. </p>
				<p/>
				<p>Evaluation of an expression does not produce any side effects, although the returning value can be bound to a variable name and used by the guideline to make decisions, control execution flow, etc. If an expression can be embedded in a conditional statement, the returning value is interpreted by the application to which the conditional statement belongs. </p>
			</div2>
			<div2 id="TypeOfExp">
				<head>Type of an Expression</head>
				<p>If an expression denotes a variable or a value, then such expression has a type that must be checked for compatibility. Such variable or value must match any of GELLO predefined §‎5.1.1, collection §‎5.1.3 or tuple data types §‎5.1.4, or classes defined in the underlying data model §‎5.1.2.</p>
				<p/>
				<p>If a value is bound to a variable name, both the returning value and the variable to which it is assigned must be of the same type.</p>
			</div2>
			<div2 id="Termination">
				<head>Normal and Abrupt Completion of Evaluation</head>
				<p>Expressions are evaluated by following a series of steps. Normal completion signifies that all steps can be carried out without an exception being thrown. If, however, evaluation of an expression throws an exception, the expression is said to complete abruptly. GELLO provides basic error checking described in the following section.</p>
				<div3 id="TypeCheck">
					<head>Type Checking</head>
					<p>GELLO was developed as a strongly-typed language in response to the requests of the CDS TC community. Both GELLO and OCL are strongly-typed, hence consistency was maintained. Since GELLO is a strongly-typed language, it checks that the types of all expressions are valid and match one of GELLO or model data types. Similarly, GELLO checks that the operands match the required types for any given operator. In other words, if an operator is applied to an incompatible operand, the return type of the function is undefined. </p>
				</div3>
				<div3 id="Handling">
					<head>Handling Exceptions</head>
					<p>Although GELLO provides basic type checking, it does not provide any mechanisms for handling exceptions as a result of a type mismatch. The applications into which GELLO is embedded should provide the necessary error handling mechanisms.</p>
				</div3>
			</div2>
			<div2 id="EvalExps">
				<head>Evaluation of Expressions</head>
				<p>Expressions are evaluated from left to right. In the case of infix operators, the evaluation order is determined by the precedence of the operators.</p>
				<div3 id="ArgList">
					<head>Argument List</head>
					<p>Argument lists included in method invocations are evaluated left-to-right.</p>
				</div3>
			</div2>
			<div2 id="ExampleExps">
				<head>Example of Expressions</head>
				<p>When the following expressions are evaluated, they return a value of type Boolean. Expressions like these can be used to build decision criteria:</p>
				<exhibit role="example">
					<pre>
						<p/>
   • calcium.notEmpty() and phosphate.notEmpty()
   • renal_failure and calcium_phosphate_product &gt;  threshold_for_osteodystrophy
						
   • Observation(select(coded_concept="C0428279") 
					 
   The expression above returns a collection of observations with a coded concept 
   equal to "C0428279". The result of an expression can be bound to a variable name 
   using the let operator:

    • let CreatinineReadings: set = Observation(select(coded_concept="C0428279")
					</pre>
				</exhibit>
			</div2>
		</div1>
		<div1 id="ExampleGELLO">
			<head>Examples in GELLO</head>
			<p>In this section we present some examples written in GELLO.  </p>
			<div2 id="MLMGELLO">
				<head>An MLM into GELLO</head>
				<p>From a MLM:</p>
				<exhibit role="example">
					<pre>
   maintenance: 
      title: Screening for elevated calcium-phosphate product;; 
   library: 
      purpose: provide an alert if the product of the blood calcium and 
         phosphorus exceeds a certain threshold in the setting of renal failure;;
      explanation: An elevated Ca-PO4 product suggests a tendency toward renal 
         osteodystrophy and predisposes to soft-tissue calcification;; 
					</pre>
				</exhibit>
				<p>Example in GELLO:</p>
				<exhibit role="example">
					<pre>
   let lastCreatinine : Observation = Observation→ select(code= 
         ("SNOMED-CT", "xxxxxx")).sortedBy(efectiveTime.high).last()  
         
   let lastCalcium : Observation = Observation→ select(code = 
         ("SNOMED-CT", "yyyyy")).sortedBy(efectiveTime.high).last() 
         
   let lastPhosphate : Observation = Observation→ select(code= 
         ("SNOMED-CT", "zzzzz")).sortedBy(efectiveTime.high).last() 
         
   let renal_failure_threshold : PhysicalQuantity = 
         Factory.PhysicalQuantity( "2.0, mg/dl") 
   
   let threshold_for_osteodystrophy : int = 70 
   
   let renal_failure :Boolean =    if lastCreatinine &lt;&gt; null and 
         lastCreatine.value.greaterThan(renal_failure_threshold)  
      then          
         true   
      else
         false   
      Endif 
   let calcium_phosphate_product : real = if lastCalcium 
         &lt;&gt; null and lastPhosphate &lt;&gt; null 
      then   
         lastCalcium.value *  lastPhospate.value 
      else   
         -1
      endif 

   if renal_failure and calcium_phosphate_product &gt;  
         threshold_for_osteodystrophy then   
      whatever action or message 
   else   
      whatever action or message
   endif 
					</pre>

				</exhibit>
			</div2>
			<div2 id="ItExample">
				<head>Example of an iteration over more than one collection at a time</head>
				<p>This example shows how collection operators can be nested in expressions as long as they comply with the notation.</p>
				<p>Statement in English (many thanks to Samson Tu):</p>
				<p>"There exists (for a patient) an anti-hypertensive prescription (?drug) such that there exists (for the patient) a problem (?problem) such that ?problem is a compelling indication for ?drug". Where: </p>
				<list role="unordered">
					<item>‘a patient’ is the current patient?</item>
					<item>drug is any drug in the drug database</item>
					<item>?problem is a patient’s problem</item>
				</list>
				<p>Statement in English (many thanks to Samson Tu):</p>
				<exhibit role="example">
					<pre>
   Presence of Azotemia Observation within last three months : Assumptions: 
         1. The data model has as code a generic term such as 
             SNOMED "finding" ("246188002") and the value slot has 
             the code for Azotemia. 
         2. For a diagnosis such as azotemia, the effective time is the time 
             interval during which the disease is thought to be present. 
         3. A PointInTime.NOW() function returns the current time 
 
   Example in GELLO: 
      Let month : CodedValue = Factory.CodedValue(""SNOMED-CT", "258706009"")  
      Let finding : CodedValue = Factory.CodedValue("SNOMED-CT", "246188002") 
      Let azotemia : CodedValue = Factory.CodedValue ("SNOMED-CT", "371019009")
      Observation → exists(code.equal(finding) and value.implies(azotemia) and 
              effective_time.intersect(ThreeMonthsAgo, PointInTime.NOW())) 
						</pre>
				</exhibit>
			</div2>
			<div2 id="ExampleNumber">
				<head>Example: Number of current anti-hypertensive Medications &gt; 1</head>
				<p>Statement in English (many thanks to Samson Tu):</p>
				<p>Number of current anti-hypertensive Medications &gt; 1</p>
				<p/>
				<exhibit role="example">
					<pre>
   Example in GELLO: 
      Let hypotensive_agents : CodedValue = 
            Factory.CodedValue("SNOMED-CT", "1182007")  
            
      MedicationOrder→ select(code.(hypotensive_agents) and 
            effectiveTime.high = null)→ size() &gt; 1  
            
      MedicationOrder→select(code.implies(hypotensive_agents) and 
            effectiveTime.high = null)→size() &gt; 1 
 					</pre>
				</exhibit>
			</div2>
			<div2 id="Example3rdDose">
				<head>3rd Td dose before 12 months of age</head>
				<p>Statement in English (many thanks to Samson Tu):</p>
				<p>3rd Td dose before 12 months of age </p>
				<p/>
				<exhibit role="example">
					<pre>
   Example in GELLO:
      Let month : CodedValue = Factory.CodedValue("SNOMED-CT", "258706009"")
      
      Let DOBcode : CodedValue = Factory.CodedValue ("SNOMED-CT", "184099003")
      
      Let DateOfBirth : Observation= Factory.Observation→ select( 
            code.equal(DOBCode)).sortedBy(effectiveTime.high).last()
            
      Let TwelveMonthsOfAge : PointInTime = Factory.PointInTime(
            DateOfBirth.effectiveTime.high.plus(12, month)) 
            
      Let Td :CodedValue = Factory.CodedValue("SNOMED-CT", "59999009")
      
      Let ThirdTdDose : SubstanceAdministration = Factory.SubstanceAdministration→ 
            select(code.implies(Td)).sortedBy(effectiveTime.high)).third() 
            ThirdTdDose.effectiveTime.high.before(TwelveMonthsOfAge) 
					</pre>
				</exhibit>
			</div2>
		</div1>
		<div1 id="GroupingGELLOexpressionsintoModelProcesses">
			<head>Grouping GELLO expressions into Model Processes</head>
			<p>
GELLO expressions can be grouped into ‘Model processes’ to perform user-defined operations upon given classes of the data model for a specific purpose.
			</p>
			<p/>
			<p>
A model process must be defined as an attribute of a stereotype class which could be:
					<list role="ordered">
					<item>a user-defined class independent of the data model, </item>
					<item>a class dependent of a class in the data model. The latter being the ‘metaclass’ to which the user-defined stereotype class relates to. In this case the stereotype class must follow the UML class hierarchy definition <loc href="http://www.omg.org/docs/formal/03-03-01.pdf">(UML-OMG v1.5 p2-75)</loc>
					</item>
				</list>
			</p>
			<p/>
			<p>
In both cases the names of new stereotypes must not clash with the names of predefined classes in the data model. The stereotype class should not affect any of the properties of the classes in the data model, but rather,  to extend such properties adding extra functionality. 
</p>
			<p/>
			<p>
Stereotypes may be assembled into ‘profiles’ –or libraries. A profile is a stereotyped package containing user-defined stereotype model elements customized for a specific domain or purpose <loc href="http://i12www.ilkd.uni-karlsruhe.de/~baar/oclworkshopUml03/papers/10_combined_model_processing.pdf">(OCL/UML)</loc>. In the following example, Package P1 is the profile where we assembled the stereotypes S1 and S2 dependent on C1 and C2 respectively. Both C1 and C2 are classes from the data model and hence S1 and S2 add extended functionality to those classes.
			</p>
			<exhibit role="example">
				<pre>
  
         Package P1
               Class C1
               Class S1&lt;&lt;stereotype&gt;&gt;
               Class C2
               Class S2&lt;&lt;stereotype&gt;&gt;

					</pre>
			</exhibit>
			<p>
In the following example, S3 is a stereotype independent of the data model located in Package P2:
</p>
			<exhibit role="example">
				<pre>
  
         Package P2
               Class S3 &lt;&lt;stereotype&gt;&gt;
 
					</pre>
			</exhibit>
			<p>
				As with all GELLO expressions, all model processes must be side-effect free, that is, they should not change the state of the modeled system.
				</p>
			<p>
				The exhibit below is the UML representation for a user-defined stereotype class as an extension of a Model Class. </p>
			<p>
				<exhibit role="figure" id="UserDefStereotypeExtModelClass">
					<caption>User-defined stereotype class as an extension of a Model Class 
<loc href="http://www.omg.org/docs/formal/03-03-01.pdf">[From UML-OMG v1.5Fig. 4-1]</loc>
					</caption>
					<graphic source="UserDefinedAndMetaclass.gif"/>
				</exhibit>
			</p>
			<p/>
			<p>The exhibit below is an example of the user-defined Azotemia3months as a stereotype class related to the model class Observation.  CheckAzotemia is the model process containing the GELLO expressions that evaluate whether a patient has suffered from azotemia within the past 3 months.
				</p>
			<p>
				<exhibit role="figure" id="UserDefAzotemia">
					<caption>: User-defined Azotemia3Months stereotype class. The stereotype class depends on the Observation class (metaclass) in the datamodel. The model process CheckAzotemia is an attribute of the stereotype class contraining GELLO expressions.
</caption>
					<graphic source="AzotemiaModelProcessExample.gif"/>
				</exhibit>
			</p>
		</div1>
		<div1 id="Ack">
			<head>Acknowledgements</head>
			<p>We would like to thank Gunther Schadow, Grahame Grieve, Dale Nelson, Bob Dolin, Anthony Malia, Mor Peleg, and Eclipsys Corporation for their valuable comments.</p>
			<p>Support for this project has been provided by the CKBP grant and Partners Information Systems.</p>
		</div1>
		<div1 id="References">
			<head>References</head>
			<p>
				<loc href="http://dsg.bwh.harvard.edu/public_html/msordo/pubs/GELLOWhitePaperV1.2.pdf">• Speaking the same language: sharing clinical knowledge with GELLO expression language. White Paper v 1.2. Decision Systems Group, Harvard Medical School. December 2004.</loc>
			</p>
			<p>
				<loc href="http://www.hl7.org/Library/data-model/RIM/modelpage_mem.htm">
			• HL7 RIM   
		</loc>
			</p>
			<p>
				<loc href="http://www.hl7.org/Library/data-model/RIM/C30202/rim.htm">
			• HL7 RIM information model
		</loc>
			</p>
			<p>
				<loc href="http://www.omg.org/docs/formal/03-03-01.pdf">
			• UML-OMG v1.5
			    </loc>
			</p>
			<p>
				<loc href="http://i12www.ilkd.uni-karlsruhe.de/~baar/oclworkshopUml03/papers/10_combined_model_processing.pdf">
			• Combining OCL and Programming Languages for UML Model Processing
			   </loc>
			</p>
			<p>
				<loc href="http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&amp;db=PubMed&amp;list_uids=11825198&amp;dopt=Abstract">
			• A virtual medical record for guideline-based decision support. 
		</loc>
			</p>
			<p>
				<loc href="http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&amp;db=PubMed&amp;list_uids=11825198&amp;dopt=Abstract">			
			• The Virtual Medical Record (vMR) 
		</loc>
			</p>
			<p>
				<loc href="http://smi-web.stanford.edu/people/tu/HL7/HL7SanDiegoJan2002.txt">			
			• Minute from HL7 CDS TC  San Diego, CA, January 2002.
		</loc>
			</p>
			<p>
				<loc href="http://dsg.bwh.harvard.edu/~msordo/GELLO/GELLClassesBNF.rtf">
				• [DSG02-01] 
				   BNF and built-in classes for object-oriented guideline expression language (GELLO). </loc>
			</p>
			<p>
				<loc href="http://dsg.bwh.harvard.edu/~msordo/GELLO/Arden_GLIF_May_2001_AB.ppt">
			  • [TC1]   Harmonization of Arden’s expression syntax and the RIM
		</loc>
			</p>
			<p>
				<loc href=" http://dsg.bwh.harvard.edu/~msordo/gello/gello.ppt">
			• [TC2]  Expression and query languages
		</loc>
			</p>
			<p>
				<loc href="http://www.hl7.org/library/committees/dss/minutes/expr-lang-boxwala-10-2001.ppt">
• [TC3]  Progress on Guideline Expression Language
		</loc>
				<loc href="http://dsg.bwh.harvard.edu/~msordo/gello/slc.ppt">
			also here 
		</loc>
			</p>
			<p>
				<loc href="http://www.hl7.org/library/committees/dss/minutes/gelloupdate2-W2002.ppt">
				•  [TC4]  Progress on Object-Oriented Guideline Expression Language (GELLO)
		</loc>
				<loc href="http://dsg.bwh.harvard.edu/~msordo/gello/gelloupdate.ppt">
			Also here
		</loc>
			</p>
			<p>
				<loc href="http://dsg.bwh.harvard.edu/~msordo/gello/GELLO_may02.ppt">	
				• [TC5]  The GELLO Report.  
				2002 Spring WGM
		</loc>
			</p>
			<p>
				<loc href="http://cslxinfmtcs.csmc.edu/hl7/arden/HL7GELLOUpdate_1002.ppt">
• [TC6]  GELLO Update.  HL7 Meeting, Baltimore,  October 2002
		</loc>
			</p>
			<p>
				<loc href="http://www.omg.org/cgi-bin/doc?ptc/03-10-14.pdf">
			• UML 2.0 OCL 
		</loc>
			</p>
			<p>
				<loc href="http://www.dmi.columbia.edu/homepages/wandong/homepage20030805_files/GESDOR.htm">
			• Guideline Execution Model 
		</loc>
			</p>
			<p>
				<loc href="http://www.w3.org/TR/2003/WD-owl-ref-20030221/">
				• OWL latest work in progress report
		</loc>
			</p>
			<p>
				<loc href="http://www.w3.org/TR/owl-guide/wine.rdf">
			• Example of an OWL ontology.
		</loc>
			</p>
			<p>
				<loc href="http://www.w3.org/TR/">
			• Current W3C recommendations and technical documents
		</loc>
			</p>
			<p>
				<xspecref spec="datatypes-its-uml" alt="&#8226; UML ITS data model"/>
			</p>
			<p>
				<loc href="">
			• [GR04] </loc> Design of a Standards-Based External Rules Engine for Decision Support
               in a Variety of Application Contexts: Report of a Feasibility Study at Partners 
			   HealthCare System. 
			  To appear at Symposium of the Medical Informatics Association (MedInfo), September, 2004
			</p>
		</div1>
		<back>
			<div1 id="annexA">
				<head>Annex A: HL7v3DataTypes</head>
				<p>
					<exhibit role="figure">
						<caption>HL7 Version 3 Data Types</caption>
						<graphic source="HL7v3DataTypes.gif"/>
					</exhibit>
				</p>
			</div1>
			<div1 id="annexB">
				<head>Annex B: The HL7 Reference Information Model</head>
				<p>
					<ilxspecref spec="&rimfile;" ref="RIM-CoreGraphics">THIS IS THE SECTION WHERE THE DIAGRAM IS----- RIM FoundationClasses Subject Area</ilxspecref>
					<!-- 1.4.4.1 -->
				</p>
			</div1>
			<div1 id="annexC">
				<head>Annex C: The core UML OCL kernel declarations</head>
				<exhibit role="figure">
					<caption>The core UML / OCL kernel declarations</caption>
					<graphic source="uml-its-main.gif"/>
				</exhibit>
			</div1>
			<div1 id="annexD">
				<head>Annex D: A Simplified Data Model</head>
				<p>The following is a simplified data model included in this specification so examples of GELLO operators and operations can be illustrated and easily followed. The model upon which the simplified data model is based is the result of a feasibility study which reviewed various decision support systems within Brigham &amp; Women’s Hospital and Massachusetts General Hospital [GR04]. The simplified data model consists of 5 model classes, each of which holds some properties that can be mapped into the HL7 RIM. These 5 classes and their equivalent in the RIM are showed in Table 1.</p>
				<table id="DataModelAndHL7RIM">
					<tr>
						<th>Classes in the Data Model</th>
						<th>Equivalent Classes in the HL7 RIM</th>
					</tr>
					<tr>
						<td>Patient</td>
						<td>Person in the role of Patient</td>
					</tr>
					<tr>
						<td>LabResult</td>
						<td>Observation</td>
					</tr>
					<tr>
						<td>ProblemLIst</td>
						<td>Observation</td>
					</tr>
					<tr>
						<td>Allergy</td>
						<td>Observation</td>
					</tr>
					<tr>
						<td>Medication</td>
						<td>Substance Administration</td>
					</tr>
				</table>
				<p>Figure below depicts the data model. Each class includes some properties equivalent to those found in the RIM. The data model is by no means extensive. This data model will be used along the document to exemplify the use of GELLO operators in expressions in a simple manner.</p>
				<exhibit role="figure">
					<caption>Simplified Data Model</caption>
					<graphic source="MiniVMRforExamplesInSpecs.gif"/>
				</exhibit>
				<p>When referencing RIM classes directly more complex expressions can be written. Such expressions may include references to mood, and class code, in accordance with the HL7 RIM specification.</p>
			</div1>
			<div1 id="annexE">
				<head>Annex E: Temporal Relations and Temporal Intervals</head>
				<p>It is assumed that the HL7 v3 Data Types provides all 13 operators for handling Allen relations on temporal intervals. Such operators can be used in GELLO expressions referring to the appropriate model class and method. The 13 operators are described below for clarity.</p>
				<p/>
				<p>A time interval is a set of consecutive time-stamps values during which the given information is expected to be valid. As defined in HL7 V3 Data Types (p 100), a time interval can be open or closed, infinite or undefined on either side. Graphic examples of temporal relations are depicted in Figure 2. There are thirteen fundamental relations, known as the Allen primitives, between pairs of time intervals.</p>
				<div2 id="before">
					<head>Before</head>
					<p>The notation is: </p>
					<exhibit role="example">
						<pre>
   before(interval1,interval2).  
 
Types of "before" 
   (timeInterval x timeInterval) → Boolean 
 
Definition of evaluation function for Fbefore(IVL1,IVL2) 
 Fbefore(IVL,IVL) = true      If IVL1 and IVL2 are both time intervals and the 
                              end-point of interval1 occurs strictly earlier 
                              than the start-point of interval2. 
                  = false     Else if IVL1 and IVL2 are both time intervals 
                              and the end-point of interval1 does not occur 
                              strictly earlier than the start-point of interval2. 
                  = undefined otherwise 
					</pre>
					</exhibit>
				</div2>
				<div2 id="after">
					<head>After</head>
					<p>The notation is: </p>
					<exhibit role="example">
						<pre>
   after(interval1,interval2).  
 
Types of "after" 
   (timeInterval x timeInterval) → Boolean 
 
Definition of evaluation function for Fafter(IVL1,IVL2)
Fafter(IVL,IVL) = true         If IVL1 and IVL2 are both time intervals and 
                               the start-point of interval1 occurs (starts) after 
                               the end-point of interval2. 
                = false        Else if IVL1 and IVL2 are both time intervals and 
                               the start-point of interval1 does not occur after 
                               the end-point of interval2. 
                = undefined    otherwise 
					  </pre>
					</exhibit>
				</div2>
				<div2 id="Meets">
					<head>Meets</head>
					<p>The notation is: </p>
					<exhibit role="example">
						<pre>
   meets(interval1,interval2).  
 
Types of "meets" 
   (timeInterval x timeInterval) → Boolean 
 
Definition of evaluation function for Fmeets(IVL1,IVL2) 
Fmeets(IVL,IVL) = true          If IVL1 and IVL2 are both time intervals and 
                                 the end-point of interval1 is simultaneous with 
                                 the start-point of interval2. 
                = false          Else if IVL1 and IVL2 are both time intervals and 
                                 end-point of interval1 is not simultaneous with 
                                 the start-point of interval2.
                = undefined      otherwise 
					 </pre>
					</exhibit>
				</div2>
				<div2 id="MetBy">
					<head>Met-By</head>
					<p>The notation is: </p>
					<exhibit role="example">
						<pre>
   met-by(interval1,interval2).  
 
Types of "met-by" 
    (timeInterval x timeInterval) → Boolean

Definition of evaluation function for Fmet-by(IVL1,IVL2)
Fmet-by(IVL,IVL) = true      If IVL1 and IVL2 are both time intervals and the 
                             start-point of interval1 is simultaneous with the 
                             end-point of interval2.
                = false      Else if IVL1 and IVL2 are both time intervals and 
                             start-point of interval1 is not simultaneous with 
                             the end-point of interval2.
                = undefined  otherwise
				  </pre>
					</exhibit>
				</div2>
				<div2 id="Overlaps">
					<head>Overlaps</head>
					<p>The notation is: </p>
					<exhibit role="example">
						<pre>
   overlaps(interval1,interval2). 
 
Types of "overlaps"
    (timeInterval x timeInterval) → Boolean
 
Definition of evaluation function for Foverlaps(IVL1,IVL2)
Foverlaps(IVL,IVL) = true        If IVL1 and IVL2 are both time intervals and 
                                 the start-point of interval1 is earlier than  
                                 the start-point of interval2, but the end-point 
                                 of interval1 occurs strictly between the 
                                 start- and end-points of interval2.
                   = false       Else if IVL1 and IVL2 are both time intervals 
                                 and start-point of interval1 is not earlier 
                                 than the start-point of interval2, or  the 
                                 end-point of interval1 does not ocurr
                                 strictly between the start- and 
                                 end-points of interval2.
                   = undefined  otherwise
					 </pre>
					</exhibit>
				</div2>
				<div2 id="overlapped">
					<head>Overlapped-by</head>
					<p>The notation is: </p>
					<exhibit role="example">
						<pre>
   overlapped-by(interval1,interval2). 
 
Types of "overlapped-by"
   (timeInterval x timeInterval) → Boolean
 
Definition of evaluation function for Foverlapped-by(IVL1,IVL2)
Foverlapped-by(IVL,IVL) = true        If IVL1 and IVL2 are both time intervals 
                                      and the start-point of interval1 occurs 
                                      between the start- and end-points of 
                                      interval2, but the end-point of interval1 
                                      occurs later than the end-point of interval2.
                        = false       Else if IVL1 and IVL2 are both time intervals 
                                      and the start-point of interval1 does not 
                                      occur between the start- and end-points 
                                      of interval2, or the end-point of interval1 
                                      occurs before the end-point of interval2.
                        = undefined   otherwise
					 </pre>
					</exhibit>
				</div2>
				<div2 id="Starts">
					<head>Starts</head>
					<p>The notation is: </p>
					<exhibit role="example">
						<pre>
   starts(interval1,interval2). 
Types of "starts"
   (timeInterval x timeInterval) → Boolean
 
Definition of evaluation function for Fstarts(IVL1,IVL2)
Fstarts(IVL,IVL) = true       If IVL1 and IVL2 are both time intervals and the 
                               start-point of interval1 occurs simultaneously 
                               with the start-point of interval2, but the 
                               end-point of interval1 occurs before the
                               end-point of interval2.
                 = false       Else if IVL1 and IVL2 are both time intervals 
                               and the start-point of interval1 does not occur 
                               simultaneously with the start-point of interval2, 
                               or the end-point of interval1 occurs after the
                               end-point of interval2.
                 = undefined   otherwise
					 </pre>
					</exhibit>
				</div2>
				<div2 id="StartedBy">
					<head>Started-by</head>
					<p>The notation is: </p>
					<exhibit role="example">
						<pre>
   started-by(interval1,interval2). 
 
Types of "started-by"
    (timeInterval x timeInterval) → Boolean
 
Definition of evaluation function for Fstarted-by(IVL1,IVL2)
Fstarted-by(IVL,IVL) = true        If IVL1 and IVL2 are both time intervals and
                                   the start-point if interval1 is simultaneous 
                                   with the start-point of interval2, but the 
                                   end-point of interval1 occurs later than the 
                                   end-point of interval2.
                     = false       Else if IVL1 and IVL2 are both time 
                                   intervals and the start-point if interval1 is 
                                   not simultaneous with the start-point of 
                                   interval2, or the end-point of interval1 
                                   occurs before the end-point of interval2.
                     = undefined   otherwise
					 </pre>
					</exhibit>
				</div2>
				<div2 id="During">
					<head>During</head>
					<p>The notation is: </p>
					<exhibit role="example">
						<pre>
   during(interval1,interval2). 
					<p/>
Types of "during"
   (timeInterval x timeInterval) → Boolean
 
Definition of evaluation function for Fduring(IVL1,IVL2)
Fduring(IVL,IVL) = true         If IVL1 and IVL2 are both time intervals and  
                                the start-point of interval1 occurs after the 
                                start-point of interval2 and the end-point of 
                                interval1 occurs earlier than the end-point 
                                of interval2.
                 = false        Else if IVL1 and IVL2 are both time intervals 
                                but the start-point of interval1 occurs before 
                                the start-point of interval2 or the end-point of 
                                interval1 occurs later than the end-point of 
                                interval2.
                 = undefined    otherwise
					 </pre>
					</exhibit>
				</div2>
				<div2 id="Contains">
					<head>Contains</head>
					<p>The notation is: </p>
					<exhibit role="example">
						<pre>
   contains(interval1,interval2). 
 
Types of "contains"
   (timeInterval x timeInterval) → Boolean

Definition of evaluation function for Fcontains(IVL1,IVL2)
Fcontains(IVL,IVL) = true         If IVL1 and IVL2 are both time intervals and 
                                  the start-point of interval1 is earlier than the 
                                  start-point of interval2, and the end of interval1 
                                  occurs later than the end-point of interval2.
                   = false        Else if IVL1 and IVL2 are both time intervals but 
                                  the start-point of interval1 is later than the 
                                  start-point of interval2, or the end of interval1  
                                  occurs earlier than the end-point of interval2.
                   = undefined    otherwise
					  </pre>
					</exhibit>
				</div2>
				<div2 id="Finishes">
					<head>Finishes</head>
					<p>The notation is: </p>
					<exhibit role="example">
						<pre>
   finishes(interval1,interval2). 
 
Types of "finishes"
   (timeInterval x timeInterval) → Boolean
 
Definition of evaluation function for Ffinishes(IVL1,IVL2)
Ffinishes(IVL,IVL) = true         If IVL1 and IVL2 are both time intervals and 
                                  the end-point of interval1 is simultaneous with 
                                  the end-point of interval2, but the start-point  
                                  of interval1 is later than the start-point of 
                                  interval2.
                   = false        Else if IVL1 and IVL2 are both time intervals 
                                  but the end-point of interval1is not 
                                  simultaneous with the end-point of interval2, 
                                  or the start-point of interval1 is earlier than the 
                                  start-point of interval2.
                   = undefined    otherwise
					  </pre>
					</exhibit>
				</div2>
				<div2 id="FinishedBy">
					<head>Finished-by</head>
					<p>The notation is: </p>
					<exhibit role="example">
						<pre>
   finished-by(interval1,interval2). 
 
Types of "finished-by"
    (timeInterval x timeInterval) → Boolean
 
Definition of evaluation function for Ffinished-by(IVL1,IVL2)
Ffinished-by(IVL,IVL) = true         If IVL1 and IVL2 are both time intervals and
                                     the end-point of interval1 is simultaneous with 
                                     the end-point of interval2, but the start-point of 
                                     interval1 is earlier than the start-point of interval2.
                      = false        Else if IVL1 and IVL2 are both time intervals but the 
                                     end-point of interval1 is not simultaneous with 
                                     the end-point of interval2, or  the start-point of 
                                     interval1 is later than the start-point of interval2.
                      = undefined    otherwise
					  </pre>
					</exhibit>
				</div2>
				<div2 id="Equals">
					<head>Equals</head>
					<p>The notation is: </p>
					<exhibit role="example">
						<pre>
   equals(interval1,interval2). 
 
Types of "equals"
   (timeInterval x timeInterval) → Boolean
 
Definition of evaluation function for Fequals(IVL1,IVL2)
Fequals(IVL,IVL) = true        If IVL1 and IVL2 are both time intervals and the 
                               start- and end-points of both interval1 and 
                               interval2 are respectively simultaneous.
                 = false       Else if IVL1 and IVL2 are both time intervals 
                               but the start- and end-points of both interval1 
                               and interval2 respectively are not simultaneous.
                 = undefined   otherwise
					  </pre>
					</exhibit>
				</div2>
				<p>
					<exhibit role="figure">
						<caption>Temporal Relations between Time Intervals</caption>
						<graphic source="temporalRelations.gif"/>
					</exhibit>
				</p>
			</div1>
		</back>
	</body>
</spec>
<!-- MY eof -->
