<?xml version="1.0" encoding="ISO-8859-1"?><!-- $Id: datatypes-its-xml.xml,v 1.7 2006/05/22 19:16:19 dlloyd Exp $ --><spec xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:gsd="http://aurora.regenstrief.org/GenericXMLSchema" xmlns:xlink="http://www.w3.org/TR/WD-xlink"><header><title>XML Implementation Technology Specification - Data Types</title><version>1.0</version><ballot type="Membership" number="1"/><date>December 2003</date><authlist><author><role>Editor</role><name>Gunther Schadow</name><affiliation>Regenstrief Institute for Health Care</affiliation><email href="gunther@aurora.rg.iupui.edu" xlink-form="simple" show="embed" actuate="auto"/></author><author><role>Editor</role><name>Paul Vincent Biron</name><affiliation>Kaiser Permanente</affiliation><email href="Paul.V.Biron@kp.org" xlink-form="simple" show="embed" actuate="auto"/></author><author><role>Editor</role><name>Grahame Grieve</name><affiliation>Kestral Computing P/L</affiliation><email href="grahame@kestral.com.au" xlink-form="simple" show="embed" actuate="auto"/></author><author><role>Editor</role><name>Doug Pratt</name><affiliation>Siemens Medical Solutions, Health Services Co.
                      </affiliation><email href="doug.pratt@smed.com" xlink-form="simple" show="embed" actuate="auto"/></author></authlist></header><front><div1 id="datyp2preface"><head>Preface</head><p>
            This document specifies the HL7 Version 3 Data Types in the
            context of their XML Implementation Technology Specification (ITS).
          </p>
          <p>
            This document is based on the Data Types Abstract Specification, which defines
            the data types on an abstract layer independent from representation.
         </p><p>
            Vocabulary tables within this specification list the current
            contents of vocabulary domains for ease of reference by the
            reader. However, at any given time the normative source for these
            domains is the vocabulary tables in the RIM database. For some large
            domains, only a sample of possible values is shown. The complete
            domains can be referenced in the vocabulary tables by looking up the
            domain name associated with the table in the RIM vocabulary
            tables.
         </p></div1><div1 id="datyp2acks"><head>Acknowledgements</head><p>
            The following persons served as co-editors of this document or have
            otherwise made major contributions to this specification.  Wes Rishel
            (Gartner Group) has driven the initial forumlation of the approach.
            Paul V. Biron (Kaiser Permanente) has prepared the first ballot draft
            and continued to be a major support in all XML matters.  Douglas Pratt
            (Siemens) has contributed the initial distillation of the abstract
            definitions. Gunther Schadow (Regenstrief Institute, Inc.) has done
            most of the editing, document automation, and maintenance during the
            many ballot cycles.  Major contributions of thought are from Mark
            Tucker (Regenstrief Institute). Lloyd McKenzie (IBM), and Grahame
            Grieve (Kestral Computing Pty. Ltd.) have helped in the cleaning
            up of many aspects of the recent ballot draft.
         </p></div1></front><body>
         <div1 id="intro" ballotStatus="NormativeStandard"><head>Introduction</head><p><emph role="strong">What is a Data Type?</emph>
            Data types are the basic building blocks used to construct messages,
            computerized patient record documents, business objects and their
            transactions. Data types define the meaning of any given field's
            value. Without knowing a field's data type, it is impossible to
            interpret the field's value.
         </p><p><emph role="strong">Representation of Data Values.</emph>
            On an abstract layer, independent from representation, data types
            define properties of values. When values are represented, some of
            their properties are directly represented as atomic literal forms or
            as data structures. At that point we call those properties
            "components". On the representation layer we can also distinguish
            simple data types, represented as atomic literal forms, from complex
            ones, represented as structures with components. For the implementor,
            it is important to realize that data types have more properties than
            shown as components, and that it only depends on the implementation
            technology and ITS specification what data types are simple or complex
            and which of their properties are represented as "components" and
            which are inferred from those components.
         </p><p>
            This specification defines standard representations for data values in
            XML only. Other ITS, and programming environments may choose different
            representations and data structures, all of which must be consistent
            with the Data Types Abstract Specification.
         </p><div2 id="organization"><head>Organization of this Specification</head><p>This specification is divided in two major parts:</p><list role="ordered"><item>Basic data types</item><item>Generic data types (templates)</item></list><p>
               The fully specified data types are organized approximately in the same
               order in which they appear in the Data Types Abstract Specification, divided in roughly
               three categories: (1) boolean, binary, text and multimedia, (2) codes
               and identifiers, and (3) quantitative data types.
            </p><p>
               Generic types are about collections (sets, lists, etc.) and common
               data type extensions to deal with uncertainty, time-dependency and
               other qualifications of data values. Finally, the framework of
               specifying complex timing patterns (e.g., for scheduling periodic
               activities) is mostly specified in terms of generic data types.
            </p><p>
               The following table lists all data types specified in the XML ITS.
            </p><table id="dtimpl-summary-table"><caption>
       Overview of HL7 version 3 data types
    </caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Symbol</th><th>Description</th></tr></thead><tbody><tr><td>Data Value</td><td><termref ref="dtimpl-ANY">ANY</termref></td><td>
            Defines the basic properties of every data value. This
            is an abstract type, meaning that no value can be just
            a data value without belonging to any concrete type.
            Every concrete type is a specialization of this
            general abstract DataValue type.
         </td></tr><tr><td>Boolean</td><td><termref ref="dtimpl-BL">BL</termref></td><td>
            The Boolean type stands for the values of two-valued logic.
            A Boolean value can be either <emph>true</emph> or
            <emph>false</emph>, or, as any other value may be NULL.
         </td></tr><tr><td>BooleanNonNull</td><td><termref ref="dtimpl-BN">BN</termref></td><td>
            The BooleanNonNull type is used where a Boolean cannot
            have a null value. A Boolean value can be either
            <emph>true</emph> or <emph>false</emph>.
         </td></tr><tr><td>Binary Data</td><td><termref ref="dtimpl-BIN">BIN</termref></td><td>
            Binary data is a raw block of bits. Binary data is a
            protected type that MUST not be used outside the data
            type specification.
         </td></tr><tr><td>Encapsulated Data</td><td><termref ref="dtimpl-ED">ED</termref></td><td>
            Data that is primarily intended for human interpretation
            or for further machine processing is outside the scope of
            HL7. This includes unformatted or formatted written language,
            multimedia data, or structured information as defined by a
            different standard (e.g., XML-signatures.)  Instead of the
            data itself, an <termref ref="dtimpl-ED">ED</termref> may contain 
            only a reference (see <termref ref="dtimpl-TEL">TEL</termref>.) Note
            that the <termref ref="dtimpl-ST">ST</termref> data type is a
            specialization of <emph>ED</emph>
            when the <termref ref="comp-ED.mediaType">mediaType</termref> is <emph>text/plain</emph>.
         </td></tr><tr><td>Character String</td><td><termref ref="dtimpl-ST">ST</termref></td><td>
            The character string data type stands for text data,
            primarily intended for machine processing (e.g.,
            sorting, querying, indexing, etc.) Used for names,
            symbols, and formal expressions.
         </td></tr><tr><td>Coded Simple Value</td><td><termref ref="dtimpl-CS">CS</termref></td><td>
            Coded data in its simplest form, consists of a code.
            The code system and code system version is fixed by 
            the context in which the <emph>CS</emph> value occurs. <emph>CS</emph> is used
            for coded attributes that have a single HL7-defined
            value set.
         </td></tr><tr><td>Coded Value</td><td><termref ref="dtimpl-CV">CV</termref></td><td>
            Coded data, consists of a code, display name, code system,
            and original text. Used when a single code value must be sent.
         </td></tr><tr><td>Coded Ordinal</td><td><termref ref="dtimpl-CO">CO</termref></td><td>
            Coded data, where the domain from which the codeset comes
            is ordered. The Coded Ordinal data type adds semantics
            related to ordering so that models that make use of such
            domains may introduce model elements that involve statements
            about the order of the terms in a domain. 
         </td></tr><tr><td>Coded with Equivalents</td><td><termref ref="dtimpl-CE">CE</termref></td><td>
            Coded data, consists of a coded value (<termref ref="dtimpl-CV">CV</termref>)
            and, optionally, coded value(s) from other coding systems
            that identify the same concept. Used when alternative
            codes may exist.
         </td></tr><tr><td>Concept Descriptor</td><td><termref ref="dtimpl-CD">CD</termref></td><td>
            A concept descriptor represents any kind of concept usually
            by giving a code defined in a code system.  A concept
            descriptor can contain the original text or phrase that
            served as the basis of the coding and one or more
            translations into different coding systems. A concept
            descriptor can also contain qualifiers to describe, e.g.,
            the concept of a "left foot" as a postcoordinated term built
            from the primary code "FOOT" and the qualifier "LEFT".
            In exceptional cases, the concept descriptor need not
            contain a code but only the original text describing
            that concept.
         </td></tr><tr><td>Concept Role</td><td><termref ref="dtimpl-CR">CR</termref></td><td>
            A concept qualifier code with optionally named role.
            Both qualifier role and value codes must be defined by
            the coding system.  For example, if SNOMED RT defines a
            concept "leg", a role relation "has-laterality", and
            another concept "left", the concept role relation allows
            to add the qualifier "has-laterality: left" to a primary
            code "leg" to construct the meaning "left leg".
         </td></tr><tr><td>Character String with Code</td><td><termref ref="dtimpl-SC">SC</termref></td><td>
            An <termref ref="dtimpl-ST">ST</termref> that optionally may have a code attached.
            The text must always be present if a code is present. The
            code is often a local code.
         </td></tr><tr><td>Unique Identifier String</td><td><termref ref="dtimpl-UID">UID</termref></td><td>
            A unique identifier string is a character string which
            identifies an object in a globally unique and timeless
            manner. The allowable formats and values and procedures
            of this data type are strictly controlled by HL7. At this
            time, user-assigned identifiers may be certain character
            representations of ISO Object Identifiers (<termref ref="dtimpl-OID">OID</termref>)
            and DCE
            Universally Unique Identifiers (<termref ref="dtimpl-UUID">UUID</termref>).
            HL7 also reserves
            the right to assign other forms of UIDs (<termref ref="dtimpl-RUID">RUID</termref>,
            such as mnemonic
            identifiers for code systems.
         </td></tr><tr><td>Instance Identifier</td><td><termref ref="dtimpl-II">II</termref></td><td>
            An identifier that uniquely identifies a thing or object.
            Examples are object identifier for HL7 RIM objects,
            medical record number, order id, service catalog item id,
            Vehicle Identification Number (VIN), etc. Instance
            identifiers are defined based on ISO object identifiers.
         </td></tr><tr><td>Universal Resource Locator</td><td><termref ref="dtimpl-URL">URL</termref></td><td>
            A telecommunications address  specified according to
            Internet standard RFC 1738
            [<loc href="http://www.ietf.org/rfc/rfc1738.txt" xlink-form="simple" show="embed" actuate="auto"/>]. The
            URL specifies the protocol and the contact point defined
            by that protocol for the resource.  Notable uses of the
            telecommunication address data type are for telephone and
            telefax numbers, e-mail addresses, Hypertext references,
            FTP references, etc.
         </td></tr><tr><td>Telecommunication Address</td><td><termref ref="dtimpl-TEL">TEL</termref></td><td>
            A telephone number (voice or fax), e-mail address, or
            other locator for a resource (information or service)
            mediated by telecommunication equipment. The address
            is specified as a <termref ref="dtimpl-URL">URL</termref>
            qualified by time specification and use codes that help
            in deciding which address to use for a given time and
            purpose.
         </td></tr><tr><td>Address Part</td><td><termref ref="dtimpl-ADXP">ADXP</termref></td><td>
            A character string that may have a type-tag signifying its
            role in the address. Typical parts that exist in about
            every address are street, house number, or post box,
            postal code, city, country but other roles may be defined
            regionally, nationally, or on an enterprise level (e.g. in
            military addresses). Addresses are usually broken up into
            lines, which are indicated by special line-breaking
            delimiter elements (e.g., DEL).
         </td></tr><tr><td>Postal Address</td><td><termref ref="dtimpl-AD">AD</termref></td><td>
            Mailing and home or office addresses. A sequence of
            address parts, such as street or post office Box, city,
            postal code, country, etc.
         </td></tr><tr><td>Entity Name Part</td><td><termref ref="dtimpl-ENXP">ENXP</termref></td><td>
            A character string token representing a part of a name.
            May have a type code signifying the role of the part in
            the whole entity name, and a qualifier code for more detail
            about the name part type. Typical name parts for person
            names are given names, and family names, titles, etc.
         </td></tr><tr><td>Entity Name</td><td><termref ref="dtimpl-EN">EN</termref></td><td>
            A name for a person, organization, place or thing. A
            sequence of name parts, such as given name or family
            name, prefix, suffix, etc. Examples for entity name
            values are "Jim Bob Walton, Jr.", "Health Level Seven,
            Inc.", "Lake Tahoe", etc. An entity name may be as simple
            as a character string or may consist of several entity name
            parts, such as, "Jim", "Bob", "Walton", and "Jr.", "Health
            Level Seven" and "Inc.", "Lake" and "Tahoe".
         </td></tr><tr><td>Person Name</td><td><termref ref="dtimpl-PN">PN</termref></td><td>
            A name for a person. A sequence of name parts, such as
            given name or family name, prefix, suffix, etc. PN differs
            from EN because the qualifier type cannot include LS
            (Legal Status).
         </td></tr><tr><td>Organization Name</td><td><termref ref="dtimpl-ON">ON</termref></td><td>
            A name for an organization. A sequence of name parts.
         </td></tr><tr><td>Trivial Name</td><td><termref ref="dtimpl-TN">TN</termref></td><td>
            A restriction of entity name that is effectively a simple string used
            for a simple name for things and places.
         </td></tr><tr><td>Quantity</td><td><termref ref="dtimpl-QTY">QTY</termref></td><td><emph>QTY</emph> is an abstract generalization
            for all data types (1) whose value set has an order
            relation (less-or-equal) and (2) where difference is
            defined in all of the data type's totally ordered value
            subsets.  The quantity type abstraction is needed in
            defining certain other types, such as the interval and
            the probability distribution.
         </td></tr><tr><td>Integer Number</td><td><termref ref="dtimpl-INT">INT</termref></td><td>
            Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise
            numbers that are results of counting and enumerating.
            Integer numbers are discrete, the set of integers is
            infinite but countable.  No arbitrary limit is imposed on
            the range of integer numbers. Two NULL flavors are
            defined for the positive and negative infinity.
         </td></tr><tr><td>Real Number</td><td><termref ref="dtimpl-REAL">REAL</termref></td><td>
            Fractional numbers. Typically used whenever quantities
            are measured, estimated, or computed from other real
            numbers.  The typical representation is decimal, where
            the number of significant decimal digits is known as the
            precision. Real numbers are needed beyond integers
            whenever quantities of the real world are measured,
            estimated, or computed from other real numbers. The term
            "Real number" in this specification is used to mean
            that fractional values are covered without necessarily
            implying the full set of the mathematical real numbers.
         </td></tr><tr><td>Physical Quantity</td><td><termref ref="dtimpl-PQ">PQ</termref></td><td>
            A dimensioned quantity expressing the result of a
            measurement act.
        </td></tr><tr><td>Physical Quantity Representation</td><td><termref ref="dtimpl-PQR">PQR</termref></td><td>
            A representation of a physical quantity in a unit from
            any code system. Used to show alternative representation
            for a physical quantity.
         </td></tr><tr><td>Monetary Amount</td><td><termref ref="dtimpl-MO">MO</termref></td><td>
            A monetary amount is a quantity expressing the amount of
            money in some currency. Currencies are the units in which
            monetary amounts are denominated in different economic
            regions. While the monetary amount is a single kind of
            quantity (money) the exchange rates between the different
            units are variable.  This is the principle difference
            between physical quantity and monetary amounts, and the
            reason why currency units are not physical units.
         </td></tr><tr><td>Ratio</td><td><termref ref="dtimpl-RTO">RTO</termref></td><td>
            A quantity constructed as the quotient of a numerator
            quantity divided by a denominator quantity. Common
            factors in the numerator and denominator are not
            automatically cancelled out.  <emph>RTO</emph> supports titers
            (e.g., "1:128") and other quantities produced by
            laboratories that truly represent ratios. Ratios are
            not simply "structured numerics", particularly blood
            pressure measurements (e.g. "120/60") are not ratios.
            In many cases <termref ref="dtimpl-REAL">REAL</termref> should be used instead
            of <emph>RTO</emph>.
         </td></tr><tr><td>Point in Time</td><td><termref ref="dtimpl-TS">TS</termref></td><td>
            A quantity specifying a point on the axis of natural time.
            A point in time is most often represented as a calendar
            expression.
         </td></tr><tr><td>Set</td><td><termref ref="dtimpl-SET">SET</termref></td><td>
            A value that contains other distinct values in no particular order.
         </td></tr><tr><td>Set Component</td><td><termref ref="dtimpl-SXCM">SXCM</termref></td><td>
            An ITS-defined generic type extension for the base data
            type of a set, representing a component of a general set
            over a discrete or continuous value domain. Its use is
            mainly for continuous value domains. Discrete (enumerable)
            set components are the individual elements of the base
            data type.
         </td></tr><tr><td>Sequence</td><td><termref ref="dtimpl-LIST">LIST</termref></td><td>
            A value that contains other discrete values in a
            defined sequence.
         </td></tr><tr><td>Generated Sequence</td><td><termref ref="dtimpl-GLIST">GLIST</termref></td><td>
            A periodic or monotone sequence of values generated
            from a few parameters, rather than being enumerated.
            Used to specify regular sampling points for biosignals.
         </td></tr><tr><td>Sampled Sequence</td><td><termref ref="dtimpl-SLIST">SLIST</termref></td><td>
            A sequence of sampled values scaled and translated from a
            list of integer values.  Used to specify sampled biosignals.
         </td></tr><tr><td>Bag</td><td><termref ref="dtimpl-BAG">BAG</termref></td><td>
            An unordered collection of values, where each value can
            be contained more than once in the bag.
         </td></tr><tr><td>Bag Item</td><td><termref ref="dtimpl-BXIT">BXIT</termref></td><td>
            An ITS-defined generic data type extension that
            represents a collection of a certain number of identical
            items in a bag.
         </td></tr><tr><td>Interval</td><td><termref ref="dtimpl-IVL">IVL</termref></td><td>
            A set of consecutive values of an ordered base data type.
         </td></tr><tr><td>Interval Boundary</td><td><termref ref="dtimpl-IVXB">IVXB</termref></td><td>
            An ITS-defined generic type extension representing the
            boundary value for an interval.
         </td></tr><tr><td>History</td><td><termref ref="dtimpl-HIST">HIST</termref></td><td>
            A set of data values that conform to the history item
            (<termref ref="dtimpl-HXIT">HXIT</termref>) type, (i.e., that have a valid-time
            property). The history information is not limited to the
            past; expected future values can also appear.
         </td></tr><tr><td>History Item</td><td><termref ref="dtimpl-HXIT">HXIT</termref></td><td>
            A generic data type extension that tags a time range to
            any data value of any data type.  The time range is the
            time in which the information represented by the value
            is (was) valid.
         </td></tr><tr><td>Uncertain Value - Probabilistic</td><td><termref ref="dtimpl-UVP">UVP</termref></td><td>
            A generic data type extension used to specify a
            probability expressing the information producer's belief
            that the given value holds.
         </td></tr><tr><td>Non-Parametric Probability Distribution</td><td><termref ref="dtimpl-NPPD">NPPD</termref></td><td>
            A set of uncertain values with probabilities (also known
            as a histogram).
         </td></tr><tr><td>Periodic Interval of Time</td><td><termref ref="dtimpl-PIVL">PIVL</termref></td><td>
            An interval of time that recurs periodically. Periodic
            intervals have two properties, phase and period. The
            phase specifies the "interval prototype" that is repeated
            every period.
         </td></tr><tr><td>Event-Related Interval of Time</td><td><termref ref="dtimpl-EIVL">EIVL</termref></td><td>
            Specifies a periodic interval of time where the
            recurrence is based on activities of daily living
            or other important events that are time-related but
            not fully determined by time.
         </td></tr><tr><td>Parenthetic Set Expression</td><td><termref ref="dtimpl-SXPR">SXPR</termref></td><td>
            A set-component that is itself made up of set-components
            that are evaluated as one value.
         </td></tr><tr><td>Parametric Probability Distribution</td><td><termref ref="dtimpl-PPD">PPD</termref></td><td>
            A generic data type extension specifying uncertainty of
            quantitative data using a distribution function and its
            parameters. Aside from the specific parameters of the
            distribution, a mean (expected value) and standard
            deviation is always given to help maintain a minimum layer
            of interoperability if receiving applications cannot deal
            with a certain probability distribution.
         </td></tr><tr><td>General Timing Specification</td><td><termref ref="dtimpl-GTS">GTS</termref></td><td>
            A set of points in time, specifying the timing of events
            and actions and the cyclical validity-patterns that may
            exist for certain kinds of information, such as phone
            numbers (evening, daytime), addresses (so called
            "snowbirds," residing closer to the equator during winter
            and farther from the equator during summer) and office
            hours.
         </td></tr></tbody></table><p><emph role="strong">Element and Attibute Forms</emph></p><p>
               Data types may be represented in either an Element form or an abbreviated
               Attribute form. The context where the data type is used will define which
               form is to be used.
            </p><p>
               In the Element form, which is the normal case, the data type is represented
               using an XML elment. This is usually encountered for high-level
               HL7 content derived from the Reference Information Model (RIM).
            </p><p>
               In the abbreviated Attribute form, the data type is represented by a single
               XML attribute. This form is used when the data type is a property of other
               data types or when the data type is used in a Stuctutral RIM attribute.
               If an Attribute form is allowed, it is defined in the narrative.
            </p><p>
               Any data types represented in an Attribute form cannot convey any
               form of null flavor. If the attribute is not present in the XML instance
               then the data type has a null flavor of NI.
            </p></div2><div2 id="xmlrep"><head>Defining the XML Representation of Data Types</head><p>
               This standard specifies the XML representation for the
               HL7 data types. The XML representation is described in several
               different ways:
            </p><list role="unordered"><item>Narrative</item><item>Template</item></list><p><emph role="strong">XML Templates</emph></p><p>
               The XML Template format used in this document has been adapted
               from the format used in the W3C XML Schema specification.
            </p><exhibit role="template" verbatim="yes">
&lt;!-- type ED --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   representation = (B64 | TXT) : TXT
   language = CS
   mediaType = CS
   compression = CS
   integrityCheck = BIN
   integrityCheckAlgorithm = (SHA-1 | SHA-256) : SHA-1
   &gt;
  <emph>Content</emph>: ( reference, thumbnail, (#PCDATA | any) )
&lt;/x&gt;

&lt;!-- type EN --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   use = CS*
   &gt;
  <emph>Content</emph>: ( (delimiter | family | given | prefix | suffix)*, validTime )
&lt;/x&gt;
</exhibit><p>
               This example template shows the attributes and elements for the
               <termref ref="dtimpl-ED">ED</termref> and <termref ref="dtimpl-EN">EN</termref> types.
               The template describes a set of XML attributes and elements that may be used to
               represent the semantics of the data type described in the Data Types Abstract Specification.
               There may not be a direct mapping between the XML attributes and elements and
               the properties of the type described in the Data Types Abstract Specification. If the name of
               the XML attribute or element matches a property name in the Data Types Abstract Specification
               then the semantics of the content will be as described in the Data Types Abstract Specification,
               otherwise the narrative will explain the use of the attribute or element.
            </p><p>
               This specification describes types, not elements, so the element name
               for a given type is not known. The character x is used in place of
               the element name, which will be determined by the context in which the type
               is used, either in this specification, or the name of the RIM attribute.
            </p><p>
               For each attribute, the XML name of the attribute is shown, followed by
               either a set of possible values or a type name.  Allowed values are shown
               separated by vertical bars between parentheses. A default value, if applicable,
               is specified following a colon. If the attribute is assigned a type, then
               it is represented using the Attribute format described for the specified type.
               Some attributes are given the type <termref ref="dtimpl-CS">CS</termref>*. For these
               attributes, the valid content is a whitespace separated list of
               <termref ref="dtimpl-CS">CS</termref> codes.
            </p><p>
               For the element and text content, only the element names are shown. The type
               of the elements is described in the narrative associated with the type. The
               presence of a * denotes that the element or set of elements grouped by
               parentheses may appear more than once.
            </p><p>
               Some types may contain text data. This is represented using #PCDATA. Any
               text content must be properly escaped character content with no markup.
            </p><p>
               All attributes and elements are optional. If an attribute or
               element is not present, then the data type property it represents has the
               nullFlavor NI. Although all attributes and elements are optional, the datatype
               represented in the XML instance must be a valid instance of the datatype - it
               must meet all the constraints and specifications from the Data Types Abstract Specification.
            </p><p>
               The rules which determine which data types can be substituted for other
               data types are defined in the Data Types Abstract Specification.
            </p><p><emph role="strong">Validation against Schema and Predicates</emph></p><p>
               HL7 artefact processing systems are not required to validate any HL7
               XML data type representations against any schema or XPath predicates.
               Systems may wish to perform schema validation to gain access to
               the Post Schema Validation Instance
               [<loc href="http://www.w3.org/TR/xmlschema-1#key-psvi" xlink-form="simple" show="embed" actuate="auto"/>],
               but there will be no requirement to do this in order to properly understand the message,
               though all systems must be aware of the default values that are not represented
               in the instance by some means.
            </p><note><p>
                  All XML data type representations must conform to this
                  specification irrespective of whether validation by schema or any
                  other method is being performed.
               </p></note><note><p>
                  No existing technology for validating XML is able to completely
                  validate the HL7 data types as represented in XML.
               </p></note></div2><div2 id="namespaces"><head>Namespaces used in this document</head><table id="ITS-namespaces" border="1"><tr><td rowspan="1" colspan="1">xml</td><td rowspan="1" colspan="1">http://www.w3.org/XML/1998/namespace</td><td rowspan="1" colspan="1">xml namespace defined in Namespaces in XML<br/>
        			[<loc href="http://www.w3.org/TR/1999/REC-xml-names-19990114" xlink-form="simple" show="embed" actuate="auto"/>]</td></tr><tr><td rowspan="1" colspan="1">xs</td><td rowspan="1" colspan="1">http://www.w3.org/2001/XMLSchema</td><td rowspan="1" colspan="1">W3C Schema namespace defined in XML Schema Part 1: Structures<br/>
					  [<loc href="http://www.w3.org/TR/2001/REC-xmlschema-1-20010502" xlink-form="simple" show="embed" actuate="auto"/>]</td></tr><tr><td rowspan="1" colspan="1">xsi</td><td rowspan="1" colspan="1">http://www.w3.org/2001/XMLSchema-instance</td><td rowspan="1" colspan="1">W3C Schema namespace defined in XML Schema Part 1: Structures<br/>
					  [<loc href="http://www.w3.org/TR/2001/REC-xmlschema-1-20010502" xlink-form="simple" show="embed" actuate="auto"/>]</td></tr><tr><td rowspan="1" colspan="1">hl7</td><td rowspan="1" colspan="1">urn:hl7-org:v3</td><td rowspan="1" colspan="1">HL7 defined namespace for V3</td></tr></table></div2><div2 id="Use-of-attributes-from-XML-specifications"><head>Use of attributes from XML specifications</head><p>
               The W3C XML specifications define several attributes in w3c namespaces that
               carry particular meaning when processing XML documents. This section
               documents the usage for several such attributes. Other attributes not
               described in this section may be used but HL7 artefact processing systems
               are not required to attach any meaning to them beyond that required in the
               context of processing the XML containing the HL7 artefacts.
            </p><p><loc href="http://www.w3.org/TR/REC-xml" target="xml-rec" xlink-form="simple" show="embed" actuate="auto">xml:lang</loc>
               is not used. HL7 uses it's own attribute to convey the
               HL7 langauge property. This is done for several reasons.
               Many existing tools do not properly support
               xml:lang, and using <loc href="http://www.w3.org/TR/REC-xml" target="xml-rec" xlink-form="simple" show="embed" actuate="auto">xml:lang</loc>
               provides no useful outcomes. In addition, using a <termref ref="dtimpl-CS">CS</termref>
               instead of <loc href="http://www.w3.org/TR/REC-xml/#lang" target="xml-rec" xlink-form="simple" show="embed" actuate="auto">xml:lang</loc>
               provides clear support for the realm variation by international HL7
               affiliates. Note that at present, the codeset of <termref ref="comp-ED.language">language</termref>
               is identical to that of 
               <loc href="http://www.w3.org/TR/REC-xml" target="xml-rec" xlink-form="simple" show="embed" actuate="auto">xml:lang</loc>
               so it is possible to transform from one to the other.
            </p><p><loc href="http://www.w3.org/TR/xmlschema-1/#schemaLocation" xlink-form="simple" show="embed" actuate="auto">xsi:schemaLocation</loc>
               must not be used in an instance to point to a schema
               document to be used for validation. Instance processors
               are expected to provide their own schemas.
            </p><p><loc href="http://www.w3.org/TR/xmlschema-1/#type" xlink-form="simple" show="embed" actuate="auto">xsi:type</loc>
               is required when:
            </p><list role="unordered"><item>
                  The type of the RIM attribute is <termref ref="dtimpl-ANY">ANY</termref>,
                  <termref ref="dtimpl-RTO">RTO</termref>, or <termref ref="dtimpl-QTY">QTY</termref></item><item>
                  An instance of an <termref ref="dtimpl-SC">SC</termref> is being sent
                  as a promotion of an <termref ref="dtimpl-ST">ST</termref></item></list><p><loc href="http://www.w3.org/TR/xmlschema-1" xlink-form="simple" show="embed" actuate="auto">xsi:type</loc>
               may be used at other times according to the XML Schema specification.
            </p><p>
               When xsi:type is used to describe a data type defined in this specification,
               the correct type name is the value of the "Symbol" column for the type as given
               in <tabref ref="dtimpl-summary-table"/> in the hl7 namespace.
            </p><p>
               For generic types, the type names of the parameter types are appended to
               the generic type with an underscore between, so that an
               <termref ref="dtimpl-IVL">IVL</termref>&lt;<termref ref="dtimpl-TS">TS</termref>&gt; becomes IVL_TS.
               No ambiguities arise with this naming scheme due to the way that
               the data types have been defined.
            </p></div2></div1><div1 id="basic-types" ballotStatus="NormativeStandard"><head>Basic Data Types</head><div2 id="dtimpl-ANY"><head><anchor id="ANY"/>Data Value (ANY)</head><p><emph role="strong">Definition:     </emph>
            Defines the basic properties of every data value. This
            is an abstract type, meaning that no value can be just
            a data value without belonging to any concrete type.
            Every concrete type is a specialization of this
            general abstract DataValue type.
         </p><descriptive name="XML Representation"/><p><emph>ANY</emph> is an abstract datatype and may not be used directly; hence,
                  <emph>ANY</emph> has no XML representation.
               </p><!--
<schema id='schema-foo'>
<xs:element name='foo' type='ST'/>
</schema>
--><div3 id="comp-ANY.nullFlavor"><head>Null Flavor : <termref ref="dtimpl-CS">CS</termref></head><p><emph role="strong">Definition:     </emph>
               An exceptional value expressing missing information
               and possibly the reason why the information is missing.
            </p><p>
                  Every data element has either a proper value or it is considered
                  NULL. If and only if it is NULL, a "null flavor" provides more
                  detail as to in what way or why no proper value is supplied.
               </p><table id="domain-NullFlavor"><caption>Domain NullFlavor</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><td>NI</td><td>NoInformation</td><td>No information whatsoever can be inferred from this exceptional value.  This is the most general exceptional value.  It is also the default exceptional value.</td></tr><tr valign="top"><td>  OTH</td><td>other</td><td>The actual value is not an element in the value domain of a variable.  (e.g., concept not provided by required code system).</td></tr><tr valign="top"><td>    NINF</td><td>negative infinity</td><td>Negative infinity of numbers.</td></tr><tr valign="top"><td>    PINF</td><td>positive infinity</td><td>Positive infinity of numbers.</td></tr><tr valign="top"><td>  UNK</td><td>unknown</td><td>A proper value is applicable, but not known.</td></tr><tr valign="top"><td>    ASKU</td><td>asked but unknown</td><td>Information was sought but not found (e.g., patient was asked but didn't know)</td></tr><tr valign="top"><td>      NAV</td><td>temporarily unavailable</td><td>Information is not available at this time but it is expected that it will be available later.</td></tr><tr valign="top"><td>    NASK</td><td>not asked</td><td>This information has not been sought (e.g., patient was not asked)</td></tr><tr valign="top"><td>    TRC</td><td>trace</td><td>The content is greater than zero, but too small to be quantified.</td></tr><tr valign="top"><td>  MSK</td><td>masked</td><td>There is information on this item available but it has not been provided by the sender due to security, privacy or other reasons. There may be an alternate mechanism for gaining access to this information.Note: using this null flavor does provide information that may be a breach of confidentiality, even though no detail data is provided.  Its primary purpose is for those circumstances where it is necessary to inform the receiver that the information does exist without providing any detail.</td></tr><tr valign="top"><td>  NA</td><td>not applicable</td><td>No proper value is applicable in this context (e.g., last menstrual period for a male).</td></tr><tr valign="top"><td>NP</td><td>not present</td><td>Value is not present in a message.  This is only defined in messages, never in application data!  All values not present in the message must be replaced by the applicable default, or no-information (NI) as the default of all defaults.</td></tr></table><!--
                  <entry code="NI">
                     <entry code="NA"/>
                     <entry code="UNK" override="topology">
                        <entry code="NASK"/>
                        <entry code="TRC"/>
                        <entry code="ASKU" override="topology">
                           <entry code="NAV"/>
                        </entry>
                     </entry>
                     <entry code="OTH" override="topology">
                        <entry code="PINF"/>
                        <entry code="NINF"/>
                     </entry>
                  </entry>
                  <entry code="MSK"/>
                  <entry code="NP"/>
               </domain>
  --><descriptive name="XML Representation"/><p><emph>nullFlavor</emph> is represented by the XML attribute<emph>nullFlavor</emph>
                     whose value, if present, must be a valid value from the NullFlavor
                     domain (<tabref ref="domain-NullFlavor"/>).
                  </p></div3></div2><div2 id="dtimpl-BL"><head><anchor id="BL"/>Boolean (BL)</head><p><emph role="strong">Definition:     </emph>
            The Boolean type stands for the values of two-valued logic.
            A Boolean value can be either <emph>true</emph> or
            <emph>false</emph>, or, as any other value may be NULL.
         </p><p>
               All Boolean values obey the common operators negation, conjunction,
               and disjunction. With the NULL value these common Boolean operations
               are extended as shown in the following tables.
             </p><table id="BL-truth-tables" border="1" class="booleanTruthTable"><caption>Truth tables for Boolean logic with NULL values</caption><col width="0.4" span="1"/><col width="0.4" span="1"/><col width="0.4" span="1"/><col width="0.4" span="1"/><col width="0.4" span="1"/><col width="0.4" span="1"/><col width="0.4" span="1"/><col width="0.4" span="1"/><col width="0.4" span="1"/><col width="0.4" span="1"/><col width="0.4" span="1"/><col width="0.4" span="1"/><thead><tr><!-- NOT --><th rowspan="1" colspan="1">NOT</th><th rowspan="1" colspan="1"> </th><th rowspan="1" colspan="1"/><!-- AND --><th rowspan="1" colspan="1">AND</th><th rowspan="1" colspan="1">true</th><th rowspan="1" colspan="1">false</th><th rowspan="1" colspan="1">NULL</th><th rowspan="1" colspan="1"/><!-- OR  --><th rowspan="1" colspan="1">OR</th><th rowspan="1" colspan="1">true</th><th rowspan="1" colspan="1">false</th><th rowspan="1" colspan="1">NULL</th></tr></thead><tbody><tr><!-- NOT --><th rowspan="1" colspan="1">true</th><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1"/><!-- AND --><th rowspan="1" colspan="1">true</th><td rowspan="1" colspan="1">true</td><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">NULL</td><td rowspan="1" colspan="1"/><!-- OR  --><th rowspan="1" colspan="1">true</th><td rowspan="1" colspan="1">true</td><td rowspan="1" colspan="1">true</td><td rowspan="1" colspan="1">true</td></tr><tr><!-- NOT --><th rowspan="1" colspan="1">false</th><td rowspan="1" colspan="1">true</td><td rowspan="1" colspan="1"/><!-- AND --><th rowspan="1" colspan="1">false</th><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1"/><!-- OR  --><th rowspan="1" colspan="1">false</th><td rowspan="1" colspan="1">true</td><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">NULL</td></tr><tr><!-- NOT --><th rowspan="1" colspan="1">NULL</th><td rowspan="1" colspan="1">NULL</td><td rowspan="1" colspan="1"/><!-- AND --><th rowspan="1" colspan="1">NULL</th><td rowspan="1" colspan="1">NULL</td><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">NULL</td><td rowspan="1" colspan="1"/><!-- OR  --><th rowspan="1" colspan="1">NULL</th><td rowspan="1" colspan="1">true</td><td rowspan="1" colspan="1">NULL</td><td rowspan="1" colspan="1">NULL</td></tr></tbody></table><descriptive name="XML Representation"/><p><emph>BL</emph> is represented by both Element and Attribute forms.
                  In the Element form, the name of the element is determined by the
                  context in which it is used. The element has attributes as described
                  in the template and the sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type BL --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   value = (true | false)
   /&gt;
</exhibit><p>
XML instances may carry either a nullFlavor or a value, but not both.
</p><p>
                  The Attribute form of <emph>BL</emph> is used when properties of other data types
                  have type <emph>BL</emph>.  The name of the attribute is determined by the context
                  in which it is used. The attribute must have the value <emph>true</emph> 
                  or <emph>false</emph>.
               </p><div3 id="BL-examples"><head>Examples</head><p>
                  The first example shows true and false negation and context conduction indicators.
               </p><exhibit role="example" verbatim="yes">
&lt;negationInd value='true'/&gt;
&lt;contextConductionInd value='false'/&gt;</exhibit><p>
                  The second example shows the use of true and false
                  inclusive interval boundaries.
               </p><exhibit role="example" verbatim="yes">
&lt;effectiveTime&gt;
   &lt;low value='20020101' inclusive='true'/&gt;
   &lt;high value='20040101' inclusive='false'/&gt;
&lt;/effectiveTime&gt;</exhibit></div3></div2><div2 id="dtimpl-BN"><head><anchor id="BN"/>BooleanNonNull (BN)</head><p><emph role="strong">Definition:     </emph>
            The BooleanNonNull type is used where a Boolean cannot
            have a null value. A Boolean value can be either
            <emph>true</emph> or <emph>false</emph>.
         </p><descriptive name="XML Representation"/><p><emph>BN</emph> is represented by both Element and Attribute
                  forms. In the Element form, the name of the element is determined
                  by the context in which it is used. The element has attributes as
                  described in the template and the sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type BN --&gt;
&lt;x
   value = (true | false)
   /&gt;
</exhibit><p>
XML instances must carry a value.
</p><p>
                  The Attribute form of <emph>BN</emph> is used when properties of other data types
                  have type <emph>BN</emph>.  The name of the attribute is determined by the context
                  in which it is used and whose value is either <emph>true</emph> or
                  <emph>false</emph>. Unless the value has a default property the
                  attribute must be present.
               </p></div2><!-- ** BINARY DATA ****************************** --><div2 id="dtimpl-BIN"><head><anchor id="BIN"/>Binary Data (BIN)</head><p><emph role="strong">Definition:     </emph>
            Binary data is a raw block of bits. Binary data is a
            protected type that MUST not be used outside the data
            type specification.
         </p><table id="dtimpl-BIN-comp-summary"><caption>Components of
      Binary Data</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">data</termref></td><td>XML Text Content</td><td>
               The data itself represented in the XML instance encoding
               according to the binary data representation element (text
               or base64 form.) ST and types that specialize ST use only
               the text representation.
            </td></tr><tr><td><termref ref="">representation</termref></td><td><termref ref="dtimpl-CS">CS</termref></td><td>
                     Specifies the representation of the binary data that
                     is the content of the binary data value.
                  </td></tr></tbody></table><descriptive name="XML Representation"/><p><emph>BIN</emph> is represented by both Element and Attribute
                  forms. The Element form serves as the basis of the encapsulated
                  data type, used for both written text and multimedia (binary data).
                  When an element is defined to be of type <emph/> that property is
                  represented as the character data (e.g., #PCDATA) content of the
                  element in question.
               </p><p>
                  The Attribute form of <emph>BIN</emph> is used when properties of other
                  data types have type <emph>BIN</emph> (e.g., <termref ref="comp-ED.integrityCheck">ED.integrityCheck</termref>).
                  The name of the XML attribute is determined by the name of the
                  property in question.  The value of the XML attribute must be the
                  base64 encoding [<loc href="http://www.ietf.org/rfc/rfc2045.txt" xlink-form="simple" show="embed" actuate="auto"/>]
                  of the binary data.
               </p><div3 id="comp-BIN.data"><head>Data : XML Text Content</head><p><emph role="strong">Definition:     </emph>
               The data itself represented in the XML instance encoding
               according to the binary data representation element (text
               or base64 form.) ST and types that specialize ST use only
               the text representation.
            </p><descriptive name="XML Representation"/><p><emph>data</emph> is represented as the text content of the
                     XML element representing the <emph>BIN</emph> value, whose value, if
                     present must be the base64 encoding of the actual value.
                  </p></div3><div3 id="comp-BIN.representation"><head>Representation : <termref ref="dtimpl-CS">CS</termref></head><p><emph role="strong">Definition:     </emph>
                     Specifies the representation of the binary data that
                     is the content of the binary data value.
                  </p><p>
                  BIN in the Data Types Abstract Specification does not have a representation property since,
                  for HL7's purposes, representation is not a meaningful property of data.
                  Therefore applications need not retain the representation.
               </p><descriptive name="XML Representation"/><p><emph>representation</emph> is represented by the XML attribute<emph>representation</emph>
                     whose value, if present, must be <emph>TXT</emph> or <emph>B64</emph>.
                     The default value is <emph>TXT</emph>.
                  </p><p><emph>TXT</emph> indicates that the character data of the
                     <emph>BIN</emph> is to be interpreted directly
                     as characters; <emph>B64</emph> indicates that the
                     <emph>BIN</emph> data has been base64 encoded
                     and must be decoded in order to recover the original data.
                  </p></div3></div2><!-- ** ENC DATA ******************************** --><div2 id="dtimpl-ED"><head><anchor id="ED"/>Encapsulated Data (ED) specializes <termref ref="dtimpl-BIN">BIN</termref></head><p><emph role="strong">Definition:     </emph>
            Data that is primarily intended for human interpretation
            or for further machine processing is outside the scope of
            HL7. This includes unformatted or formatted written language,
            multimedia data, or structured information as defined by a
            different standard (e.g., XML-signatures.)  Instead of the
            data itself, an <termref ref="dtimpl-ED">ED</termref> may contain 
            only a reference (see <termref ref="dtimpl-TEL">TEL</termref>.) Note
            that the <termref ref="dtimpl-ST">ST</termref> data type is a
            specialization of <emph>ED</emph>
            when the <termref ref="comp-ED.mediaType">mediaType</termref> is <emph>text/plain</emph>.
         </p><table id="dtimpl-ED-comp-summary"><caption>Components of
      Encapsulated Data</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="comp-ED.data">data</termref></td><td>XML Text Content</td><td>
               The data itself represented in the XML instance encoding
               according to the binary data representation element (text
               or base64 form.) ST and types that specialize ST use only
               the text representation.
            </td></tr><tr><td><termref ref="comp-ED.representation">representation</termref></td><td><termref ref="dtimpl-CS">CS</termref></td><td>
                     Specifies the representation of the binary data that
                     is the content of the binary data value.
                  </td></tr><tr><td><termref ref="">mediaType</termref></td><td><termref ref="dtimpl-CS">CS</termref></td><td>
                     Identifies the type of the encapsulated data and
                     identifies a method to interpret or render the data.
                  </td></tr><tr><td><termref ref="">charset</termref></td><td><termref ref="dtimpl-CS">CS</termref></td><td>
                  For character-based encoding types, this property
                  specifies the character set and character encoding
                  used. The charset shall be identified by an Internet
                  Assigned Numbers Authority (IANA) Charset Registration
                  [<loc href="http://www.iana.org/assignments/character-sets" xlink-form="simple" show="embed" actuate="auto"/>] 
                  in accordance with RFC 2978
                  [<loc href="http://www.ietf.org/rfc/rfc2978.txt" xlink-form="simple" show="embed" actuate="auto"/>].
               </td></tr><tr><td><termref ref="">language</termref></td><td><termref ref="dtimpl-CS">CS</termref></td><td>
                     For character based information the language property
                     specifies the human language of the text.
                  </td></tr><tr><td><termref ref="">compression</termref></td><td><termref ref="dtimpl-CS">CS</termref></td><td>
                     Indicates whether the raw byte data is compressed,
                     and what compression algorithm was used.
                  </td></tr><tr><td><termref ref="">reference</termref></td><td><termref ref="dtimpl-TEL">TEL</termref></td><td>
                        A telecommunication address (<termref ref="dtimpl-TEL">TEL</termref>), such as a <termref ref="dtimpl-URL">URL</termref>
                        for HTTP or FTP, which will resolve to precisely
                        the same binary data that could as well have been
                        provided as inline data.
                     </td></tr><tr><td><termref ref="">integrityCheck</termref></td><td><termref ref="dtimpl-BIN">BIN</termref></td><td>
                     The integrity check is a short binary value representing
                     a cryptographically strong checksum that is calculated
                     over the binary data. The purpose of this property, when
                     communicated with a reference is for anyone to validate
                     later whether the reference still resolved to the same
                     data that the reference resolved to when the encapsulated
                     data value with reference was created.
                  </td></tr><tr><td><termref ref="">integrityCheckAlgorithm</termref></td><td><termref ref="dtimpl-CS">CS</termref></td><td>
                     Specifies the algorithm used to compute the
                     integrityCheck value.
                  </td></tr><tr><td><termref ref="">thumbnail</termref></td><td><termref ref="dtimpl-ED">ED</termref></td><td>
                     A thumbnail is an abbreviated rendition of the full
                     data. A thumbnail requires significantly fewer
                     resources than the full data, while still maintaining
                     some distinctive similarity with the full data. A
                     thumbnail is typically used with by-reference
                     encapsulated data. It allows a user to select data
                     more efficiently before actually downloading through
                     the reference.
                  </td></tr></tbody></table><p>
               Encapsulated data can be present in one of two forms, inline
               or by reference. Inline data is communicated or moved as part
               of the encapsulated data value, whereas by-reference data may
               reside at a different (remote) location. The data is the same
               whether it is located inline or remote.
            </p><descriptive name="XML Representation"/><exhibit role="template" verbatim="yes">
&lt;!-- type ED --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   representation = (B64 | TXT) : TXT
   language = CS
   mediaType = CS
   compression = CS
   integrityCheck = BIN
   integrityCheckAlgorithm = (SHA-1 | SHA-256) : SHA-1
   &gt;
   <emph>Content</emph>: ( reference, thumbnail, (#PCDATA | any) )
&lt;/x&gt;
</exhibit><p><emph>ED</emph> is always represented in Element form as
                  described in the template and sub-sections below. The binary
                  data is conveyed as inline character content. Alternatively
                  addition ED can contain the data as XML markup. In these cases
                  the mediaType is expected to describe some form of XML markup,
                  and the content must be
                  <loc href="http://www.w3.org/TR/REC-xml/#dt-wellformed" target="xml-rec" xlink-form="simple" show="embed" actuate="auto">well-formed</loc>
                  XML contained in a single element in the ED content. If the
                  in-line content is HTML or SGML, it must be 
                  <loc href="http://www.w3.org/TR/REC-xml/#dt-wellformed" target="xml-rec" xlink-form="simple" show="embed" actuate="auto">well-formed</loc>
                  XML or it must be represented as escaped or base64 encoded
                  character content.
               </p><p>
                  Markup contained in an <emph>ED</emph> can come from any namespace other
                  than the HL7 V3 namespace (urn:hl7-org:v3) without restriction.
                  Additionally, any element in the HL7 namespace that represents
                  an interaction or the root of a CDA document may also appear.
                  The reason for this restriction on elements from the HL7 namespace
                  is to help support those who choose to do optional XML Schema
                  processing.  It would not be possible to write a schema definition
                  that would allow arbitrary content from the HL7 namespace since
                  that would result in a violation of
                  <loc href="http://www.w3.org/TR/xmlschema-1/#cos-nonambig" target="schema-rec" xlink-form="simple" show="embed" actuate="auto">
                  Schema Component Constraint: Unique Particle Attribution</loc>.
               </p><p>
                  Because inline data for <emph>ED</emph> (and its restricted form,
                  <termref ref="dtimpl-ST">ST</termref>) may be encoded as character
                  data, and the content model also includes a thumbnail and
                  reference element, <emph>ED</emph> has
                  <loc href="http://www.w3.org/TR/REC-xml/#sec-mixed-content" target="xml-rec" xlink-form="simple" show="embed" actuate="auto">mixed content</loc>.
                  An instance of <emph>ED</emph> may only contain at most one text node.
               </p><div3 id="comp-ED.data"><head><anchor id=""/>Data : XML Text Content (inherited from <termref ref="dtimpl-BIN">BIN</termref>)</head><p><emph role="strong">Definition:     </emph>
               The data itself represented in the XML instance encoding
               according to the binary data representation element (text
               or base64 form.) ST and types that specialize ST use only
               the text representation.
            </p></div3><descriptive name="XML Representation"/><p><emph>data</emph> is represented as the text content of the
                     XML element representing the <emph>ED</emph> value.
                  </p><div3 id="comp-ED.representation"><head><anchor id=""/>Representation : <termref ref="dtimpl-CS">CS</termref> (inherited from <termref ref="dtimpl-BIN">BIN</termref>)</head><p><emph role="strong">Definition:     </emph>
                     Specifies the representation of the binary data that
                     is the content of the binary data value.
                  </p></div3><descriptive name="XML Representation"/><p><emph>representation</emph> is represented by the XML attribute<emph>representation</emph>
                     whose value must either <emph>TXT</emph> or <emph>B64</emph>.
                  </p><div3 id="comp-ED.mediaType"><head>Media Type : <termref ref="dtimpl-CS">CS</termref></head><p><emph role="strong">Definition:     </emph>
                     Identifies the type of the encapsulated data and
                     identifies a method to interpret or render the data.
                  </p><p>
                  The IANA defined domain of media types is established by
                  the Internet standard RFC 2046
                  [<loc href="http://www.ietf.org/rfc/rfc2046.txt" xlink-form="simple" show="embed" actuate="auto"/>].
               </p><p>
                  To promote interoperability, this specification prefers certain
                  media types to others. This is to define a greatest common
                  denominator on which interoperability is not only possible, but
                  that is powerful enough to support even advanced multimedia
                  communication needs.
               </p><p><tabref ref="domain-MediaType"/>  below assigns a status to
                  certain MIME media types, where the status means one of the following:
               </p><!-- FIXME: this should be a definition list dl-dt-dd kind of thing --><p><emph role="strong">required</emph>: Every HL7 application must support
                  at least the required media types if it supports a given kind
                  of media. One required media-type for each kind of media exists.
                  Some media types are required for a specific purpose, which is
                  then indicated as "required for ..."
               </p><p><emph role="strong">recommended</emph>: Other media types are recommended
                  for a particular purpose. For any given purpose there should be
                  only very few additionally recommended media types and the rationale,
                  conditions and assumptions of such recommendations must be made
                  very clear.
               </p><p><emph role="strong">indifferent</emph>: This status means, HL7 does neither
                  forbid nor endorse the use of this media type. All media types not
                  mentioned here by default belong into the indifferent category. Since
                  there is one required and several recommended media types for most
                  practically relevant use cases, media types of this status should be
                  used very conservatively.
               </p><p><emph role="strong">deprecated</emph>: Deprecated media types should not be
                  used, because these media types are flawed, because there are better
                  alternatives, or because of certain risks. Such risks could be
                  security risks, for example, the risk that such a media type could
                  spread computer viruses. Not every flawed media type is marked as
                  deprecated, though. A media type that is not mentioned, and thus
                  considered other by default, may well be flawed.
               </p><table id="domain-MediaType"><caption>Domain MediaType</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>status</th><th>definition</th></tr></thead><tbody><tr valign="top"><td>text/plain </td><td>Plain Text </td><td>required </td><td>For any plain text.  This is the default and is equivalent to a character string (ST) data type. </td></tr><tr valign="top"><td>text/html </td><td>HTML Text </td><td>recommended </td><td>For marked-up text according to the Hypertext Mark-up Language.  HTML markup is sufficient for typographically marking-up most written-text documents.  HTML is platform independent and widely deployed. </td></tr><tr valign="top"><td>text/x-hl7-ft </td><td>HL7 Text </td><td>recommended </td><td>For compatibility, this represents the HL7 v2.x FT data type.  Its use is recommended only for backward compatibility with HL7 v2.x systems. </td></tr><tr valign="top"><td>text/xml </td><td>XML Text </td><td>indifferent </td><td>For structured character based data.  There is a risk that general SGML/XML is too powerful to allow a sharing of general SGML/XML documents between different applications. </td></tr><tr valign="top"><td>text/rtf </td><td>RTF Text </td><td>indifferent </td><td>The Rich Text Format is widely used to share word-processor documents.  However, RTF does have compatibility problems, as it is quite dependent on the word processor.  May be useful if word processor edit-able text should be shared. </td></tr><tr valign="top"><td>text/sgml </td><td>SGML Text </td><td>indifferent </td><td>For structured character based data.  There is a risk that general SGML/XML is too powerful to allow a sharing of general SGML/XML documents between different applications. </td></tr><tr valign="top"><td>image/png </td><td>PNG Image </td><td>required </td><td>Portable Network Graphics (PNG) [http://www.cdrom.com/pub/png] is a widely supported lossless image compression standard with open source code available. </td></tr><tr valign="top"><td>image/jpeg </td><td>JPEG Image </td><td>required </td><td>This format is required for high compression of high color photographs.  It is a "lossy" compression, but the difference to lossless compression is almost unnoticeable to the human vision. </td></tr><tr valign="top"><td>image/g3fax </td><td>G3Fax Image </td><td>recommended </td><td>This is recommended only for fax applications. </td></tr><tr valign="top"><td>image/gif </td><td>GIF Image </td><td>indifferent </td><td>GIF is a popular format that is universally well supported. However GIF is patent encumbered and should therefore be used with caution. </td></tr><tr valign="top"><td>image/tiff </td><td>TIFF Image </td><td>indifferent </td><td>Although TIFF (Tag Image File Format) is an international standard it has many interoperability problems in practice.  Too many different versions that are not handled by all software alike. </td></tr><tr valign="top"><td>audio/basic </td><td>Basic Audio </td><td>required </td><td>This is a format for single channel audio, encoded using 8bit ISDN mu-law [PCM] at a sample rate of 8000 Hz.  This format is standardized by: CCITT, Fascicle III.4 -Recommendation G.711.  Pulse Code Modulation (PCM) of Voice Frequencies.  Geneva, 1972. </td></tr><tr valign="top"><td>audio/mpeg </td><td>MPEG audio layer 3 </td><td>required </td><td>MPEG-1 Audio layer-3 is an audio compression algorithm and file format                       defined in ISO 11172-3 and ISO 13818-3. MP3 has an adjustable sampling frequency for highly compressed telephone to CD quality audio. </td></tr><tr valign="top"><td>audio/k32adpcm </td><td>K32ADPCM Audio </td><td>indifferent </td><td>ADPCM allows compressing audio data.  It is defined in the Internet specification RFC 2421 [ftp://ftp.isi.edu/in-notes/rfc2421.txt].  Its implementation base is unclear. </td></tr><tr valign="top"><td>video/mpeg </td><td>MPEG Video </td><td>required </td><td>MPEG is an international standard, widely deployed, highly efficient for high color video; open source code exists; highly interoperable. </td></tr><tr valign="top"><td>video/x-avi </td><td>X-AVI Video </td><td>deprecated </td><td>The AVI file format is just a wrapper for many different codecs; it is a source of many interoperability problems. </td></tr><tr valign="top"><td>model/vrml </td><td>VRML Model </td><td>recommended </td><td>This is an openly standardized format for 3D models that can be useful for virtual reality applications such as anatomy or biochemical research (visualization of the steric structure of macromolecules) </td></tr><tr valign="top"><td>application/pdf </td><td>PDF </td><td>recommended </td><td>The Portable Document Format is recommended for written text that is completely laid out and read-only.  PDF is a platform independent, widely deployed, and open specification with freely available creation and rendering tools. </td></tr><tr valign="top"><td>application/dicom </td><td>DICOM </td><td>recommended </td><td>Digital Imaging and Communications in Medicine (DICOM) MIME type defined in RFC3240 [http://ietf.org/rfc/rfc3240.txt]. </td></tr><tr valign="top"><td>application/msword </td><td>MSWORD </td><td>deprecated </td><td>This format is very prone to compatibility problems.  If sharing of edit-able text is required, text/plain, text/html or text/rtf should be used instead. </td></tr><tr valign="top"><td>multipart/x-hl7-cda-level1 </td><td>CDA Level 1 Multipart </td><td>recommended </td><td>The HL7 clinical document Architecture, Level 1 MIME package. </td></tr></tbody></table><p>
                  The set of required media types is very small so that no undue
                  requirements are forced on HL7 applications, especially legacy
                  systems. In general, no HL7 application is forced to support any given
                  kind of media other than written text. For example, many systems just
                  do not want to receive audio data, because those systems can only show
                  written text to their users. It is a matter of application conformance
                  statements to say: "I will not handle audio". Only if a system claims
                  to handle audio media, it must support the required media type for
                  audio.
               </p><descriptive name="XML Representation"/><p><emph>mediaType</emph> is represented by the XML attribute<emph>mediaType</emph>
                     whose value, if present, must be a valid mediaType as specified
                     by the Internet standard RFC 2046
                     [<loc href="http://www.ietf.org/rfc/rfc2046.txt" xlink-form="simple" show="embed" actuate="auto"/>]. The default
                     value is <emph>text/plain</emph>.
                  </p></div3><!-- CHARSET --><div3 id="comp-ED.charset"><head>Charset : <termref ref="dtimpl-CS">CS</termref></head><p><emph role="strong">Definition:     </emph>
                  For character-based encoding types, this property
                  specifies the character set and character encoding
                  used. The charset shall be identified by an Internet
                  Assigned Numbers Authority (IANA) Charset Registration
                  [<loc href="http://www.iana.org/assignments/character-sets" xlink-form="simple" show="embed" actuate="auto"/>] 
                  in accordance with RFC 2978
                  [<loc href="http://www.ietf.org/rfc/rfc2978.txt" xlink-form="simple" show="embed" actuate="auto"/>].
               </p><descriptive name="XML Representation"/><p><emph>charset</emph> is not explicitly represented in the XML ITS.
                     Rather, the value of charset is to be inferred from the encoding
                     used in the
                     <loc href="http://www.w3.org/TR/REC-xml/#dt-entity" target="xml-rec" xlink-form="simple" show="embed" actuate="auto">XML entity</loc>
                     in which the <emph>ED</emph> value is contained.
                  </p></div3><!-- LANGUAGE --><div3 id="comp-ED.language"><head>Language : <termref ref="dtimpl-CS">CS</termref></head><p><emph role="strong">Definition:     </emph>
                     For character based information the language property
                     specifies the human language of the text.
                  </p><p>
                  The HL7 table for human languages is based on RFC 3066, Tags
                  for the Identification of Languages
                  [<loc href="http://www.ietf.org/rfc/rfc3066.txt" xlink-form="simple" show="embed" actuate="auto"/>]. It is a
                  set of pre-coordinated pairs of one 2-letter ISO 639 language code
                  and one 2-letter ISO 3166 country code (e.g., en-us [English,
                  United States]).
               </p><p>
                  Language tags do not modify the meaning of the characters found
                  in the text; they are only an advice on if and how to present
                  or communicate the text. For this reason, any system or site that
                  does not deal with multilingual text or names in the real world
                  can safely ignore the language property.
               </p><descriptive name="XML Representation"/><p><emph>language</emph> is represented by the XML attribute<emph>language</emph>
                     whose value, if present, must be a valid language tag as
                     defined by RFC 3066
                     [<loc href="http://www.ietf.org/rfc/rfc3066.txt" target="rfcs" xlink-form="simple" show="embed" actuate="auto"/>].
                  </p></div3><!-- COMPRESSION --><div3 id="comp-ED.compression"><head>Compression : <termref ref="dtimpl-CS">CS</termref></head><p><emph role="strong">Definition:     </emph>
                     Indicates whether the raw byte data is compressed,
                     and what compression algorithm was used.
                  </p><table id="domain-CompressionAlgorithm"><caption>Domain CompressionAlgorithm</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>status</th><th>definition</th></tr></thead><tbody><tr valign="top"><td>DF </td><td>deflate </td><td>required </td><td>The deflate compressed data format as specified in RFC 1951 [http://www.ietf.org/rfc/rfc1951.txt]. </td></tr><tr valign="top"><td>GZ </td><td>gzip </td><td>indifferent </td><td>A compressed data format that is compatible with the widely used GZIP utility as specified in RFC 1952 [http://www.ietf.org/rfc/rfc1952.txt] (uses the deflate algorithm). </td></tr><tr valign="top"><td>ZL </td><td>zlib </td><td>indifferent </td><td>A compressed data format that also uses the deflate algorithm.  Specified as RFC 1950 [http://www.ietf.org/rfc/rfc1952.txt] </td></tr><tr valign="top"><td>Z </td><td>compress </td><td>deprecated </td><td>Original UNIX compress algorithm and file format using the LZC algorithm (a variant of LZW).  Patent encumbered and less efficient than deflate. </td></tr></tbody></table><descriptive name="XML Representation"/><p><emph>compression</emph> is represented as the XML attribute<emph>compression</emph>
                     whose value, if present, must be a valid value from the
                     CompressionAlgorithm domain (<tabref ref="domain-CompressionAlgorithm"/>).
                     There is no compression by default.
                  </p></div3><!-- REFERENCE --><div3 id="comp-ED.reference"><head>Reference : <termref ref="dtimpl-TEL">TEL</termref></head><p><emph role="strong">Definition:     </emph>
                        A telecommunication address (<termref ref="dtimpl-TEL">TEL</termref>), such as a <termref ref="dtimpl-URL">URL</termref>
                        for HTTP or FTP, which will resolve to precisely
                        the same binary data that could as well have been
                        provided as inline data.
                     </p><p>
                  The semantic value of an encapsulated data value is the same,
                  regardless whether the data is present inline data or just
                  by-reference. However, an encapsulated data value without
                  inline data behaves differently, since any attempt to examine
                  the data requires the data to be downloaded from the reference.
               </p><p>
                  An encapsulated data value may have both inline data and a
                  reference. The reference must point to the same data as provided
                  inline.
               </p><descriptive name="XML Representation"/><p><emph>reference</emph> is represented as the XML element<emph>reference</emph>
                     which, if present, must be a valid <termref ref="dtimpl-TEL">TEL</termref>.
                  </p></div3><!-- INTEGRITY CHECK --><div3 id="comp-ED.integrityCheck"><head>Integrity Check : <termref ref="dtimpl-BIN">BIN</termref></head><p><emph role="strong">Definition:     </emph>
                     The integrity check is a short binary value representing
                     a cryptographically strong checksum that is calculated
                     over the binary data. The purpose of this property, when
                     communicated with a reference is for anyone to validate
                     later whether the reference still resolved to the same
                     data that the reference resolved to when the encapsulated
                     data value with reference was created.
                  </p><p>
                  The integrity check is calculated according to the integrity
                  check algorithm. By default, the Secure Hash Algorithm-1
                  (<emph>SHA-1</emph>) shall be used. The integrity check is
                  binary encoded according to the rules of the integrity check
                  algorithm.
               </p><p>
                  The integrity check is calculated over the raw binary data that
                  is contained in the data component, or that is accessible through
                  the reference. No transformations are made before the integrity
                  check is calculated. If the data is compressed, the Integrity
                  Check is calculated over the compressed data.
               </p><descriptive name="XML Representation"/><p><emph>integrityCheck</emph> is represented by the XML attribute<emph>integrityCheck</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-BIN">BIN</termref>.
                     There is no default value.
                  </p><p>
                     When generating instances, applications must base64 encode the
                     integrity check prior to populating the XML attribute<emph>integrityCheck</emph>.
                     When receiving instances, applications must base64 decode the value
                     of the XML attribute<emph>integrityCheck</emph> to obtain the integrity check
                     value.
                  </p></div3><!-- INTEGRITY CHECK ALGORITHM --><div3 id="comp-ED.integrityCheckAlgorithm"><head>Integrity Check Algorithm : <termref ref="dtimpl-CS">CS</termref></head><p><emph role="strong">Definition:     </emph>
                     Specifies the algorithm used to compute the
                     integrityCheck value.
                  </p><!-- FIXME: needs harmonization action table="IntegrityCheckAlgorithm"/ --><table id="domain-IntegrityCheckAlgorithm"><caption>Domain IntegrityCheckAlgorithm</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><td>SHA-1</td><td>secure hash algorithm - 1</td><td>This algorithm is defined in FIPS PUB 180-1: Secure Hash Standard.  As of April 17, 1995.</td></tr><tr valign="top"><td>SHA-256</td><td>secure hash algorithm - 256</td><td>This algorithm is defined in FIPS PUB 180-2: Secure Hash Standard.</td></tr></table><descriptive name="XML Representation"/><p><emph>integrityCheckAlgorithm</emph> is represented by the
                     XML attribute<emph>integrityCheckAlgorithm</emph> whose value must be a
                     valid value from the IntegrityCheckAlgorithm domain
                     (<tabref ref="domain-IntegrityCheckAlgorithm"/>).
                     The default value is <emph>SHA-1</emph>.
                  </p></div3><!-- THUMBNAIL --><div3 id="comp-ED.thumbnail"><head>Thumbnail : <termref ref="dtimpl-ED">ED</termref></head><p><emph role="strong">Definition:     </emph>
                     A thumbnail is an abbreviated rendition of the full
                     data. A thumbnail requires significantly fewer
                     resources than the full data, while still maintaining
                     some distinctive similarity with the full data. A
                     thumbnail is typically used with by-reference
                     encapsulated data. It allows a user to select data
                     more efficiently before actually downloading through
                     the reference.
                  </p><p>
                  For example, a large image may be represented by a small image;
                  a high quality audio sequence by a shorter low-quality audio; a
                  movie may be represented by a shorter clip (or just an image);
                  text may be summarized to an abstract.
               </p><p>
                  A thumbnail may not itself contain a thumbnail.
               </p><descriptive name="XML Representation"/><p><emph>thumbnail</emph> is represented as the XML element<emph>thumbnail</emph>
                     which, if present, is a restricted form of
                     <emph>ED</emph> that does not allow
                     <emph>thumbnail</emph> children.
                  </p><exhibit role="template" verbatim="yes">
&lt;!-- internal type Thumbnail --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   representation = (B64 | TXT) : TXT
   language = CS
   mediaType = CS
   compression = CS
   integrityCheck = BIN
   integrityCheckAlgorithm = (SHA-1 | SHA-256) : SHA-1
   &gt;
   <emph>Content</emph>: ( reference, (#PCDATA | any) )
&lt;/x&gt;
</exhibit></div3><div3 id="ED-examples"><head>Examples</head><p>
                  The first example shows an Adobe Acrobat document that has been
                  compressed using the GZip compression algorithm.
               </p><exhibit role="example" verbatim="yes">
&lt;text mediaType='application/pdf' representation='B64' compression='GZ'&gt;
   omSJUEdmde9j44zmMiromSJUEdmde9j44zmMirdMDSsWdIJdksIJR3373jeu83
   6edjzMMIjdMDSsWdIJdksIJR3373jeu83MNYD83jmMdomSJUEdmde9j44zmMir
   ...
   MNYD83jmMdomSJUEdmde9j44zmMir6edjzMMIjdMDSsWdIJdksIJR3373jeu83
   4zmMir6edjzMMIjdMDSsWdIJdksIJR3373jeu83==
&lt;/text&gt;</exhibit><p>
                  The next example contains a reference to an image,
                  stored at particular <termref ref="dtimpl-URL">URL</termref> and available
                  for the next month. An integrity check is provided for the image,
                  as well as in inline thumbnail.
               </p><exhibit role="example" verbatim="yes">
&lt;text mediaType='image/png' representation='B64'
      integrityCheck='aA5mb7c8TXtu392KMsaSa2MKkAwL5LKAo2d99azAs3MdUdw'&gt;
   &lt;reference value='http://example.org/xrays/128s8d9ej229se32s.png'&gt;
      &lt;useablePeriod xsi:type='IVL_TS'&gt;
         &lt;low value='200007200845'/&gt;
         &lt;high value='200008200845'/&gt;
      &lt;/useablePeriod&gt;
   &lt;/reference&gt;
   &lt;thumbnail mediaType='image/jpeg' representation='B64'&gt;
      MNYD83jmMdomSJUEdmde9j44zmMir6edjzMMIjdMDSsWdIJdksIJR3373jeu83
      6edjzMMIjdMDSsWdIJdksIJR3373jeu83MNYD83jmMdomSJUEdmde9j44zmMir
      ...
      omSJUEdmde9j44zmMiromSJUEdmde9j44zmMirdMDSsWdIJdksIJR3373jeu83
      4zmMir6edjzMMIjdMDSsWdIJdksIJR3373jeu83==
   &lt;/thumbnail&gt;
&lt;/text&gt;</exhibit></div3></div2><!-- ** CHARACTER STRING **************************** --><div2 id="dtimpl-ST"><head><anchor id="ST"/>Character String (ST) specializes <termref ref="dtimpl-ED">ED</termref></head><p><emph role="strong">Definition:     </emph>
            The character string data type stands for text data,
            primarily intended for machine processing (e.g.,
            sorting, querying, indexing, etc.) Used for names,
            symbols, and formal expressions.
         </p><table id="dtimpl-ST-comp-summary"><caption>Components of
      Character String</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="comp-ST.data">data</termref></td><td>XML Text Content</td><td>
                     The data itself represented in the XML instance encoding.
                  </td></tr><tr><td><termref ref="comp-ST.representation">representation</termref></td><td><termref ref="dtimpl-CS">CS</termref></td><td>
                     Specifies the representation of the binary data that
                     is the content of the binary data value.
                  </td></tr><tr><td><termref ref="comp-ST.mediaType">mediaType</termref></td><td><termref ref="dtimpl-CS">CS</termref></td><td>
                     Identifies the type of the encapsulated data and
                     identifies a method to interpret or render the data.
                  </td></tr><tr><td><termref ref="comp-ST.charset">charset</termref></td><td><termref ref="dtimpl-CS">CS</termref></td><td>
                  For character-based encoding types, this property
                  specifies the character set and character encoding
                  used. The charset shall be identified by an Internet
                  Assigned Numbers Authority (IANA) Charset Registration
                  [<loc href="http://www.iana.org/assignments/character-sets" xlink-form="simple" show="embed" actuate="auto"/>] 
                  in accordance with RFC 2978
                  [<loc href="http://www.ietf.org/rfc/rfc2978.txt" xlink-form="simple" show="embed" actuate="auto"/>].
               </td></tr><tr><td><termref ref="comp-ST.language">language</termref></td><td><termref ref="dtimpl-CS">CS</termref></td><td>
                     For character based information the language property
                     specifies the human language of the text.
                  </td></tr></tbody></table><p>
               A character string must at least have one character or else
               it is NULL. The length of a string is the number of characters,
               not the number of encoded bytes. 
            </p><!--FIXME: no need to mention length if length isn't used or defined. --><p><emph>ST</emph>
               interprets the encapsulated data as character data (as opposed
               to bits), depending on the charset property. In other words,
               the string S1 "Rose" is equal to the string S2 "Rose" even if
               S1 is ASCII encoded (hex '526f7365') and S2 is EBCDIC encoded
               (hex 'd996a285') or UTF-16 encoded (hex '0052006f00730065').
            </p><descriptive name="XML Representation"/><p><emph>ST</emph> is represented by both Element and Attribute
                  forms. In the Element form, the name of the XML element is
                  determined by the context in which it is used. The element
                  has attributes as described in the template and sub-sections
                  below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type ST --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   representation = (TXT) : TXT
   mediaType = (text/plain) : text/plain
   language = CS
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/x&gt;
</exhibit><p>
                  The Attribute form of <emph>ST</emph> is used when properties of other
                  data types have type <emph>ST</emph>.  The name of the attribute is
                  determined by the context in which it is used. The value
                  of the attribute is the content of the string.
               </p><div3 id="comp-ST.data"><head><anchor id=""/>Data : XML Text Content (inherited from <termref ref="dtimpl-BIN">BIN</termref>)</head></div3><p><emph role="strong">Definition:     </emph>
                     The data itself represented in the XML instance encoding.
                  </p><descriptive name="XML Representation"/><p><emph>data</emph> is represented as the text content of the
                     XML element representing the <emph>ST</emph> value.
                  </p><div3 id="comp-ST.representation"><head><anchor id=""/>Representation : <termref ref="dtimpl-CS">CS</termref> (inherited from <termref ref="dtimpl-BIN">BIN</termref>)</head><p><emph role="strong">Definition:     </emph>
                     Specifies the representation of the binary data that
                     is the content of the binary data value.
                  </p></div3><!-- pvb standard-fixed-attr/--><descriptive name="XML Representation"/><p><emph>representation</emph> is represented by the XML attribute<emph>representation</emph>
                     whose value, if present, must be <emph>TXT</emph>.
                     Since the representation always has a fixed value,
                     it is not normally present in the XML instance.
                  </p><div3 id="comp-ST.mediaType"><head><anchor id=""/>Media Type : <termref ref="dtimpl-CS">CS</termref> (inherited from <termref ref="dtimpl-ED">ED</termref>)</head><p><emph role="strong">Definition:     </emph>
                     Identifies the type of the encapsulated data and
                     identifies a method to interpret or render the data.
                  </p></div3><!-- pvb standard-fixed-attr/--><descriptive name="XML Representation"/><p><emph>mediaType</emph> is represented by the XML attribute<emph>mediaType</emph>
                     whose value, if present, must be <emph>text/plain</emph>.
                     Since the media type always has a fixed value, it is
                     not normally present in the XML instance.
                  </p><!-- CHARSET --><div3 id="comp-ST.charset"><head><anchor id=""/>Charset : <termref ref="dtimpl-CS">CS</termref> (inherited from <termref ref="dtimpl-ED">ED</termref>)</head><p><emph role="strong">Definition:     </emph>
                  For character-based encoding types, this property
                  specifies the character set and character encoding
                  used. The charset shall be identified by an Internet
                  Assigned Numbers Authority (IANA) Charset Registration
                  [<loc href="http://www.iana.org/assignments/character-sets" xlink-form="simple" show="embed" actuate="auto"/>] 
                  in accordance with RFC 2978
                  [<loc href="http://www.ietf.org/rfc/rfc2978.txt" xlink-form="simple" show="embed" actuate="auto"/>].
               </p></div3><descriptive name="XML Representation"/><p><emph>charset</emph> is not explicitly represented in the XML ITS.
                     Rather, the value of charset is to be inferred from the
                     encoding used in the
                     <loc href="http://www.w3.org/TR/REC-xml/#dt-entity" target="xml-rec" xlink-form="simple" show="embed" actuate="auto">XML entity</loc>
                     in which the <termref ref="dtimpl-ST">ST</termref> value is contained.
                  </p><div3 id="comp-ST.language"><head><anchor id=""/>Language : <termref ref="dtimpl-CS">CS</termref> (inherited from <termref ref="dtimpl-ED">ED</termref>)</head><p><emph role="strong">Definition:     </emph>
                     For character based information the language property
                     specifies the human language of the text.
                  </p></div3><descriptive name="XML Representation"/><p><emph>language</emph> is represented by the XML attribute<emph>language</emph>
                     whose value, if present, must be a valid language tag as
                     defined by RFC 3066
                     [<loc href="http://www.ietf.org/rfc/rfc3066.txt" target="rfcs" xlink-form="simple" show="embed" actuate="auto"/>].
                  </p><div3 id="comp-ST.compression"><head><anchor id=""/>Compression : <termref ref="dtimpl-CS">CS</termref> (fixed)</head><p><emph role="strong">Definition:     </emph>
                     Indicates whether the raw byte data is compressed,
                     and what compression algorithm was used.
                  </p></div3><descriptive name="XML Representation"/><p><emph>compression</emph> is inherited from an ancestor data type
				but does not appear in the XML representation of this data type.</p><div3 id="comp-ST.reference"><head><anchor id=""/>Reference : <termref ref="dtimpl-TEL">TEL</termref> (fixed)</head><p><emph role="strong">Definition:     </emph>
                        A telecommunication address (<termref ref="dtimpl-TEL">TEL</termref>), such as a <termref ref="dtimpl-URL">URL</termref>
                        for HTTP or FTP, which will resolve to precisely
                        the same binary data that could as well have been
                        provided as inline data.
                     </p></div3><descriptive name="XML Representation"/><p><emph>reference</emph> is inherited from an ancestor data type
				but does not appear in the XML representation of this data type.</p><div3 id="comp-ST.integrityCheck"><head><anchor id=""/>Integrity Check : <termref ref="dtimpl-BIN">BIN</termref> (fixed)</head><p><emph role="strong">Definition:     </emph>
                     The integrity check is a short binary value representing
                     a cryptographically strong checksum that is calculated
                     over the binary data. The purpose of this property, when
                     communicated with a reference is for anyone to validate
                     later whether the reference still resolved to the same
                     data that the reference resolved to when the encapsulated
                     data value with reference was created.
                  </p></div3><descriptive name="XML Representation"/><p><emph>integrityCheck</emph> is inherited from an ancestor data type
				but does not appear in the XML representation of this data type.</p><div3 id="comp-ST.integrityCheckAlgorithm"><head><anchor id=""/>Integrity Check Algorithm : <termref ref="dtimpl-CS">CS</termref> (fixed)</head><p><emph role="strong">Definition:     </emph>
                     Specifies the algorithm used to compute the
                     integrityCheck value.
                  </p></div3><descriptive name="XML Representation"/><p><emph>integrityCheckAlgorithm</emph> is inherited from an ancestor data type
				but does not appear in the XML representation of this data type.</p><div3 id="comp-ST.thumbnail"><head><anchor id=""/>Thumbnail : <termref ref="dtimpl-ED">ED</termref> (fixed)</head><p><emph role="strong">Definition:     </emph>
                     A thumbnail is an abbreviated rendition of the full
                     data. A thumbnail requires significantly fewer
                     resources than the full data, while still maintaining
                     some distinctive similarity with the full data. A
                     thumbnail is typically used with by-reference
                     encapsulated data. It allows a user to select data
                     more efficiently before actually downloading through
                     the reference.
                  </p></div3><descriptive name="XML Representation"/><p><emph>thumbnail</emph> is inherited from an ancestor data type
				but does not appear in the XML representation of this data type.</p><div3 id="ST-examples"><head>Examples</head><p>
                  This example shows a simple case of a character string
                  for Act.text.
               </p><exhibit role="example" verbatim="yes">
&lt;text language='en'&gt;cellulitis of the left foot&lt;/text&gt;</exhibit></div3></div2><!-- *** CODED DATA TYPES ********************************
Because it was seen as more intuitive by many, I will roll
this presentation up from CS to CD. However, the XML
schema will do the exact same thing as the semantics
specification: it goes from CD and restricts down to
CS. To me, the fact that XML schema works exactly the
same way is a validation of the V3DT semantics way of
doing it. Let them complain :-).
--><!-- *** CS *************** --><div2 id="dtimpl-CS"><head><anchor id="CS"/>Coded Simple Value (CS) specializes <termref ref="dtimpl-CV">CV</termref></head><p><emph role="strong">Definition:     </emph>
            Coded data in its simplest form, consists of a code.
            The code system and code system version is fixed by 
            the context in which the <emph>CS</emph> value occurs. <emph>CS</emph> is used
            for coded attributes that have a single HL7-defined
            value set.
         </p><table id="dtimpl-CS-comp-summary"><caption>Components of
      Coded Simple Value</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="comp-CS.code">code</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     The plain code symbol defined by the code system.
                     For example, "784.0" is the code symbol of the ICD-9
                     code "784.0" for headache.
                  </td></tr></tbody></table><descriptive name="XML Representation"/><p><emph>CS</emph> is represented by both Element and
                  Attribute forms. In the Element form, the type is
                  represented by an XML element whose name is determined
                  by the context in which it is used. The code value is
                  represented by an XML attribute<emph>code</emph>, whose value,
                  if present, must be a valid
                  <loc href="http://www.w3.org/TR/xmlschema-2/#token" target="schema-rec" xlink-form="simple" show="embed" actuate="auto">xs:token</loc>
                  with no internal whitespace.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type CS --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   code = ST
   /&gt;
</exhibit><p>
                  In the Attribute form, <termref ref="comp-CS.code">code</termref> is represented as
                  an XML attribute whose name is determined by the context in
                  which it is used, and whose value, if present, must be a valid
                  <loc href="http://www.w3.org/TR/xmlschema-2/#token" target="schema-rec" xlink-form="simple" show="embed" actuate="auto">xs:token</loc>
                  with no internal whitespace.
               </p><div3 id="comp-CS.code"><head><anchor id=""/>Code : <termref ref="dtimpl-ST">ST</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     The plain code symbol defined by the code system.
                     For example, "784.0" is the code symbol of the ICD-9
                     code "784.0" for headache.
                  </p></div3><descriptive name="XML Representation"/><p><emph>code</emph> is represented by the XML attribute<emph>code</emph>
                     whose value, if present, must be a valid
                     <loc href="http://www.w3.org/TR/xmlschema-2/#token" target="schema-rec" xlink-form="simple" show="embed" actuate="auto">xs:token</loc>
                     with no internal whitespace.
                  </p><div3 id="comp-CS.codeSystem"><head><anchor id=""/>Code System : UID (fixed)</head><p><emph role="strong">Definition:     </emph>
                     Specifies the code system that defines the code.
                  </p></div3><descriptive name="XML Representation"/><p><emph>codeSystem</emph> is inherited from an ancestor data type
				but does not appear in the XML representation of this data type.</p><p>
                     The fact that a sending system is prohibited from specifying
                     a code system for an <emph>CS</emph> data value should not be misconstrued
                     as if such codes would not have any code system. Rather, the
                     code system in <emph>CS</emph> values is <emph>fixed by the context</emph>.
                     That context is defined by the model in which <emph>CS</emph> is used.
                  </p><div3 id="comp-CS.codeSystemName"><head><anchor id=""/>Code System Name : <termref ref="dtimpl-ST">ST</termref> (fixed)</head><p><emph role="strong">Definition:     </emph>
                     A common name of the coding system.
                  </p></div3><descriptive name="XML Representation"/><p><emph>codeSystemName</emph> is inherited from an ancestor data type
				but does not appear in the XML representation of this data type.</p><div3 id="comp-CS.codeSystemVersion"><head><anchor id=""/>Code System Version : <termref ref="dtimpl-ST">ST</termref> (fixed)</head><p><emph role="strong">Definition:     </emph>
                     If applicable, a version descriptor defined
                     specifically for the given code system.
                  </p></div3><descriptive name="XML Representation"/><p><emph>codeSystemVersion</emph> is inherited from an ancestor data type
				but does not appear in the XML representation of this data type.</p><div3 id="comp-CS.displayName"><head><anchor id=""/>Display Name : <termref ref="dtimpl-ST">ST</termref> (fixed)</head><p><emph role="strong">Definition:     </emph>
                     A name or title for the code, under which the sending
                     system shows the code value to its users.
                  </p></div3><descriptive name="XML Representation"/><p><emph>displayName</emph> is inherited from an ancestor data type
				but does not appear in the XML representation of this data type.</p><div3 id="comp-CS.originalText"><head><anchor id=""/>Original Text : <termref ref="dtimpl-ED">ED</termref> (fixed)</head><p><emph role="strong">Definition:     </emph>
                        The text or phrase used as the basis for the coding.
                     </p></div3><descriptive name="XML Representation"/><p><emph>originalText</emph> is inherited from an ancestor data type
				but does not appear in the XML representation of this data type.</p><!--
                  <schema id="schema-CS.originalText" include="false">
                     <xs:element name="originalText" type="ED" minOccurs="0" maxOccurs="0"/>
                  </schema>
  --><div3 id="CS-examples"><head>Examples</head><p>
                  This example shows a US realmCode.
               </p><exhibit role="example" verbatim="yes">
&lt;realmCode code='US'/&gt;</exhibit><p>
                  This example shows a ControlAct with a classCode of <code>CACT</code>
                  and a moodCode of <code>EVN</code>, both of which are <emph>CS</emph>.
               </p><exhibit role="example" verbatim="yes">
&lt;controlActProcess classCode='CACT' moodCode='EVN'&gt;
   ...
&lt;/controlActProcess&gt;</exhibit></div3></div2><!-- *** CV *************** --><div2 id="dtimpl-CV"><head><anchor id="CV"/>Coded Value (CV) specializes <termref ref="dtimpl-CE">CE</termref></head><p><emph role="strong">Definition:     </emph>
            Coded data, consists of a code, display name, code system,
            and original text. Used when a single code value must be sent.
         </p><table id="dtimpl-CV-comp-summary"><caption>Components of
      Coded Value</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="comp-CV.code">code</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     The plain code symbol defined by the code system.
                     For example, "784.0" is the code symbol of the ICD-9
                     code "784.0" for headache.
                  </td></tr><tr><td><termref ref="comp-CV.codeSystem">codeSystem</termref></td><td>UID</td><td>
                     Specifies the code system that defines the code.
                  </td></tr><tr><td><termref ref="comp-CV.codeSystemName">codeSystemName</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     A common name of the coding system.
                  </td></tr><tr><td><termref ref="comp-CV.codeSystemVersion">codeSystemVersion</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     If applicable, a version descriptor defined
                     specifically for the given code system.
                  </td></tr><tr><td><termref ref="comp-CV.displayName">displayName</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     A name or title for the code, under which the sending
                     system shows the code value to its users.
                  </td></tr><tr><td><termref ref="comp-CV.originalText">originalText</termref></td><td><termref ref="dtimpl-ED">ED</termref></td><td>
                        The text or phrase used as the basis for the coding.
                     </td></tr></tbody></table><descriptive name="XML Representation"/><p><emph>CV</emph> is always represented in Element form
                  as described in the template and sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type CV --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   code = ST
   codeSystem = UID
   codeSystemName = ST
   codeSystemVersion = ST
   displayName = ST
   &gt;
   <emph>Content</emph>: ( originalText )
&lt;/x&gt;
</exhibit><div3 id="comp-CV.code"><head><anchor id=""/>Code : <termref ref="dtimpl-ST">ST</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     The plain code symbol defined by the code system.
                     For example, "784.0" is the code symbol of the ICD-9
                     code "784.0" for headache.
                  </p></div3><descriptive name="XML Representation"/><p><emph>code</emph> is represented by the XML attribute<emph>code</emph>
                     whose value, if present, must be a valid
                     <loc href="http://www.w3.org/TR/xmlschema-2/#token" target="schema-rec" xlink-form="simple" show="embed" actuate="auto">xs:token</loc>
                     with no internal whitespace.
                  </p><div3 id="comp-CV.codeSystem"><head><anchor id=""/>Code System : UID (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     Specifies the code system that defines the code.
                  </p></div3><descriptive name="XML Representation"/><p><emph>codeSystem</emph> is represented by the XML attribute<emph>codeSystem</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-UID">UID</termref>.
                  </p><div3 id="comp-CV.codeSystemName"><head><anchor id=""/>Code System Name : <termref ref="dtimpl-ST">ST</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     A common name of the coding system.
                  </p></div3><descriptive name="XML Representation"/><p><emph>codeSystemName</emph> is represented by the XML attribute<emph>codeSystemName</emph>
                     whose value, if present, must be a valid
                     <termref ref="dtimpl-ST">ST</termref>.
                  </p><div3 id="comp-CV.codeSystemVersion"><head><anchor id=""/>Code System Version : <termref ref="dtimpl-ST">ST</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     If applicable, a version descriptor defined
                     specifically for the given code system.
                  </p></div3><descriptive name="XML Representation"/><p><emph>codeSystemVersion</emph> is represented by the XML attribute<emph>codeSystemVersion</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-ST">ST</termref>.
                  </p><div3 id="comp-CV.displayName"><head><anchor id=""/>Display Name : <termref ref="dtimpl-ST">ST</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     A name or title for the code, under which the sending
                     system shows the code value to its users.
                  </p></div3><descriptive name="XML Representation"/><p><emph>displayName</emph> is represented by the XML attribute<emph>displayName</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-ST">ST</termref>.
                  </p><div3 id="comp-CV.originalText"><head><anchor id=""/>Original Text : <termref ref="dtimpl-ED">ED</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                        The text or phrase used as the basis for the coding.
                     </p></div3><descriptive name="XML Representation"/><p><emph>originalText</emph> is represented by the XML element<emph>originalText</emph>
                     which, if present, must be a valid <termref ref="dtimpl-ED">ED</termref>.
                  </p><div3 id="comp-CV.translation"><head><anchor id=""/>Translation : SET&lt;CD&gt; (fixed)</head><p><emph role="strong">Definition:     </emph>
                        A set of other concept descriptors that translate
                        this concept descriptor into other code systems.
                     </p></div3><descriptive name="XML Representation"/><p><emph>translation</emph> is inherited from an ancestor data type
				but does not appear in the XML representation of this data type.</p><div3 id="CV-examples"><head>Examples</head><p>
                  The first example shows the LOINC code for <code>"consultation note"</code>.
               </p><exhibit role="example" verbatim="yes">
&lt;code code='11488-4' codeSystem='2.16.840.1.113883.19.6.1' codeSystemName='LOINC'
   displayName='Consultation note'/&gt;</exhibit><p>
                  The second example shows a SNOMED-CT code with
                  <termref ref="comp-CD.originalText">CD.originalText</termref> for
                  "osteoarthritis of the right knee".
               </p><exhibit role="example" verbatim="yes">
&lt;code code='396275006' codeSystem='2.16.840.1.113883.19.6.96'
      codeSystemName='SNOMED CT' displayName='Osteoarthritis'&gt;
   &lt;originalText&gt;osteoarthritis of the right knee&lt;/originalText&gt;
&lt;/code&gt;</exhibit><p>
                  The final example shows the use of nullFlavor='OTHER' to
                  indicate that a code does not exist in a coding system.
               </p><exhibit role="example" verbatim="yes">
&lt;code codeSystem='2.16.840.1.113883.19.6.96'
      codeSystemName='SNOMED CT' nullFlavor='OTH'&gt;
   &lt;originalText&gt;normal cardiac silhouette&lt;/originalText&gt;
&lt;/code&gt;</exhibit></div3></div2><!-- *** CO *************** --><div2 id="dtimpl-CO"><head><anchor id="CO"/>Coded Ordinal (CO) specializes <termref ref="dtimpl-CV">CV</termref></head><p><emph role="strong">Definition:     </emph>
            Coded data, where the domain from which the codeset comes
            is ordered. The Coded Ordinal data type adds semantics
            related to ordering so that models that make use of such
            domains may introduce model elements that involve statements
            about the order of the terms in a domain. 
         </p><table id="dtimpl-CO-comp-summary"><caption>Components of
      Coded Ordinal</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="comp-C0.code">code</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     The plain code symbol defined by the code system.
                     For example, "784.0" is the code symbol of the ICD-9
                     code "784.0" for headache.
                  </td></tr><tr><td><termref ref="comp-C0.codeSystem">codeSystem</termref></td><td>UID</td><td>
                     Specifies the code system that defines the code.
                  </td></tr><tr><td><termref ref="comp-C0.codeSystemName">codeSystemName</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     A common name of the coding system.
                  </td></tr><tr><td><termref ref="comp-C0.codeSystemVersion">codeSystemVersion</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     If applicable, a version descriptor defined
                     specifically for the given code system.
                  </td></tr><tr><td><termref ref="comp-C0.displayName">displayName</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     A name or title for the code, under which the sending
                     system shows the code value to its users.
                  </td></tr><tr><td><termref ref="comp-C0.originalText">originalText</termref></td><td><termref ref="dtimpl-ED">ED</termref></td><td>
                        The text or phrase used as the basis for the coding.
                     </td></tr></tbody></table><descriptive name="XML Representation"/><p><emph>CO</emph> is always represented in Element form as
                  described in the template and sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type CO --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   code = ST
   codeSystem = UID
   codeSystemName = ST
   codeSystemVersion = ST
   displayName = ST
   &gt;
   <emph>Content</emph>: ( originalText )
&lt;/x&gt;
</exhibit><div3 id="comp-C0.code"><head><anchor id=""/>Code : <termref ref="dtimpl-ST">ST</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     The plain code symbol defined by the code system.
                     For example, "784.0" is the code symbol of the ICD-9
                     code "784.0" for headache.
                  </p></div3><descriptive name="XML Representation"/><p><emph>code</emph> is represented by the XML attribute<emph>code</emph>
                     whose value, if present, must be a valid
                     <loc href="http://www.w3.org/TR/xmlschema-2/#token" target="schema-rec" xlink-form="simple" show="embed" actuate="auto">xs:token</loc>
                     with no internal whitespace.
                  </p><div3 id="comp-C0.codeSystem"><head><anchor id=""/>Code System : UID (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     Specifies the code system that defines the code.
                  </p></div3><descriptive name="XML Representation"/><p><emph>codeSystem</emph> is represented by the XML attribute<emph>codeSystem</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-UID">UID</termref>.
                  </p><div3 id="comp-C0.codeSystemName"><head><anchor id=""/>Code System Name : <termref ref="dtimpl-ST">ST</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     A common name of the coding system.
                  </p></div3><descriptive name="XML Representation"/><p><emph>codeSystemName</emph> is represented by the XML attribute<emph>codeSystemName</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-ST">ST</termref>.
										</p><div3 id="comp-C0.codeSystemVersion"><head><anchor id=""/>Code System Version : <termref ref="dtimpl-ST">ST</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     If applicable, a version descriptor defined
                     specifically for the given code system.
                  </p></div3><descriptive name="XML Representation"/><p><emph>codeSystemVersion</emph> is represented by the XML attribute<emph>codeSystemVersion</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-ST">ST</termref>.
                  </p><div3 id="comp-C0.displayName"><head><anchor id=""/>Display Name : <termref ref="dtimpl-ST">ST</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     A name or title for the code, under which the sending
                     system shows the code value to its users.
                  </p></div3><descriptive name="XML Representation"/><p><emph>displayName</emph> is represented by the XML attribute<emph>displayName</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-ST">ST</termref>.
                  </p><div3 id="comp-C0.originalText"><head><anchor id=""/>Original Text : <termref ref="dtimpl-ED">ED</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                        The text or phrase used as the basis for the coding.
                     </p></div3><descriptive name="XML Representation"/><p><emph>originalText</emph> is represented by the XML element<emph>originalText</emph>
                     which, if present, must be a valid <termref ref="dtimpl-ED">ED</termref>.
                  </p><div3 id="comp-C0.translation"><head><anchor id=""/>Translation : SET&lt;CD&gt; (fixed)</head><p><emph role="strong">Definition:     </emph>
                        A set of other concept descriptors that translate
                        this concept descriptor into other code systems.
                     </p></div3><descriptive name="XML Representation"/><p><emph>translation</emph> is inherited from an ancestor data type
				but does not appear in the XML representation of this data type.</p></div2><!-- *** CE ******************** --><div2 id="dtimpl-CE"><head><anchor id="CE"/>Coded with Equivalents (CE) specializes <termref ref="dtimpl-CD">CD</termref></head><p><emph role="strong">Definition:     </emph>
            Coded data, consists of a coded value (<termref ref="dtimpl-CV">CV</termref>)
            and, optionally, coded value(s) from other coding systems
            that identify the same concept. Used when alternative
            codes may exist.
         </p><table id="dtimpl-CE-comp-summary"><caption>Components of
      Coded with Equivalents</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="comp-CE.code">code</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     The plain code symbol defined by the code system.
                     For example, "784.0" is the code symbol of the ICD-9
                     code "784.0" for headache.
                  </td></tr><tr><td><termref ref="comp-CE.codeSystem">codeSystem</termref></td><td>UID</td><td>
                     Specifies the code system that defines the code.
                  </td></tr><tr><td><termref ref="comp-CE.codeSystemName">codeSystemName</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     A common name of the coding system.
                  </td></tr><tr><td><termref ref="comp-CE.codeSystemVersion">codeSystemVersion</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     If applicable, a version descriptor defined
                     specifically for the given code system.
                  </td></tr><tr><td><termref ref="comp-CE.displayName">displayName</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     A name or title for the code, under which the sending
                     system shows the code value to its users.
                  </td></tr><tr><td><termref ref="comp-CE.originalText">originalText</termref></td><td><termref ref="dtimpl-ED">ED</termref></td><td>
                        The text or phrase used as the basis for the coding.
                     </td></tr><tr><td><termref ref="comp-CE.translation">translation</termref></td><td>SET&lt;CD&gt;</td><td>
                        A set of other concept descriptors that translate
                        this concept descriptor into other code systems.
                     </td></tr></tbody></table><descriptive name="XML Representation"/><p><emph>CE</emph> is always represented in Element form as
                  described in the template and sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type CE --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   code = ST
   codeSystem = UID
   codeSystemName = ST
   codeSystemVersion = ST
   displayName = ST
   &gt;
   <emph>Content</emph>: ( originalText, translation* )
&lt;/x&gt;
</exhibit><div3 id="comp-CE.code"><head><anchor id=""/>Code : <termref ref="dtimpl-ST">ST</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     The plain code symbol defined by the code system.
                     For example, "784.0" is the code symbol of the ICD-9
                     code "784.0" for headache.
                  </p></div3><descriptive name="XML Representation"/><p><emph>code</emph> is represented by the XML attribute<emph>code</emph> whose value,
                     if present, must be a valid
                     <loc href="http://www.w3.org/TR/xmlschema-2/#token" target="schema-rec" xlink-form="simple" show="embed" actuate="auto">xs:token</loc>
                     with no internal whitespace.
                  </p><div3 id="comp-CE.codeSystem"><head><anchor id=""/>Code System : UID (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     Specifies the code system that defines the code.
                  </p></div3><descriptive name="XML Representation"/><p><emph>codeSystem</emph> is represented by the XML attribute<emph>codeSystem</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-UID">UID</termref>.
                  </p><div3 id="comp-CE.codeSystemName"><head><anchor id=""/>Code System Name : <termref ref="dtimpl-ST">ST</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     A common name of the coding system.
                  </p></div3><descriptive name="XML Representation"/><p><emph>codeSystemName</emph> is represented by the XML attribute<emph>codeSystemName</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-ST">ST</termref>.
                  </p><div3 id="comp-CE.codeSystemVersion"><head><anchor id=""/>Code System Version : <termref ref="dtimpl-ST">ST</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     If applicable, a version descriptor defined
                     specifically for the given code system.
                  </p></div3><descriptive name="XML Representation"/><p><emph>codeSystemVersion</emph> is represented by the XML attribute<emph>codeSystemVersion</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-ST">ST</termref>.
                  </p><div3 id="comp-CE.displayName"><head><anchor id=""/>Display Name : <termref ref="dtimpl-ST">ST</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     A name or title for the code, under which the sending
                     system shows the code value to its users.
                  </p></div3><descriptive name="XML Representation"/><p><emph>displayName</emph> is represented by the XML attribute<emph>displayName</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-ST">ST</termref>.
                  </p><div3 id="comp-CE.qualifier"><head><anchor id=""/>Qualifier : LIST&lt;CR&gt; (fixed)</head><p><emph role="strong">Definition:     </emph>
                        Specifies additional codes that increase the
                        specificity of the primary code.
                     </p></div3><descriptive name="XML Representation"/><p><emph>qualifier</emph> is inherited from an ancestor data type
				but does not appear in the XML representation of this data type.</p><div3 id="comp-CE.originalText"><head><anchor id=""/>Original Text : <termref ref="dtimpl-ED">ED</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                        The text or phrase used as the basis for the coding.
                     </p></div3><descriptive name="XML Representation"/><p><emph>originalText</emph> is represented by the XML element<emph>originalText</emph>
                     which, if present, must be a valid <termref ref="dtimpl-ED">ED</termref>.
                  </p><div3 id="comp-CE.translation"><head><anchor id=""/>Translation : SET&lt;CD&gt; (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                        A set of other concept descriptors that translate
                        this concept descriptor into other code systems.
                     </p></div3><descriptive name="XML Representation"/><p><emph>translation</emph> is represented by 0 or more
                     XML elements<emph>translation</emph> each of which must be
                     a valid <termref ref="dtimpl-CD">CD</termref>.
                  </p><div3 id="CE-examples"><head>Examples</head><p>
                  This example shows an observation whose
                  value is the SNOMED-CT code for <code>"asthma"</code>
                  as well as a <termref ref="comp-CE.translation">translation</termref>
                  of that code in ICD9CM.
               </p><exhibit role="example" verbatim="yes">
&lt;code code='195967001' codeSystem='2.16.840.1.113883.19.6.96'
      codeSystemName='SNOMED CT' displayName='Asthma'&gt;
   &lt;translation code='49390' codeSystem='2.16.840.1.113883.19.6.2'
      codeSystemName='ICD9CM' displayName='ASTHMA W/O STATUS ASTHMATICUS'/&gt;
&lt;/code&gt;</exhibit><p>
					For additional examples see <specref ref="CV-examples"/>.
				</p></div3></div2><!-- *** CD ******************** --><div2 id="dtimpl-CD"><head><anchor id="CD"/>Concept Descriptor (CD)</head><p><emph role="strong">Definition:     </emph>
            A concept descriptor represents any kind of concept usually
            by giving a code defined in a code system.  A concept
            descriptor can contain the original text or phrase that
            served as the basis of the coding and one or more
            translations into different coding systems. A concept
            descriptor can also contain qualifiers to describe, e.g.,
            the concept of a "left foot" as a postcoordinated term built
            from the primary code "FOOT" and the qualifier "LEFT".
            In exceptional cases, the concept descriptor need not
            contain a code but only the original text describing
            that concept.
         </p><table id="dtimpl-CD-comp-summary"><caption>Components of
      Concept Descriptor</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">code</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     The plain code symbol defined by the code system.
                     For example, "784.0" is the code symbol of the ICD-9
                     code "784.0" for headache.
                  </td></tr><tr><td><termref ref="">codeSystem</termref></td><td>UID</td><td>
                     Specifies the code system that defines the code.
                  </td></tr><tr><td><termref ref="">codeSystemName</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     A common name of the coding system.
                  </td></tr><tr><td><termref ref="">codeSystemVersion</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     If applicable, a version descriptor defined
                     specifically for the given code system.
                  </td></tr><tr><td><termref ref="">displayName</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     A name or title for the code, under which the sending
                     system shows the code value to its users.
                  </td></tr><tr><td><termref ref="">originalText</termref></td><td><termref ref="dtimpl-ED">ED</termref></td><td>
                        The text or phrase used as the basis for the coding.
                     </td></tr><tr><td><termref ref="">qualifier</termref></td><td>LIST&lt;CR&gt;</td><td>
                        Specifies additional codes that increase the
                        specificity of the primary code.
                     </td></tr><tr><td><termref ref="">translation</termref></td><td>SET&lt;CD&gt;</td><td>
                        A set of other concept descriptors that translate
                        this concept descriptor into other code systems.
                     </td></tr></tbody></table><!--
GDG Nov 2003. Why is this commented out?
div3>
<head>Concept Codes vs. Instance Identifiers</head>
<p>
A concept is a class of things or ideas. Concepts are frequently
represented by codes. Diagnosis, procedures, and specialties are
examples of concepts. The CD refers to a concept usually by citing a
code defined in a coding system.
</p>

<p>
A major distinction exists between codes and instance
identifiers. Codes are values that stand for classes or properties of
things (sometimes referred to as "universals".) For example, "F150" is
a code referring to a class of Ford pickup trucks. There are thousands
of F150's on the road, all of which are classified as full-size Ford
pickup trucks.
</p>

<p>
Instance identifiers on the other hand refer to individual
things. Individual things are instances of concepts and concepts may
have individual things as instances. But instances <emph>are
not</emph> concepts and concepts <emph>are not</emph> instances. Every
individual Ford F150 has a unique Vehicle Identification Number (VIN),
an identifier that refers to an individual truck.
</p>

<p>
Diagnosis codes, procedure codes, medication codes, gender, marital
status and religion codes are examples of, as their name implies,
codes. Medical record numbers, Social Security Numbers, Provider IDs,
and Manufacturer IDs are examples of instance identifiers.
</p>

<p>
The CD and all coded data types are used for concepts only.
Identifiers for individuals are represented with the Intstance
Idenfifier data type (II).
</p>
<div3 --><descriptive name="XML Representation"/><p><emph>CD</emph> is always represented in Element form
                  as described in the template and sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type CD --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   code = ST
   codeSystem = UID
   codeSystemName = ST
   codeSystemVersion = ST
   displayName = ST
   &gt;
   <emph>Content</emph>: ( originalText, qualifier*, translation* )
&lt;/x&gt;
</exhibit><div3 id="comp-CD.code"><head>Code : <termref ref="dtimpl-ST">ST</termref></head><p><emph role="strong">Definition:     </emph>
                     The plain code symbol defined by the code system.
                     For example, "784.0" is the code symbol of the ICD-9
                     code "784.0" for headache.
                  </p><descriptive name="XML Representation"/><p><emph>code</emph> is represented by the XML attribute<emph>code</emph>
                     whose value, if present, must be a valid
                     <loc href="http://www.w3.org/TR/xmlschema-2/#token" target="schema-rec" xlink-form="simple" show="embed" actuate="auto">xs:token</loc>
                     with no internal whitespace.
                  </p></div3><div3 id="comp-CD.codeSystem"><head>Code System : UID</head><p><emph role="strong">Definition:     </emph>
                     Specifies the code system that defines the code.
                  </p><descriptive name="XML Representation"/><p><emph>codeSystem</emph> is represented by the XML attribute<emph>codeSystem</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-UID">UID</termref>.
                  </p></div3><div3 id="comp-CD.codeSystemName"><head>Code System Name : <termref ref="dtimpl-ST">ST</termref></head><p><emph role="strong">Definition:     </emph>
                     A common name of the coding system.
                  </p><descriptive name="XML Representation"/><p><emph>codeSystemName</emph> is represented by the XML attribute<emph>codeSystemName</emph>
                  whose value, if present, must be a valid <termref ref="dtimpl-ST">ST</termref>.
               </p></div3><div3 id="comp-CD.codeSystemVersion"><head>Code System Version : <termref ref="dtimpl-ST">ST</termref></head><p><emph role="strong">Definition:     </emph>
                     If applicable, a version descriptor defined
                     specifically for the given code system.
                  </p><descriptive name="XML Representation"/><p><emph>codeSystemVersion</emph> is represented by the XML attribute<emph>codeSystemVersion</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-ST">ST</termref>.
                  </p></div3><div3 id="comp-CD.displayName"><head>Display Name : <termref ref="dtimpl-ST">ST</termref></head><p><emph role="strong">Definition:     </emph>
                     A name or title for the code, under which the sending
                     system shows the code value to its users.
                  </p><descriptive name="XML Representation"/><p><emph>displayName</emph> is represented by the XML attribute<emph>displayName</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-ST">ST</termref>.                                        	
                  </p></div3><div3 id="comp-CD.originalText"><head>Original Text : <termref ref="dtimpl-ED">ED</termref></head><p><emph role="strong">Definition:     </emph>
                        The text or phrase used as the basis for the coding.
                     </p><descriptive name="XML Representation"/><p><emph>originalText</emph> is represented by the XML element<emph>originalText</emph>
                     which, if present, must be a valid <termref ref="dtimpl-ED">ED</termref>.
                  </p></div3><div3 id="comp-CD.translation"><head>Translation : SET&lt;CD&gt;</head><p><emph role="strong">Definition:     </emph>
                        A set of other concept descriptors that translate
                        this concept descriptor into other code systems.
                     </p><descriptive name="XML Representation"/><p><emph>translation</emph> is represented by a 0 or more
                     XML elements<emph>translation</emph> each which must be a
                     valid <termref ref="dtimpl-CD">CD</termref>.
                  </p></div3><div3 id="comp-CD.qualifier"><head>Qualifier : LIST&lt;CR&gt;</head><p><emph role="strong">Definition:     </emph>
                        Specifies additional codes that increase the
                        specificity of the primary code.
                     </p><descriptive name="XML Representation"/><p><emph>qualifier</emph> is represented by a 0 or more
                     XML elements<emph>qualifer</emph> each of which must be a
                     valid <termref ref="dtimpl-CR">CR</termref>.
                  </p></div3><div3 id="CD-examples"><head>Examples</head><p>
                  The first example shows the SNOMED-CT code with
                  <termref ref="comp-CD.qualifier">qualifier</termref> for
                  "skin of palmer surface of left index finger".
               </p><exhibit role="example" verbatim="yes">
&lt;targetSiteCode code='48856004' codeSystem='2.16.840.1.113883.19.6.96'
      codeSystemName='SNOMED CT'
      displayName='Skin of palmer surface of index finger'&gt;
   &lt;qualifier&gt;
      &lt;name code='78615007' codeSystem='2.16.840.1.113883.19.6.96'
         codeSystemName='SNOMED CT' displayName='with laterality'/&gt;
      &lt;value code='7771000' codeSystem='2.16.840.1.113883.19.6.96'
         codeSystemName='SNOMED CT' displayName='left'/&gt;
   &lt;/qualifier&gt;
&lt;/targetSiteCode&gt;</exhibit><p>
                  The second example shows an observation whose
                  value is the SNOMED-CT code with <termref ref="comp-CD.qualifier">qualifier</termref>
                  and <termref ref="comp-CD.originalText">originalText</termref> for
                  "osteoarthritis of the right knee".
               </p><exhibit role="example" verbatim="yes">
&lt;code code='396275006' codeSystem='2.16.840.1.113883.19.6.96'
      codeSystemName='SNOMED CT' displayName='Osteoarthritis'&gt;
   &lt;originalText&gt;osteoarthritis of the right knee&lt;/originalText&gt;
   &lt;qualifier&gt;
      &lt;name code='363698007' codeSystem='2.16.840.1.113883.19.6.96'
         codeSystemName='SNOMED CT' displayName='finding site'/&gt;
      &lt;value code='6757004' codeSystem='2.16.840.1.113883.19.6.96'
         codeSystemName='SNOMED CT' displayName='right knee'/&gt;
   &lt;/qualifier&gt;
&lt;/code&gt;</exhibit></div3></div2><!-- Concept Role --><div2 id="dtimpl-CR"><head><anchor id="CR"/>Concept Role (CR)</head><p><emph role="strong">Definition:     </emph>
            A concept qualifier code with optionally named role.
            Both qualifier role and value codes must be defined by
            the coding system.  For example, if SNOMED RT defines a
            concept "leg", a role relation "has-laterality", and
            another concept "left", the concept role relation allows
            to add the qualifier "has-laterality: left" to a primary
            code "leg" to construct the meaning "left leg".
         </p><table id="dtimpl-CR-comp-summary"><caption>Components of
      Concept Role</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">name</termref></td><td><termref ref="dtimpl-CV">CV</termref></td><td>
                        Specifies the manner in which the concept role value
                        contributes to the meaning of a code phrase.  For
                        example, if SNOMED RT defines a concept "leg", a role
                        relation "has-laterality", and another concept "left",
                        the concept role relation allows to add the qualifier
                        "has-laterality: left" to a primary code "leg" to
                        construct the meaning "left leg".  In this example
                        "has-laterality" is <emph>name</emph>.
                     </td></tr><tr><td><termref ref="">value</termref></td><td><termref ref="dtimpl-CD">CD</termref></td><td>
                        The concept that modifies the primary code of a code
                        phrase through the role relation.  For example, if
                        SNOMED RT defines a concept "leg", a role relation
                        "has-laterality", and another concept "left", the
                        concept role relation allows adding the qualifier
                        "has-laterality: left" to a primary code "leg" to
                        construct the meaning "left leg".  In this example
                        "left" is <emph>value</emph>.
                     </td></tr><tr><td><termref ref="">inverted</termref></td><td><termref ref="dtimpl-BN">BN</termref></td><td>
                     Indicates if the sense of the role name is inverted.
                     This can be used in cases where the underlying code
                     system defines inversion but does not provide reciprocal
                     pairs of role names. By default, inverted is <emph>false</emph>.
                  </td></tr></tbody></table><p>
               The use of qualifiers is strictly governed by the code
               system used. The <termref ref="dtimpl-CD">CD</termref> data type
               does not permit using qualifiers with code systems that
               do not provide for qualifiers (e.g. pre-coordinated systems,
               such as LOINC, ICD-10 PCS.)
            </p><descriptive name="XML Representation"/><p><emph>CR</emph> is represented in Element form as described
                  in the template and sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type CR --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   inverted = (true | false) : false
   &gt;
   <emph>Content</emph>: ( name, value )
&lt;/x&gt;
</exhibit><div3 id="comp-CR.name"><head>Name : <termref ref="dtimpl-CV">CV</termref></head><p><emph role="strong">Definition:     </emph>
                        Specifies the manner in which the concept role value
                        contributes to the meaning of a code phrase.  For
                        example, if SNOMED RT defines a concept "leg", a role
                        relation "has-laterality", and another concept "left",
                        the concept role relation allows to add the qualifier
                        "has-laterality: left" to a primary code "leg" to
                        construct the meaning "left leg".  In this example
                        "has-laterality" is <emph>name</emph>.
                     </p><p>
                  The name component can be NULL if a coding system allows
                  postcoordination but no role names.
               </p><descriptive name="XML Representation"/><p><emph>name</emph> is represented by the XML element<emph>name</emph>
                     which, if present, must be a valid <termref ref="dtimpl-CV">CV</termref>.
                  </p></div3><div3 id="comp-CR.value"><head>Value : <termref ref="dtimpl-CD">CD</termref></head><p><emph role="strong">Definition:     </emph>
                        The concept that modifies the primary code of a code
                        phrase through the role relation.  For example, if
                        SNOMED RT defines a concept "leg", a role relation
                        "has-laterality", and another concept "left", the
                        concept role relation allows adding the qualifier
                        "has-laterality: left" to a primary code "leg" to
                        construct the meaning "left leg".  In this example
                        "left" is <emph>value</emph>.
                     </p><p><emph>value</emph> is of type <termref ref="dtimpl-CD">CD</termref> and thus can
                  be in turn have qualifiers.  This allows qualifiers to nest.
                  Qualifiers can only be used as far as the underlying code
                  system defines them.  It is not allowed to use any kind of
                  qualifiers for code systems that do not explicitly allow and
                  regulate such use of qualifiers.
               </p><descriptive name="XML Representation"/><p><emph>value</emph> is represented by the XML element<emph>value</emph>
                     which, if present, must be a valid <termref ref="dtimpl-CD">CD</termref>.
                  </p></div3><div3 id="comp-CR.inverted"><head>Inversion Indicator : <termref ref="dtimpl-BN">BN</termref></head><p><emph role="strong">Definition:     </emph>
                     Indicates if the sense of the role name is inverted.
                     This can be used in cases where the underlying code
                     system defines inversion but does not provide reciprocal
                     pairs of role names. By default, inverted is <emph>false</emph>.
                  </p><p>
                  For example, a code system may define the role relation
                  "causes" besides the concepts "Streptococcus pneumoniae"
                  and "Pneumonia".  If that code system allows its roles to
                  be inverted, one can construct the post-coordinated concept
                  "Pneumococcus pneumonia" through "Pneumonia - causes,
                  inverted - Streptococcus pneumoniae."
               </p><p>
                  Roles may only be inverted if the underlying coding systems
                  allows such inversion.  Notably, if a coding system defines
                  roles in inverse pairs or intentionally does not define
                  certain inversions, the appropriate role code (e.g.
                  "caused-by") must be used rather than inversion. It must be
                  known whether the inverted property is true or false, if it
                  is NULL, the role cannot be interpreted.
               </p><descriptive name="XML Representation"/><p><emph>inverted</emph> is represented by the XML attribute<emph>inverted</emph>
                     whose value, if present, must be either <emph>true</emph>
                     or <emph>false</emph>.  The default value is <emph>false</emph>.
                  </p></div3><div3 id="CR-examples"><head>Examples</head><p>
            		See the examples using <termref ref="comp-CD.qualifier">CD.qualifier</termref> in
            		<specref ref="CD-examples"/>.
            	</p></div3></div2><div2 id="dtimpl-SC"><head><anchor id="SC"/>Character String with Code (SC) specializes <termref ref="dtimpl-ST">ST</termref></head><p><emph role="strong">Definition:     </emph>
            An <termref ref="dtimpl-ST">ST</termref> that optionally may have a code attached.
            The text must always be present if a code is present. The
            code is often a local code.
         </p><table id="dtimpl-SC-comp-summary"><caption>Components of
      Character String with Code</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="comp-SC.code">code</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     The plain code symbol defined by the code system.
                     For example, "784.0" is the code symbol of the ICD-9
                     code "784.0" for headache.
                  </td></tr><tr><td><termref ref="comp-SC.codeSystem">codeSystem</termref></td><td>UID</td><td>
                     Specifies the code system that defines the code.
                  </td></tr><tr><td><termref ref="comp-SC.codeSystemName">codeSystemName</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     A common name of the coding system.
                  </td></tr><tr><td><termref ref="comp-SC.codeSystemVersion">codeSystemVersion</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     If applicable, a version descriptor defined
                     specifically for the given code system.
                  </td></tr><tr><td><termref ref="comp-SC.displayName">displayName</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     A name or title for the code, under which the sending
                     system shows the code value to its users.
                  </td></tr></tbody></table><descriptive name="XML Representation"/><p><emph>SC</emph> is represented in Element form as described in
                  the template and sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type SC --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   code = ST
   codeSystem = UID
   codeSystemName = ST
   codeSystemVersion = ST
   displayName = ST
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/x&gt;
</exhibit><div3 id="comp-SC.code"><head><anchor id=""/>Code : <termref ref="dtimpl-ST">ST</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     The plain code symbol defined by the code system.
                     For example, "784.0" is the code symbol of the ICD-9
                     code "784.0" for headache.
                  </p></div3><descriptive name="XML Representation"/><p><emph>code</emph> is represented by the XML attribute<emph>code</emph>
                     whose value, if present, must be a valid
                     <loc href="http://www.w3.org/TR/xmlschema-2/#token" target="schema-rec" xlink-form="simple" show="embed" actuate="auto">xs:token</loc>
                     with no internal whitespace.
                  </p><div3 id="comp-SC.codeSystem"><head><anchor id=""/>Code System : UID (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     Specifies the code system that defines the code.
                  </p></div3><descriptive name="XML Representation"/><p><emph>codeSystem</emph> is represented by the XML attribute<emph>codeSystem</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-UID">UID</termref>.
                  </p><div3 id="comp-SC.codeSystemName"><head><anchor id=""/>Code System Name : <termref ref="dtimpl-ST">ST</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     A common name of the coding system.
                  </p></div3><descriptive name="XML Representation"/><p><emph>codeSystemName</emph> is represented by the XML attribute<emph>codeSystemName</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-ST">ST</termref>.
                  </p><div3 id="comp-SC.codeSystemVersion"><head><anchor id=""/>Code System Version : <termref ref="dtimpl-ST">ST</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     If applicable, a version descriptor defined
                     specifically for the given code system.
                  </p></div3><descriptive name="XML Representation"/><p><emph>codeSystemVersion</emph> is represented by the XML attribute<emph>codeSystemVersion</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-ST">ST</termref>.
                  </p><div3 id="comp-SC.displayName"><head><anchor id=""/>Display Name : <termref ref="dtimpl-ST">ST</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     A name or title for the code, under which the sending
                     system shows the code value to its users.
                  </p></div3><descriptive name="XML Representation"/><p><emph>displayName</emph> is represented by the XML attribute<emph>displayName</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-ST">ST</termref>.
                  </p></div2><!-- ************************************************
     INSTANCE IDENTIFIERS
     ************************************************ --><!-- UNIQUE IDENTIFIER STRING --><div2 id="dtimpl-UID"><head><anchor id="UID"/>Unique Identifier String (UID)</head><p><emph role="strong">Definition:     </emph>
            A unique identifier string is a character string which
            identifies an object in a globally unique and timeless
            manner. The allowable formats and values and procedures
            of this data type are strictly controlled by HL7. At this
            time, user-assigned identifiers may be certain character
            representations of ISO Object Identifiers (<termref ref="dtimpl-OID">OID</termref>)
            and DCE
            Universally Unique Identifiers (<termref ref="dtimpl-UUID">UUID</termref>).
            HL7 also reserves
            the right to assign other forms of UIDs (<termref ref="dtimpl-RUID">RUID</termref>,
            such as mnemonic
            identifiers for code systems.
         </p><p>
               The sole purpose of the <emph>UID</emph> is to be a globally and
               timelessly unique identifier. The form of the UID,
               whether it is an <termref ref="dtimpl-OID">OID</termref>, an
               <termref ref="dtimpl-UUID">UUID</termref> or <termref ref="dtimpl-RUID">RUID</termref> is
               entirely irrelevant. As far as HL7 is concerned, the
               only thing one can do with an <emph>UID</emph> is denote to the object
               for which it stands. Comparison of <emph>UID</emph>s is literal,
               i.e. if two UIDs have the same character sequence,
               they are assumed to denote the same object. If two <emph>UID</emph>s
               are not literally identical they <emph>may</emph>
               not denote to the same object.
            </p><p>
               No difference in semantics is recognized between the different
               allowed forms of the <emph>UID</emph>. The different forms are not distinguished
               by a component within or aside from the identifier string itself.
            </p><descriptive name="XML Representation"/><p><emph>UID</emph> is only represented in Attribute form, where
                  the value must be a valid <termref ref="dtimpl-OID">OID</termref>,
                  <termref ref="dtimpl-UUID">UUID</termref>, or HL7 reserved identifier
                  as defined in the sections below.
               </p><div3 id="dtimpl-OID"><head>ISO Object Identifier (OID) Scheme</head><p><emph role="strong">Definition:     </emph>
            A globally unique string representing an ISO Object Identifier
            (OID) in a form that consists only of non-negative numbers with
            no leading zeros and dots (e.g., "2.16.840.1.113883.19.3.1").
            According to ISO, OIDs are paths in a tree structure, with the
            left-most number representing the root and the right-most number
            representing a leaf.
         </p><p>
                  Each branch under the root corresponds to an assigning
                  authority. Each of these assigning authorities may, in
                  turn, designate its own set of assigning authorities
                  that work under its auspices, and so on down the line.
                  Eventually, one of these authorities assigns a unique
                  (to it as an assigning authority) number that corresponds
                  to a leaf node on the tree. The leaf may represent an
                  assigning authority (in which case the OID identifies
                  the authority), or an instance of an object. An assigning
                  authority owns a namespace, consisting of its sub-tree.
               </p><p>
                  OIDs are the preferred scheme for unique identifiers.
                  OIDs should always be used except if one of the inclusion
                  criteria for other schemes apply.
               </p></div3><div3 id="dtimpl-UUID"><head>DCE Universal Unique Identifier (UUID) Scheme</head><p><emph role="strong">Definition:     </emph>
            A DCE Universal Unique Identifier is a globally unique
            string consisting of 5 groups of upper- or lower-case
            hexadecimal digits having 8, 4, 4, 4, and 12 places
            respectively. UUIDs are assigned using Ethernet MAC
            addresses, the point in time of creation and some random
            components. This mix is believed to generate sufficiently
            unique identifiers without any organizational policy for
            identifier assignment (in fact this piggy-backs on the
            organization of MAC address assignment.)
         </p><p><emph>UUID</emph>s are not the preferred identifier scheme for use as
                  <emph>UID</emph>s. <emph>UUID</emph>s may be used when identifiers are issued
                  to objects representing individuals (e.g., entity instance
                  identifiers, act event identifiers, etc.) For objects
                  describing classes of things or events (e.g., catalog items),
                  OIDs are the preferred identifier scheme.
               </p></div3><div3 id="dtimpl-RUID"><head>HL7 Reserved Identifier Scheme</head><p><emph role="strong">Definition:     </emph>
            HL7 reserved identifiers are strings consisting only of
            (US-ASCII) letters, digits and hyphens, where the first
            character must be a letter. HL7 may assign these reserved
            identifiers as mnemonic identifiers for major concepts of
            interest to HL7.
         </p></div3><div3 id="UID-examples"><head>Examples</head><p>
            		See the examples in
            		<specref ref="II-examples"/>.
            	</p></div3></div2><!-- INSTANCE IDENTIFIER --><div2 id="dtimpl-II"><head><anchor id="II"/>Instance Identifier (II)</head><p><emph role="strong">Definition:     </emph>
            An identifier that uniquely identifies a thing or object.
            Examples are object identifier for HL7 RIM objects,
            medical record number, order id, service catalog item id,
            Vehicle Identification Number (VIN), etc. Instance
            identifiers are defined based on ISO object identifiers.
         </p><table id="dtimpl-II-comp-summary"><caption>Components of
      Instance Identifier</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">root</termref></td><td>UID</td><td>
                     A unique identifier that guarantees the global uniqueness
                     of the instance identifier. The root alone may be the
                     entire instance identifier.
                  </td></tr><tr><td><termref ref="">extension</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     A character string as a unique identifier within the
                     scope of the identifier root.
                  </td></tr><tr><td><termref ref="">assigningAuthorityName</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     A human readable name or mnemonic for the assigning
                     authority. This name may be provided solely for the
                     convenience of unaided humans interpreting an <emph>II</emph> value
                     and can have no computational meaning. Note: no
                     automated processing must depend on the assigning
                     authority name to be present in any form.
                  </td></tr><tr><td><termref ref="">displayable</termref></td><td><termref ref="dtimpl-BL">BL</termref></td><td>
                     Specifies if the identifier is intended for human
                     display and data entry (displayable = true) as
                     opposed to pure machine interoperation (displayable
                     = false).
                  </td></tr></tbody></table><p>
               Some identifier schemes define certain style options to
               their code values. For example, the U.S. Social Security
               Number (SSN) is normally written with dashes that group
               the digits into a pattern "123-12-1234". However, the
               dashes are not meaningful and a SSN can just as well be
               represented as "123121234" without the dashes.
            </p><p>
               In the case where identifier schemes provide for multiple
               representations, HL7 shall make a ruling about which is the
               preferred form. HL7 shall document that ruling where that
               respective external identifier scheme is recognized. HL7
               shall decide upon the preferred form based on criteria of
               practicality and common use. In absence of clear criteria
               of practicality and common use, the safest, most extensible,
               and least stylized (the least decorated) form shall be
               given preference.
            </p><p>
               From practical experience it is recommended that <termref ref="comp-II.extension">extension</termref>
               be an alphanumeric identifier not containing leading zero digits,
               for these are often erroneously stripped. "000123" and "123"
               would be different extension values, but this is prone to be
               misunderstood, leading to false non-matches and duplicate
               record entries. However applications should maintain any
               leading zero digits encountered in <termref ref="comp-II.extension">extension</termref>.
               Leading
               zero digits are prohibited in <termref ref="dtimpl-OID">OID</termref>s,
               but may occur in <termref ref="dtimpl-UUID">UUID</termref>s,
               where they must be maintained.
            </p><p>
               There is no separate check digit property. Check digits are
               used for human purpose and work best if kept completely
               transparent. <termref ref="comp-II.extension">extension</termref> MAY contain check digits anywhere,
               and the particular check digit scheme (if any) would be
               implied by the <termref ref="comp-II.root">root</termref>. However, a separate check digit
               property is intentionally not recognized by this specification.
            </p><descriptive name="XML Representation"/><p><emph>II</emph> is represented in Element form as described
                  in the template and sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type II --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   root = UID
   extension = ST
   assigningAuthorityName = ST
   displayable = BL
   /&gt;
</exhibit><div3 id="comp-II.root"><head>Root : UID</head><p><emph role="strong">Definition:     </emph>
                     A unique identifier that guarantees the global uniqueness
                     of the instance identifier. The root alone may be the
                     entire instance identifier.
                  </p><descriptive name="XML Representation"/><p><emph>root</emph> is represented by the XML attribute<emph>root</emph> whose value,
                     if present, must be a valid <termref ref="dtimpl-UID">UID</termref>.
                  </p></div3><div3 id="comp-II.extension"><head>Extension : <termref ref="dtimpl-ST">ST</termref></head><p><emph role="strong">Definition:     </emph>
                     A character string as a unique identifier within the
                     scope of the identifier root.
                  </p><descriptive name="XML Representation"/><p><emph>extension</emph> is represented by the XML attribute<emph>extension</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-ST">ST</termref>.
                  </p></div3><div3 id="comp-II.assigningAuthorityName"><head>Assigning Authority Name : <termref ref="dtimpl-ST">ST</termref></head><p><emph role="strong">Definition:     </emph>
                     A human readable name or mnemonic for the assigning
                     authority. This name may be provided solely for the
                     convenience of unaided humans interpreting an <emph>II</emph> value
                     and can have no computational meaning. Note: no
                     automated processing must depend on the assigning
                     authority name to be present in any form.
                  </p><descriptive name="XML Representation"/><p><emph>assigningAuthorityName</emph> is represented by the XML attribute<emph>assigningAuthorityName</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-ST">ST</termref>.
                  </p></div3><div3 id="comp-II.displayable"><head>Displayable : <termref ref="dtimpl-BL">BL</termref></head><p><emph role="strong">Definition:     </emph>
                     Specifies if the identifier is intended for human
                     display and data entry (displayable = true) as
                     opposed to pure machine interoperation (displayable
                     = false).
                  </p><descriptive name="XML Representation"/><p><emph>displayable</emph> is represented by the XML attribute<emph>displayable</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-BL">BL</termref>.
                  </p></div3><div3 id="II-examples"><head>Examples</head><p>
                  The first example shows a root that is an <termref ref="dtimpl-OID">OID</termref>.
               </p><exhibit role="example" verbatim="yes">
&lt;id root='2.16.840.1.113883.19' extension='123A45'/&gt;</exhibit><p>
                  The next example shows a root that is a <termref ref="dtimpl-UUID">UUID</termref>.
               </p><exhibit role="example" verbatim="yes">
&lt;id root='343EA54F-D0E0-CE95-56C7-23108D6E25B8' extension='N8718349'/&gt;</exhibit><p>
                  The final example shows a root that is a <termref ref="dtimpl-RUID">RUID</termref>.
               </p><exhibit role="example" verbatim="yes">
&lt;id root='A208d6E-25b8' extension='827-92837-99812'/&gt;</exhibit></div3></div2><!-- ************************************************
     TELECOMMUNICATION ADDRESS
     ************************************************ --><!-- URL --><div2 id="dtimpl-URL"><head><anchor id="URL"/>Universal Resource Locator (URL)</head><p><emph role="strong">Definition:     </emph>
            A telecommunications address  specified according to
            Internet standard RFC 1738
            [<loc href="http://www.ietf.org/rfc/rfc1738.txt" xlink-form="simple" show="embed" actuate="auto"/>]. The
            URL specifies the protocol and the contact point defined
            by that protocol for the resource.  Notable uses of the
            telecommunication address data type are for telephone and
            telefax numbers, e-mail addresses, Hypertext references,
            FTP references, etc.
         </p><p><emph>URL</emph>s have a standard representation as a character string,
               formatted as "&lt;code&gt;&lt;scheme&gt;:&lt;address&gt;;&lt;/code&gt;"
               where the most common schemes are listed in
               <tabref ref="domain-URLScheme"/>. The address portion of
               the <emph>URL</emph> is a character string whose format is entirely defined
               by the <emph>URL</emph> scheme.
            </p><p>
               Similar to the <termref ref="comp-ED.mediaType">ED.mediaType</termref>, HL7 makes
               suggestions about <emph/> values classifying them as
               <emph>required</emph>, <emph>recommended</emph>, <emph>other</emph>,
               and <emph>deprecated</emph>. Any scheme not mentioned has status
               <emph>other</emph>.
            </p><table id="domain-URLScheme"><caption>Domain URLScheme</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>status</th><th>definition</th></tr></thead><tbody><tr valign="top"><td>tel </td><td>Telephone </td><td>required </td><td>A voice telephone number [http://www.ietf.org/rfc/rfc3966.txt and http://www.ietf.org/rfc/rfc2806.txt]. </td></tr><tr valign="top"><td>fax </td><td>Fax </td><td>required </td><td>A telephone number served by a fax device [http://www.ietf.org/rfc/rfc3966.txt and http://www.ietf.org/rfc/rfc2806.txt]. </td></tr><tr valign="top"><td>mailto </td><td>Mailto </td><td>required </td><td>Electronic mail address [http://www.ietf.org/rfc/rfc2368.txt]. </td></tr><tr valign="top"><td>http </td><td>HTTP </td><td>required </td><td>Hypertext Transfer Protocol [http://www.ietf.org/rfc/rfc2368.txt]. </td></tr><tr valign="top"><td>ftp </td><td>FTP </td><td>required </td><td>The File Transfer Protocol (FTP) [http://www.ietf.org/rfc/rfc1738.txt]. </td></tr><tr valign="top"><td>mllp </td><td>MLLP </td><td>required </td><td>								The traditional HL7 Minimal Lower Layer Protocol.
								The URL has the form of a common IP URL e.g.,
								mllp://&lt;host&gt;:&lt;port&gt;/ with &lt;host&gt; being the IP address or DNS hostname
								and &lt;port&gt; being a port number on which the MLLP protocol is
								served.
 </td></tr><tr valign="top"><td>file </td><td>File </td><td>deprecated </td><td>Host-specific local file names [RCF 1738].  Note that the file scheme works only for local files.  There is little use for exchanging local file names between systems, since the receiving system likely will not be able to access the file. </td></tr><tr valign="top"><td>nfs </td><td>NFS </td><td>other </td><td>Network File System protocol [http://www.ietf.org/rfc/rfc2224.txt].  Some sites use NFS servers to share data files. </td></tr><tr valign="top"><td>telnet </td><td>Telnet </td><td>other </td><td>Reference to interactive sessions [http://www.ietf.org/rfc/rfc1738.txt].  Some sites, (e.g., laboratories) have TTY based remote query sessions that can be accessed through telnet. </td></tr><tr valign="top"><td>modem </td><td>Modem </td><td>other </td><td>A telephone number served by a modem device  [http://www.ietf.org/rfc/rfc3966.txt and http://www.ietf.org/rfc/rfc2806.txt]. </td></tr></tbody></table><descriptive name="XML Representation"/><p><emph>URL</emph> is a protected type and is represented
                  only in Attribute form in the value component of <termref ref="dtimpl-TEL">TEL</termref>;
                  the XML attribute<emph>value</emph> must be a valid
                  <loc href="http://www.w3.org/TR/xmlschema-2/#anyURI" target="schema-rec" xlink-form="simple" show="embed" actuate="auto">xs:anyURI</loc>.
               </p><div3 id="tel-fax-uris"><head>Telephone and FAX Numbers</head><p>
                  Telephone and FAX Numbers. There is no special data type
                  for telephone numbers. Telephone numbers are
                  telecommunication addresses and are specified as a <emph>URL</emph>.
                  Voice telephone URLs begin with "tel:" and fax
                  URLs begin with "fax:".
               </p><p>
                  The telephone number URL is defined in the Internet RFC
                  2806 [<loc href="http://www.ietf.org/rfc/rfc2806.txt" xlink-form="simple" show="embed" actuate="auto"/>]
                  URLs for Telephone Calls. For example, "tel:+1(317)630-7960"
                  is a phone number, and "fax:+49(30)8101-724" is a FAX number.
                  The global absolute telephone numbers starting with the
                  "+" and country code are preferred. Separator characters
                  serve as decoration but have no meaning for the telephone
                  number, thus "tel:+13176307960" and "fax:+49308101724"
                  are the same telephone and FAX numbers as the previous
                  respective examples.
               </p></div3><div3 id="URL-examples"><head>Examples</head><p>
            		See the examples in
            		<specref ref="TEL-examples"/>.
            	</p></div3></div2><!-- TELECOMMUNICATION ADDRESS --><div2 id="dtimpl-TEL"><head><anchor id="TEL"/>Telecommunication Address (TEL) specializes <termref ref="dtimpl-URL">URL</termref></head><p><emph role="strong">Definition:     </emph>
            A telephone number (voice or fax), e-mail address, or
            other locator for a resource (information or service)
            mediated by telecommunication equipment. The address
            is specified as a <termref ref="dtimpl-URL">URL</termref>
            qualified by time specification and use codes that help
            in deciding which address to use for a given time and
            purpose.
         </p><table id="dtimpl-TEL-comp-summary"><caption>Components of
      Telecommunication Address</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">useablePeriod</termref></td><td>GTS</td><td>
                     Specifies the periods of time during which the
                     telecommunication address can be used.  For a
                     telephone number, this can indicate the time of day
                     in which the party can be reached on that telephone.
                     For a web address, it may specify a time range in
                     which the web content is promised to be available
                     under the given address.
                  </td></tr><tr><td><termref ref="">use</termref></td><td>SET&lt;CS&gt;</td><td>
                     One or more codes advising a system or user which
                     telecommunication address in a set of like addresses
                     to select for a given telecommunication need.
                  </td></tr></tbody></table><descriptive name="XML Representation"/><p><emph>TEL</emph> is represented in Element form as described
                  in the template and sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type TEL --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   value = ST
   use = CS*
   &gt;
   <emph>Content</emph>: ( useablePeriod* )
&lt;/x&gt;
</exhibit><div3 id="comp-TEL.useablePeriod"><head>Useable Period : GTS</head><p><emph role="strong">Definition:     </emph>
                     Specifies the periods of time during which the
                     telecommunication address can be used.  For a
                     telephone number, this can indicate the time of day
                     in which the party can be reached on that telephone.
                     For a web address, it may specify a time range in
                     which the web content is promised to be available
                     under the given address.
                  </p><descriptive name="XML Representation"/><p><emph>useablePeriod</emph> is represented by 0 or more
                     XML elements<emph>useablePeriod</emph> each of which
                     must be a valid <termref ref="dtimpl-GTS">GTS</termref>.
                  </p></div3><div3 id="comp-TEL.use"><head>Use : SET&lt;CS&gt;</head><p><emph role="strong">Definition:     </emph>
                     One or more codes advising a system or user which
                     telecommunication address in a set of like addresses
                     to select for a given telecommunication need.
                  </p><p>
                  The telecommunication address use codes are defined by
                  the HL7 domain TelecommunicationAddressUse
                  (<tabref ref="domain-TelecommunicationAddressUse"/>).
               </p><table id="domain-TelecommunicationAddressUse"><caption>Domain TelecommunicationAddressUse</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><th colspan="3"/></tr><tr valign="top"><td>  H</td><td>home address</td><td>A communication address at a home, attempted contacts for business purposes might intrude privacy and chances are one will contact family or other household members instead of the person one wishes to call.  Typically used with urgent cases, or if no other contacts are available.</td></tr><tr valign="top"><td>    HP</td><td>primary home</td><td>The primary home, to reach a person after business hours.</td></tr><tr valign="top"><td>    HV</td><td>vacation home</td><td>A vacation home, to reach a person while on vacation.</td></tr><tr valign="top"><td>  WP</td><td>work place</td><td>An office address.  First choice for business related contacts during business hours.</td></tr><tr valign="top"><td>    DIR</td><td>Direct</td><td>Indicates a work place address or telecommunication address that reaches the individual or organization directly without intermediaries.  For phones, often referred to as a 'private line'.</td></tr><tr valign="top"><td>    PUB</td><td>Public</td><td>Indicates a work place address or telecommunication address that is a 'standard' address which may reach a reception service, mail-room, or other intermediary prior to the target entity.</td></tr><tr valign="top"><td>  BAD</td><td>bad address</td><td>A flag indicating that the address is bad, in fact, useless.</td></tr><tr valign="top"><td>  TMP</td><td>temporary address</td><td>A temporary address, may be good for visit or mailing.  Note that an address history can provide more detailed information.</td></tr><tr valign="top"><td>AS</td><td>answering service</td><td>An automated answering machine used for less urgent cases and if the main purpose of contact is to leave a message or access an automated announcement.</td></tr><tr valign="top"><td>EC</td><td>emergency contact</td><td>A contact specifically designated to be used for emergencies.  This is the first choice in emergencies, independent of any other use codes.</td></tr><tr valign="top"><td>MC</td><td>mobile contact</td><td>A telecommunication device that moves and stays with its owner.  May have characteristics of all other use codes, suitable for urgent matters, not the first choice for routine business.</td></tr><tr valign="top"><td>PG</td><td>pager</td><td>A paging device suitable to solicit a callback or to leave a very short message.</td></tr></table><!--
                  <entry code="H">
                     <entry code="HP"/>
                     <entry code="HV"/>
                  </entry>
                  <entry code="WP">
                     <entry code="DIR"/>
                     <entry code="PUB"/>
                  </entry>
                  <entry code="BAD"/>
                  <entry code="EC"/>
                  <entry code="TMP"/>
                  <entry code="AS"/>
                  <entry code="PG"/>
                  <entry code="MC"/>
               </domain>
  --><p>
                  The telecommunication use code is not a complete
                  classification for equipment types or locations.
                  Its main purpose is to suggest or discourage the
                  use of a particular telecommunication address. The use
                  code should not be considered in isolation. The data
                  element in which the telephone number appears (class
                  and attribute) and the context to other data may
                  express the precise nature and use of the
                  telecommunication address more appropriately than a use code.
               </p><descriptive name="XML Representation"/><p><emph>use</emph> is represented by the XML attribute<emph>use</emph>
                     whose value, if present, must be 0 or more valid
                     values from the TelecommunicationAddressUse
                     (<tabref ref="domain-TelecommunicationAddressUse"/>)
                     separated by whitespace.
                  </p></div3><div3 id="TEL-examples"><head>Examples</head><p>
                  The first example shows a work email address.
               </p><exhibit role="example" verbatim="yes">
&lt;telecom use='WP' value='mailto://someone@example.com'/&gt;</exhibit><p>
                  The second example shows a PNG file that is only
                  accessible between 08:45 and 09:45 on July 20, 2000.
               </p><exhibit role="example" verbatim="yes">
&lt;reference value='http://example.org/xrays/128s8d9ej229se32s.png'&gt;
   &lt;useablePeriod xsi:type='IVL_TS'&gt;
      &lt;low value='200007200845'/&gt;
      &lt;high value='200008200945'/&gt;
   &lt;/useablePeriod&gt;
&lt;/reference&gt;</exhibit><p>
                  The final example shows a home phone number of 555-555-5001.
               </p><exhibit role="example" verbatim="yes">
&lt;telecom use='H' value='tel:555-555-5001'/&gt;</exhibit></div3></div2><!-- ************************************************
     POSTAL ADDRESS
     ************************************************ --><!-- Address Part --><div2 id="dtimpl-ADXP"><head><anchor id="ADXP"/>Address Part (ADXP)</head><p><emph role="strong">Definition:     </emph>
            A character string that may have a type-tag signifying its
            role in the address. Typical parts that exist in about
            every address are street, house number, or post box,
            postal code, city, country but other roles may be defined
            regionally, nationally, or on an enterprise level (e.g. in
            military addresses). Addresses are usually broken up into
            lines, which are indicated by special line-breaking
            delimiter elements (e.g., DEL).
         </p><table id="dtimpl-ADXP-comp-summary"><caption>Components of
      Address Part</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="comp-ADXP.data">data</termref></td><td>XML Text Content</td><td>
                     The data itself represented in the XML instance encoding.
                  </td></tr><tr><td><termref ref="">partType</termref></td><td><termref ref="dtimpl-CS">CS</termref></td><td>
                     Specifies whether an address part names the street,
                     city, country, postal code, post box, etc. If the type
                     is NULL the address part is unclassified and would
                     simply appear on an address label as is.
                  </td></tr></tbody></table><descriptive name="XML Representation"/><p><emph>ADXP</emph> is represented as an XML element
                  whose name is derived from the address part type code
                  (see table below) and whose content is just like an
                  <termref ref="dtimpl-ST">ST</termref>, except that it also has
                  an XML attribute<emph>partType</emph> as described above,
                  whose value is fixed to the appropriate address part type.
                  The XML attribute<emph>partType</emph> is generally not used.
                </p><!-- Note to Editors future types - the element names be the camelCased
(initial lower) version of the vocab term display name (with spaces removed).
For various reasons existing element names do not conform to this rule. GDG 2003-06-09 --><exhibit role="template" verbatim="yes">
&lt;!-- type ADXP --&gt;
&lt;additionalLocator
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (ADL) : ADL
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/additionalLocator&gt;

&lt;unitID
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (UNID) : UNID
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/unitID&gt;

&lt;unitType
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (UNIT) : UNIT
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/unitType&gt;

&lt;deliveryAddressLine
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (DAL) : DAL
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/deliveryAddressLine&gt;

&lt;deliveryInstallationType
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (DINST) : DINST
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/deliveryInstallationType&gt;

&lt;deliveryInstallationArea
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (DINSTA) : DINSTA
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/deliveryInstallationArea&gt;

&lt;deliveryInstallationQualifier
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (DINSTQ) : DINSTQ
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/deliveryInstallationQualifier&gt;

&lt;deliveryMode
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (DMOD) : DMOD
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/deliveryMode&gt;

&lt;deliveryModeIdentifier
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (DMODID) : DMODID
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/deliveryModeIdentifier&gt;

&lt;streetAddressLine
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (SAL) : SAL
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/streetAddressLine&gt;

&lt;houseNumber
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (BNR) : BNR
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/houseNumber&gt;

&lt;buildingNumberSuffix
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (BNS) : BNS
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/buildingNumberSuffix&gt;

&lt;postBox
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (POB) : POB
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/postBox&gt;

&lt;houseNumberNumeric
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (BNN) : BNN
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/houseNumberNumeric&gt;

&lt;streetName
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (STR) : STR
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/streetName&gt;

&lt;streetNameBase
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (STB) : STB
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/streetNameBase&gt;

&lt;streetNameType
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (STTYP) : STTYP
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/streetNameType&gt;

&lt;direction
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (DIR) : DIR
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/direction&gt;

&lt;careOf
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (CAR) : CAR
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/careOf&gt;

&lt;censusTract
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (CEN) : CEN
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/censusTract&gt;

&lt;country
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (CNT) : CNT
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/country&gt;

&lt;county
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (CPA) : CPA
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/county&gt;

&lt;city
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (CTY) : CTY
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/city&gt;

&lt;delimiter
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (DEL) : DEL
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/delimiter&gt;

&lt;precinct
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (PRE) : PRE
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/precinct&gt;

&lt;state
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (STA) : STA
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/state&gt;

&lt;postalCode
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (ZIP) : ZIP
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/postalCode&gt;
</exhibit><div3 id="comp-ADXP.data"><head><anchor id=""/>Data : XML Text Content (inherited from <termref ref="dtimpl-BIN">BIN</termref>)</head></div3><p><emph role="strong">Definition:     </emph>
                     The data itself represented in the XML instance encoding.
                  </p><descriptive name="XML Representation"/><p><emph/> is represented as the text content
                     of the	XML element representing the ADXP value.
                  </p><div3 id="comp-ADXP.partType"><head>Address Part Type : <termref ref="dtimpl-CS">CS</termref></head><p><emph role="strong">Definition:     </emph>
                     Specifies whether an address part names the street,
                     city, country, postal code, post box, etc. If the type
                     is NULL the address part is unclassified and would
                     simply appear on an address label as is.
                  </p><p>
                  Address part types are as defined in
                  <tabref ref="domain-AddressPartType"/></p><table id="domain-AddressPartType"><caption>Domain AddressPartType</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><td>ADL</td><td>additional locator</td><td>This can be a unit designator, such as apartment number, suite number, or floor. There may be several unit designators in an address (e.g., "3rd floor, Appt. 342"). This can also be a designator pointing away from the location, rather than specifying a smaller location within some larger one (e.g., Dutch "t.o." means "opposite to" for house boats located across the street facing houses).</td></tr><tr valign="top"><td>  UNID</td><td>unit identifier</td><td>The number or name of a specific unit contained within a building or complex, as assigned by that building or complex.</td></tr><tr valign="top"><td>  UNIT</td><td>unit designator</td><td>Indicates the type of specific unit contained within a building or complex.  E.g. Appartment, Floor</td></tr><tr valign="top"><td>DAL</td><td>delivery address line</td><td>A delivery address line is frequently used instead of breaking out delivery mode, delivery installation, etc.  An address generally has only a delivery address line or a street address line, but not both.</td></tr><tr valign="top"><td>  DINST</td><td>delivery installation type</td><td>Indicates the type of delivery installation (the facility to which the mail will be delivered prior to final shipping via the delivery mode.) Example: post office, letter carrier depot, community mail center, station, etc.</td></tr><tr valign="top"><td>  DINSTA</td><td>delivery installation area</td><td>The location of the delivery installation, usually a town or city, and is only required if the area is different from the municipality. Area to which mail delivery service is provided from any postal facility or service such as an individual letter carrier, rural route, or postal route.</td></tr><tr valign="top"><td>  DINSTQ</td><td>delivery installation qualifier</td><td>A number, letter or name identifying a delivery installation.  E.g., for Station A, the delivery installation qualifier would be 'A'.</td></tr><tr valign="top"><td>  DMOD</td><td>delivery mode</td><td>Indicates the type of service offered, method of delivery.  For example: post office box, rural route, general delivery, etc.</td></tr><tr valign="top"><td>  DMODID</td><td>delivery mode identifier</td><td>Represents the routing information such as a letter carrier route number.  It is the identifying number of the designator (the box number or rural route number).</td></tr><tr valign="top"><td>SAL</td><td>street address line</td><td/></tr><tr valign="top"><td>  BNR</td><td>building number</td><td>The number of a building, house or lot alongside the street.  Also known as "primary street number".  This does not number the street but rather the building.</td></tr><tr valign="top"><td>    BNN</td><td>building number numeric</td><td>The numeric portion of a building number</td></tr><tr valign="top"><td>    BNS</td><td>building number suffix</td><td>Any alphabetic character, fraction or other text that may appear after the numeric portion of a building number</td></tr><tr valign="top"><td>  STR</td><td>street name</td><td/></tr><tr valign="top"><td>    STB</td><td>street name base</td><td>The base name of a roadway or artery recognized by a municipality (excluding street type and direction)</td></tr><tr valign="top"><td>    STTYP</td><td>street type</td><td>The designation given to the street.  (e.g. Street, Avenue, Crescent, etc.)</td></tr><tr valign="top"><td>  DIR</td><td>direction</td><td>Direction (e.g., N, S, W, E)</td></tr><tr valign="top"><td>CAR</td><td>care of</td><td>The name of the party who will take receipt at the specified address, and will take on responsibility for ensuring delivery to the target recipient</td></tr><tr valign="top"><td>CEN</td><td>census tract</td><td>A geographic sub-unit delineated for demographic purposes.</td></tr><tr valign="top"><td>CNT</td><td>country</td><td>Country</td></tr><tr valign="top"><td>CPA</td><td>county or parish</td><td>A sub-unit of a state or province. (49 of the United States of America use the term "county;" Louisiana uses the term "parish".)</td></tr><tr valign="top"><td>CTY</td><td>municipality</td><td>The name of the city, town, village, or other community or delivery center</td></tr><tr valign="top"><td>DEL</td><td>delimiter</td><td>Delimiters are printed without framing white space.  If no value component is provided, the delimiter appears as a line break.</td></tr><tr valign="top"><td>POB</td><td>post box</td><td>A numbered box located in a post station.</td></tr><tr valign="top"><td>PRE</td><td>precinct</td><td>A subsection of a municipality</td></tr><tr valign="top"><td>STA</td><td>state or province</td><td>A sub-unit of a country with limited sovereignty in a federally organized country.</td></tr><tr valign="top"><td>ZIP</td><td>postal code</td><td>A postal code designating a region defined by the postal service.</td></tr></table><!--
	pvb: 20050630: commented out all these...just use the standard
	vocab, since these individual entries don't actually
	change anything
	
		 		 		 		 		 		 <entry code="ADL">
		 		 		 		 		 		 		 <entry code="UNID"/>
		 		 		 		 		 		 		 <entry code="UNIT"/>
		 		 		 		 		 		 </entry>
		 		 		 		 		 		 <entry code="DAL">
		 		 		 		 		 		 		 <entry code="DINST"/>
		 		 		 		 		 		 		 <entry code="DINSTA"/>
		 		 		 		 		 		 		 <entry code="DINSTQ"/>
		 		 		 		 		 		 		 <entry code="DMOD"/>
		 		 		 		 		 		 		 <entry code="DMODID"/>
		 		 		 		 		 		 </entry>
		 		 		 		 		 		 <entry code="SAL">
		 		 		 		 		 		 		 <entry code="BNR">
		 		 		 		 		 		 		 		 <entry code="BNS"/>
		 		 		 		 		 		 		 		   <entry code="POB"/>
		 		 		 		 		 		 		 		 <entry code="BNN"/>
		 		 		 		 		 		 		 </entry>
		 		 		 		 		 		 		 <entry code="STR">
		 		 		 		 		 		 		 		 <entry code="STB"/>
		 		 		 		 		 		 		 		 <entry code="STTYP"/>
		 		 		 		 		 		 		 </entry>
		 		 		 		 		 		 		 <entry code="DIR"/>
		 		 		 		 		 		 </entry>
		 		 		 		 		 		 <entry code="CAR"/>
		 		 		 		 		 		 <entry code="CEN"/>
		 		 		 		 		 		 <entry code="CNT"/>
		 		 		 		 		 		 <entry code="CPA"/>
		 		 		 		 		 		 <entry code="CTY"/>
		 		 		 		 		 		 <entry code="DEL"/>
		 		 		 		 		 		 <entry code="PRE"/>
		 		 		 		 		 		 <entry code="STA"/>
		 		 		 		 		 		 <entry code="ZIP"/>
		 		 		 		 		 </domain>
--><p>
                  Addresses are conceptualized as text with added mark-up.
                  The mark-up may break the address into lines and may
                  describe in detail the role of each address part if it
                  is known. Address parts occur in the address in the order
                  in which they would be printed on a mailing label. The
                  model is similar to HTML or XML markup of text.
               </p><descriptive name="XML Representation"/><p><emph>partType</emph> is represented simultaneously in Element
                     and Attribute forms. In the Element form, the name of
                     the element is determined by the part type, as specified
                     in <tabref ref="AddressPartType-Element-Names"/> below.
                     Additionally, each such element has an XML attribute<emph>partType</emph>
                     whose value, if present, must be a valid value from the
                     domain AddressPartType (<tabref ref="domain-AddressPartType"/>)
                     corresponding to the part type represented by the element
                     on which it appears. Since the XML attribute<emph>partType</emph> always
                     has a fixed value, it is not normally present in the
                     XML instance.
                  </p><table id="AddressPartType-Element-Names"><caption>AddressPartType Element Names</caption><tr><td rowspan="1" colspan="1">Element Name</td><td rowspan="1" colspan="1">Part Type</td></tr><tr><td rowspan="1" colspan="1">additionalLocator</td><td rowspan="1" colspan="1">ADL</td></tr><tr><td rowspan="1" colspan="1">unitID</td><td rowspan="1" colspan="1">UNID</td></tr><tr><td rowspan="1" colspan="1">unitType</td><td rowspan="1" colspan="1">UNIT</td></tr><tr><td rowspan="1" colspan="1">deliveryAddressLine</td><td rowspan="1" colspan="1">DAL</td></tr><tr><td rowspan="1" colspan="1">deliveryInstallationType</td><td rowspan="1" colspan="1">DINST</td></tr><tr><td rowspan="1" colspan="1">deliveryInstallationArea</td><td rowspan="1" colspan="1">DINSTA</td></tr><tr><td rowspan="1" colspan="1">deliveryInstallationQualifier</td><td rowspan="1" colspan="1">DINSTQ</td></tr><tr><td rowspan="1" colspan="1">deliveryMode</td><td rowspan="1" colspan="1">DMOD</td></tr><tr><td rowspan="1" colspan="1">deliveryModeIdentifier</td><td rowspan="1" colspan="1">DMODID</td></tr><tr><td rowspan="1" colspan="1">streetAddressLine</td><td rowspan="1" colspan="1">SAL</td></tr><tr><td rowspan="1" colspan="1">houseNumber</td><td rowspan="1" colspan="1">BNR</td></tr><tr><td rowspan="1" colspan="1">buildingNumberSuffix</td><td rowspan="1" colspan="1">BNS</td></tr><tr><td rowspan="1" colspan="1">postBox</td><td rowspan="1" colspan="1">POB</td></tr><tr><td rowspan="1" colspan="1">houseNumberNumeric</td><td rowspan="1" colspan="1">BNN</td></tr><tr><td rowspan="1" colspan="1">streetName</td><td rowspan="1" colspan="1">STR</td></tr><tr><td rowspan="1" colspan="1">streetNameBase</td><td rowspan="1" colspan="1">STB</td></tr><tr><td rowspan="1" colspan="1">streetNameType</td><td rowspan="1" colspan="1">STTYP</td></tr><tr><td rowspan="1" colspan="1">direction</td><td rowspan="1" colspan="1">DIR</td></tr><tr><td rowspan="1" colspan="1">careOf</td><td rowspan="1" colspan="1">CAR</td></tr><tr><td rowspan="1" colspan="1">censusTract</td><td rowspan="1" colspan="1">CEN</td></tr><tr><td rowspan="1" colspan="1">country</td><td rowspan="1" colspan="1">CNT</td></tr><tr><td rowspan="1" colspan="1">county</td><td rowspan="1" colspan="1">CPA</td></tr><tr><td rowspan="1" colspan="1">city</td><td rowspan="1" colspan="1">CTY</td></tr><tr><td rowspan="1" colspan="1">delimiter</td><td rowspan="1" colspan="1">DEL</td></tr><tr><td rowspan="1" colspan="1">precinct</td><td rowspan="1" colspan="1">PRE</td></tr><tr><td rowspan="1" colspan="1">state</td><td rowspan="1" colspan="1">STA</td></tr><tr><td rowspan="1" colspan="1">postalCode</td><td rowspan="1" colspan="1">ZIP</td></tr></table><!-- FIXME: the following should be presented in a tabular form
and then generated automagically
--></div3><div3 id="ADXP-examples"><head>Examples</head><p>
            		See the examples in
            		<specref ref="AD-examples"/>.
            	</p></div3></div2><div2 id="dtimpl-AD"><head><anchor id="AD"/>Postal Address (AD)</head><p><emph role="strong">Definition:     </emph>
            Mailing and home or office addresses. A sequence of
            address parts, such as street or post office Box, city,
            postal code, country, etc.
         </p><p><emph>AD</emph> is primarily used to communicate data that will allow
               printing mail labels, that will allow a person to physically
               visit that address. The postal address data type is not
               supposed to be a container for additional information that
               might be useful for finding geographic locations (e.g., GPS
               coordinates) or for performing epidemiological studies. Such
               additional information is captured by other, more appropriate
               HL7 elements.
            </p><p>
               Structurally, the postal address data type is a sequence of
               address part values with an added "use" code and a valid time
               range for information about if and when the address can be
               used for a given purpose.
            </p><p>
               Applications are not required to preserve the ordering of the
               address parts.
            </p><table id="dtimpl-AD-comp-summary"><caption>Components of
      Postal Address</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">use</termref></td><td>SET&lt;CS&gt;</td><td>
                     A set of codes advising a system or user which address
                     in a set of like addresses to select for a given purpose.
                  </td></tr><tr><td><termref ref="">useablePeriod</termref></td><td>GTS</td><td>
                        A <termref ref="dtimpl-GTS">GTS</termref> specifying the
                        periods of time during which the address can be used.
                        This is used to specify different addresses for
                        different times of the year or to refer to historical
                        addresses.
                     </td></tr><tr><td><termref ref="">isNotOrdered</termref></td><td><termref ref="dtimpl-BL">BL</termref></td><td>
                     A boolean value specifying whether the order of the
                     address parts is known or not. While the address parts
                     are always a Sequence, the order in which they are
                     presented may or may not be known. Where this matters,
                     <emph>isNotOrdered</emph> can be used to convey this
                     information.
                  </td></tr></tbody></table><descriptive name="XML Representation"/><p><emph>AD</emph> is represented by an XML element whose
                  name is determined by the context in which it is used. The
                  element has attributes and child elements as described in
                  the template and the sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type AD --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   isNotOrdered = BL
   use = CS*
   &gt;
   <emph>Content</emph>: ( ( delimiter | country | state | county | city | postalCode | streetAddressLine |
                houseNumber | houseNumberNumeric | direction | streetName | streetNameBase |
                streetNameType | additionalLocator | unitID | unitType | careOf | censusTract |
                deliveryAddressLine | deliveryInstallationType | deliveryInstallationArea |
                deliveryInstallationQualifier | deliveryMode | deliveryModeIdentifier |
                buildingNumberSuffix | postBox | precinct | #PCDATA )*, useablePeriod* )
&lt;/x&gt;
</exhibit><p>
                  Any non whitespace text in the <emph>AD</emph> content is interpreted as
                  <termref ref="dtimpl-ADXP">ADXP</termref> parts with a null partType. Refer to the the Formatting
                  Address section (2.21.1.5) in Abstract Data Types Specification
                  for full details on interpretation of <emph>AD</emph> content.
               </p><!-- Note to Editors future types - the element names be the camelCased
(initial lower) version of the vocab term display name (with spaces removed).
For various reasons existing element names do not conform to this rule --><div3 id="comp-AD.use"><head>Use : SET&lt;CS&gt;</head><p><emph role="strong">Definition:     </emph>
                     A set of codes advising a system or user which address
                     in a set of like addresses to select for a given purpose.
                  </p><p>
                  The postal address use codes are defined by the PostalAddressUse
                  domain (<tabref ref="domain-PostalAddressUse"/>).
               </p><table id="domain-PostalAddressUse"><caption>Domain PostalAddressUse</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><th colspan="3"/></tr><tr valign="top"><td>  H</td><td>home address</td><td>A communication address at a home, attempted contacts for business purposes might intrude privacy and chances are one will contact family or other household members instead of the person one wishes to call.  Typically used with urgent cases, or if no other contacts are available.</td></tr><tr valign="top"><td>    HP</td><td>primary home</td><td>The primary home, to reach a person after business hours.</td></tr><tr valign="top"><td>    HV</td><td>vacation home</td><td>A vacation home, to reach a person while on vacation.</td></tr><tr valign="top"><td>  WP</td><td>work place</td><td>An office address.  First choice for business related contacts during business hours.</td></tr><tr valign="top"><td>    DIR</td><td>Direct</td><td>Indicates a work place address or telecommunication address that reaches the individual or organization directly without intermediaries.  For phones, often referred to as a 'private line'.</td></tr><tr valign="top"><td>    PUB</td><td>Public</td><td>Indicates a work place address or telecommunication address that is a 'standard' address which may reach a reception service, mail-room, or other intermediary prior to the target entity.</td></tr><tr valign="top"><td>  BAD</td><td>bad address</td><td>A flag indicating that the address is bad, in fact, useless.</td></tr><tr valign="top"><td>  TMP</td><td>temporary address</td><td>A temporary address, may be good for visit or mailing.  Note that an address history can provide more detailed information.</td></tr><tr valign="top"><th colspan="3">Identifies the different representations of a name.  The representation may affect how the name is used.  (E.g. use of Ideographic for formal communications.)</th></tr><tr valign="top"><td>  ABC</td><td>Alphabetic</td><td>Alphabetic transcription of name (Japanese: romaji)</td></tr><tr valign="top"><td>  IDE</td><td>Ideographic</td><td>Ideographic representation of name (e.g., Japanese kanji, Chinese characters)</td></tr><tr valign="top"><td>  SYL</td><td>Syllabic</td><td>Syllabic transcription of name (e.g., Japanese kana, Korean hangul)</td></tr><tr valign="top"><td>PHYS</td><td>physical visit address</td><td>Used primarily to visit an address.</td></tr><tr valign="top"><td>PST</td><td>postal address</td><td>Used to send mail.</td></tr></table><!--
                  <entry code="PHYS" override="graft" printName="visit address">
                     <definition>
		 		 		 A physical address, used primarily to visit the addressee.
		 		   </definition>
                  </entry>
                  <entry code="H">
                     <entry code="HP"/>
                     <entry code="HV"/>
                  </entry>
                  <entry code="WP">
                     <entry code="DIR"/>
                     <entry code="PUB"/>
                  </entry>
                  <entry code="BAD"/>
                  <entry code="BIR"/>
                  <entry code="TMP"/>
                  <entry code="PHYS"/>
                  <entry code="PST"/>
                  <entry code="ABC" from="EntityNameUse"/>
                  <entry code="SYL" from="EntityNameUse"/>
                  <entry code="IDE" from="EntityNameUse"/>
               </domain>
  --><p>
                  The postal address use code is not a complete classification
                  for locations or activities that take place at these
                  locations.  Its main purpose is to suggest or discourage
                  the use of a particular address. The use code should not
                  be considered in isolation. The data element in which the
                  address appears (class and attribute) and the context to
                  other data may express the precise nature and use of the
                  address more appropriately than a use code.
               </p><descriptive name="XML Representation"/><p><emph>use</emph> is represented by the XML attribute<emph>use</emph>
                     whose value, if present, must be 0 or more valid values
                     from the PostalAddressUse domain (<tabref ref="domain-PostalAddressUse"/>)
                     separated by whitespace.
                  </p></div3><div3 id="comp-AD.useablePeriod"><head>Useable Period : GTS</head><p><emph role="strong">Definition:     </emph>
                        A <termref ref="dtimpl-GTS">GTS</termref> specifying the
                        periods of time during which the address can be used.
                        This is used to specify different addresses for
                        different times of the year or to refer to historical
                        addresses.
                     </p><descriptive name="XML Representation"/><p><emph>useablePeriod</emph> is represented by 0 or more
                     XML elements<emph>useablePeriod</emph> each of which
                     must be a valid <termref ref="dtimpl-GTS">GTS</termref>.
                  </p></div3><div3 id="comp-AD.isNotOrdered"><head>Is Not Ordered : <termref ref="dtimpl-BL">BL</termref></head><p><emph role="strong">Definition:     </emph>
                     A boolean value specifying whether the order of the
                     address parts is known or not. While the address parts
                     are always a Sequence, the order in which they are
                     presented may or may not be known. Where this matters,
                     <emph>isNotOrdered</emph> can be used to convey this
                     information.
                  </p><descriptive name="XML Representation"/><p><emph>isNotOrdered</emph> is represented by the XML attribute<emph>isNotOrdered</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-BL">BL</termref>.
                  </p></div3><div3 id="AD-examples"><head>Examples</head><p>
                  The following are examples of addresses in an XML
                  encoded form, where the XML tag is the address part
                  type and the data content is the address part value.
               </p><p>
                  The address:
               </p><quote>
1050 W Wishard Blvd,<br/>
RG 5th floor,<br/>
Indianapolis, IN 46240
</quote><p>
                  can be encoded in any of the following forms: 
               </p><p>
                  The first form would result from a system that only stores
                  addresses as free text or in a list of fields line1, line2,
                  etc.:
               </p><exhibit role="example" verbatim="yes">
&lt;addr use='WP'&gt;
   1050 W Wishard Blvd,
   RG 5th floor,
   Indianapolis, IN 46240
&lt;/addr&gt;</exhibit><p>
                  The second form is more specific about the role of the
                  address parts than the first one and is the typical form
                  seen in the U.S., where
                  street address is sometimes separated, and city, state
                  and ZIP code are always separated.
               </p><exhibit role="example" verbatim="yes">
&lt;addr use='WP'&gt;
   &lt;streetAddressLine&gt;1050 W Wishard Blvd&lt;/streetAddressLine&gt;,
   &lt;streetAddressLine&gt;RG 5th floor&lt;/streetAddressLine&gt;,
   &lt;city&gt;Indianapolis&lt;/city&gt;, &lt;state&gt;IN&lt;/state&gt;
   &lt;postalCode&gt;46240&lt;/postalCode&gt;
&lt;/addr&gt;</exhibit><p>
                  The third is even more specific:
               </p><exhibit role="example" verbatim="yes">
&lt;addr use='WP'&gt;
   &lt;houseNumber&gt;1050&lt;/houseNumber&gt;
   &lt;direction&gt;W&lt;/direction&gt;
   &lt;streetName&gt;Wishard Blvd&lt;/streetName&gt;,
   &lt;additionalLocator&gt;RG 5th floor&lt;/additionalLocator&gt;,
   &lt;city&gt;Indianapolis&lt;/city&gt;, &lt;state&gt;IN&lt;/state&gt;
   &lt;postalCode&gt;46240&lt;/postalCode&gt;
&lt;/addr&gt;</exhibit><p>
                  The latter form above is not often used in the USA.
                  However, it is useful in Germany, where many systems
                  keep house number as a distinct field. For example,
                  the German address:
               </p><quote>
Windsteiner Weg 54a,<br/>
D-14165 Berlin
</quote><p>
                  would most likely be encoded as follows: 
               </p><exhibit role="example" verbatim="yes">
&lt;addr use='HP'&gt;
   &lt;streetName&gt;Windsteiner Weg&lt;/streetName&gt;
   &lt;houseNumber&gt;54a&lt;/houseNumber&gt;,&lt;delimiter/&gt;
   &lt;country&gt;D&lt;/country&gt;-&lt;postalCode&gt;14165&lt;/postalCode&gt;
   &lt;city&gt;Berlin&lt;/city&gt;
&lt;/addr&gt;</exhibit></div3></div2><!-- ************************************************
     ENTITY NAME
     ************************************************ --><!-- ENTITY NAME PART --><div2 id="dtimpl-ENXP"><head><anchor id="ENXP"/>Entity Name Part (ENXP)</head><p><emph role="strong">Definition:     </emph>
            A character string token representing a part of a name.
            May have a type code signifying the role of the part in
            the whole entity name, and a qualifier code for more detail
            about the name part type. Typical name parts for person
            names are given names, and family names, titles, etc.
         </p><table id="dtimpl-ENXP-comp-summary"><caption>Components of
      Entity Name Part</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="comp-ENXP.data">data</termref></td><td>XML Text Content</td><td>
                     The data itself represented in the XML instance encoding.
                  </td></tr><tr><td><termref ref="">partType</termref></td><td><termref ref="dtimpl-CS">CS</termref></td><td>
                     Indicates whether the name part is a given name, family
                     name, prefix, suffix, etc.
                  </td></tr><tr><td><termref ref="">qualifier</termref></td><td>SET&lt;CS&gt;</td><td><emph>qualifier</emph> is a set of codes each of which specifies
                     a certain subcategory of the name part in addition to
                     the main name part type. For example, a given name may
                     be flagged as a nickname, a family name may be a
                     pseudonym or a name of public records.
                  </td></tr></tbody></table><descriptive name="XML Representation"/><p><emph>ENXP</emph> is represented as an XML element
                  whose name is derived from the entity name part type
                  code (see table below) and whose content is just like
                  an <termref ref="dtimpl-ST">ST</termref>, except that it also
                  has XML attribute<emph>partType</emph> and XML attribute<emph>qualifier</emph> as described
                  above. The value of the XML attribute<emph>partType</emph> is fixed to the
                  appropriate name part type. The XML attribute<emph>partType</emph> is
                  generally not used.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type ENXP --&gt;
&lt;family
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (FAM): FAM
   qualifier = CS*
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/family&gt;

&lt;given
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (GIV) : GIV
   qualifier = CS*
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/given&gt;

&lt;prefix
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (PFX) : PFX
   qualifier = CS*
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/prefix&gt;

&lt;suffix
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (SFX) : SFX
   qualifier = CS*
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/suffix&gt;

&lt;delimiter
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   language = CS
   partType = (DEL) : DEL
   qualifier = CS*
   &gt;
   <emph>Content</emph>: ( #PCDATA )
&lt;/delimiter&gt;
</exhibit><div3 id="comp-ENXP.data"><head><anchor id=""/>Data : XML Text Content (inherited from <termref ref="dtimpl-BIN">BIN</termref>)</head></div3><p><emph role="strong">Definition:     </emph>
                     The data itself represented in the XML instance encoding.
                  </p><descriptive name="XML Representation"/><p><emph/> is represented as the text content of the
                     XML element representing the <emph>ENXP</emph> value.
                  </p><div3 id="comp-ENXP.partType"><head>Name Part Type : <termref ref="dtimpl-CS">CS</termref></head><p><emph role="strong">Definition:     </emph>
                     Indicates whether the name part is a given name, family
                     name, prefix, suffix, etc.
                  </p><p>
                  Entity name part types are as defined in
                  <tabref ref="domain-EntityNamePartType"/></p><table id="domain-EntityNamePartType"><caption>Domain EntityNamePartType</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><td>FAM</td><td>family</td><td>Family name, this is the name that links to the genealogy. In some cultures (e.g. Eritrea) the family name of a son is the first name of his father.</td></tr><tr valign="top"><td>GIV</td><td>given</td><td>Given name (don't call it "first name" since this given names do not always come first)</td></tr><tr valign="top"><td>PFX</td><td>prefix</td><td>A prefix has a strong association to the immediately following name part. A prefix has no implicit trailing white space (it has implicit leading white space though). Note that prefixes can be inverted.</td></tr><tr valign="top"><td>SFX</td><td>suffix</td><td>A suffix has a strong association to the immediately preceding name part. A prefix has no implicit leading white space (it has implicit trailing white space though). Suffices can not be inverted.</td></tr><tr valign="top"><td>DEL</td><td>delimiter</td><td>A delimiter has no meaning other than being literally printed in this name representation.  A delimiter has no implicit leading and trailing white space.</td></tr></table><p>
                  Not every name part must have a type code, if the type
                  code is unknown, not applicable, or simply undefined
                  this is expressed by a null value (type.isNull). For
                  example, a name may be  "Rogan Sulma" and it may not be
                  clear which one is a given name or which is a last
                  name, or whether Rogan may be a title.
               </p><p>
                  Entity names are conceptualized as text with added
                  mark-up. The mark-up may describe in detail the role
                  of each name part if it is known. Name parts occur in
                  the order in which they would be printed on a mailing
                  label. The model is similar to HTML or XML markup of text.
               </p><descriptive name="XML Representation"/><p><emph>partType</emph> is represented simultaneously in Element
                     and Attribute forms. In the Element form, the name of
                     the element is determined by the part type, as specified
                     in <tabref ref="EntityNamePartType-Element-Names"/> below.
                     Additionally, each such element has an XML attribute<emph>partType</emph>
                     whose value, if present, must be a valid value from the
                     domain EntityNamePartType
                     (<tabref ref="domain-EntityNamePartType"/>) corresponding
                     to the part type represented by the element on which it
                     appears. Since the XML attribute<emph>partType</emph> always has
                     a fixed value, it is not normally present in the XML
                     instance.
                  </p><table id="EntityNamePartType-Element-Names"><caption>EntityNamePartType Element Names</caption><tr><td rowspan="1" colspan="1">Element Name</td><td rowspan="1" colspan="1">Part Type</td></tr><tr><td rowspan="1" colspan="1">delimiter</td><td rowspan="1" colspan="1">DEL</td></tr><tr><td rowspan="1" colspan="1">family</td><td rowspan="1" colspan="1">FAM</td></tr><tr><td rowspan="1" colspan="1">given</td><td rowspan="1" colspan="1">GIV</td></tr><tr><td rowspan="1" colspan="1">prefix</td><td rowspan="1" colspan="1">PFX</td></tr><tr><td rowspan="1" colspan="1">suffix</td><td rowspan="1" colspan="1">SFX</td></tr></table><!-- FIXME: the following should be presented in a tabular form
and then generated automagically
--></div3><div3 id="comp-ENXP.qualifier"><head>Qualifier : SET&lt;CS&gt;</head><p><emph role="strong">Definition:     </emph><emph>qualifier</emph> is a set of codes each of which specifies
                     a certain subcategory of the name part in addition to
                     the main name part type. For example, a given name may
                     be flagged as a nickname, a family name may be a
                     pseudonym or a name of public records.
                  </p><p>
                  Entity name part qualifiers are as defined in
                  <tabref ref="domain-EntityNamePartQualifier"/></p><table id="domain-EntityNamePartQualifier"><caption>Domain EntityNamePartQualifier</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><th colspan="3"/></tr><tr valign="top"><td>  LS</td><td>Legal status</td><td>For organizations a suffix indicating the legal status, e.g., "Inc.", "Co.", "AG", "GmbH", "B.V." "S.A.",  "Ltd." etc.</td></tr><tr valign="top"><th colspan="3"/></tr><tr valign="top"><th colspan="3">  </th></tr><tr valign="top"><td>    AC</td><td>academic</td><td>Indicates that a prefix like "Dr." or a suffix like "M.D." or "Ph.D." is an academic title.</td></tr><tr valign="top"><td>    NB</td><td>nobility</td><td>In Europe and Asia, there are still people with nobility titles (aristocrats).  German "von" is generally a nobility title, not a mere voorvoegsel.  Others are "Earl of" or "His Majesty King of..." etc.  Rarely used nowadays, but some systems do keep track of this.</td></tr><tr valign="top"><td>    PR</td><td>professional</td><td>Primarily in the British Imperial culture people tend to have an abbreviation of their professional organization as part of their credential suffices.</td></tr><tr valign="top"><td>    VV</td><td>voorvoegsel</td><td>A Dutch "voorvoegsel" is something like "van" or "de" that might have indicated nobility in the past but no longer so. Similar prefixes exist in other languages such as Spanish, French or Portugese.</td></tr><tr valign="top"><th colspan="3">  </th></tr><tr valign="top"><td>    AD</td><td>adopted</td><td>The name the person was given at the time of adoption.</td></tr><tr valign="top"><td>    BR</td><td>birth</td><td>A name that a person had shortly after being born. Usually for family names but may be used to mark given names at birth that may have changed later.</td></tr><tr valign="top"><td>    SP</td><td>spouse</td><td>The name assumed from the partner in a marital relationship (hence the "M"). Usually the spouse's family name. Note that no inference about gender can be made from the existence of spouse names.</td></tr><tr valign="top"><th colspan="3">  </th></tr><tr valign="top"><td>    CL</td><td>callme</td><td>A callme name is (usually a given name) that is preferred when a person is directly addressed.</td></tr><tr valign="top"><td>  IN</td><td>initial</td><td>Indicates that a name part is just an initial. Initials do not imply a trailing period since this would not work with non-Latin scripts.  Initials may consist of more than one letter, e.g., "Ph." could stand for "Philippe" or "Th." for "Thomas".</td></tr><tr valign="top"><td>  TITLE</td><td>title</td><td>Indicates that a prefix or a suffix is a title that applies to the whole name, not just the adjacent name part.</td></tr></table><!--
                  <entry code="LS"/>
                  <entry code="AC"/>
                  <entry code="NB"/>
                  <entry code="PR"/>
                  <entry code="VV"/>
                  <entry code="AD"/>
                  <entry code="BR"/>
                  <entry code="SP"/>
                  <entry code="CL"/>
                  <entry code="IN"/>
                  <entry code="TITLE" override="graft" printName="title">
                     <definition>
                        Indicates that a prefix or a suffix is a title that
                        applies to the whole name, not just the adjacent name part
		 		   </definition>
                  </entry>
               </domain>
  --><descriptive name="XML Representation"/><p><emph>qualifier</emph> is represented as the XML attribute<emph>qualifier</emph>
                     whose value, if present, must be 0 or more values from the
                     EntityNamePartQualifier domain
                     (<tabref ref="domain-EntityNamePartQualifier"/>)
                     separated by whitespace.
                  </p></div3><div3 id="ENXP-examples"><head>Examples</head><p>
            		See the examples in
            		<specref ref="PN-examples"/>, <specref ref="ON-examples"/>
            		and <specref ref="TN-examples"/>.
            	</p></div3></div2><!-- ENTITY NAME --><div2 id="dtimpl-EN"><head><anchor id="EN"/>Entity Name (EN)</head><p><emph role="strong">Definition:     </emph>
            A name for a person, organization, place or thing. A
            sequence of name parts, such as given name or family
            name, prefix, suffix, etc. Examples for entity name
            values are "Jim Bob Walton, Jr.", "Health Level Seven,
            Inc.", "Lake Tahoe", etc. An entity name may be as simple
            as a character string or may consist of several entity name
            parts, such as, "Jim", "Bob", "Walton", and "Jr.", "Health
            Level Seven" and "Inc.", "Lake" and "Tahoe".
         </p><p>
               Structurally, the entity name data type is a sequence
               of entity name part values with an added "use" code and
               a valid time range for information about if and when the
               name can be used for a given purpose.
            </p><table id="dtimpl-EN-comp-summary"><caption>Components of
      Entity Name</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">use</termref></td><td>SET&lt;CS&gt;</td><td>
                     A set of codes advising a system or user which name
                     in a set of like names to select for a given purpose.
                     A name without specific use code might be a default
                     name useful for any purpose, but a name with a specific
                     use code would be preferred for that respective purpose.
                  </td></tr><tr><td><termref ref="">validTime</termref></td><td>IVL&lt;TS&gt;</td><td>
                        An interval of time specifying the time during which
                        the name is or was used for the entity. This
                        accomodates the fact that people change names for
                        people, places and things.
                     </td></tr></tbody></table><descriptive name="XML Representation"/><p><emph>EN</emph> is represented by an XML element
                  whose name is determined by the context in which it is
                  used. The element has attributes and child elements as
                  described in the template and the sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type EN --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   use = CS*
   &gt;
   <emph>Content</emph>: ( (delimiter | family | given | prefix | suffix | #PCDATA)*, validTime )
&lt;/x&gt;
</exhibit><!-- pvb: 20050715: the section reference to the abstract spec below
     should really be an xspecref but PUBS HAVE mucked with the xslt template
     that processes those so much I can't figure out how to reference
     with it now --><p>
                  Any non whitespace text in the <emph>EN</emph> content is interpreted
                  as <termref ref="dtimpl-ENXP">ENXP</termref> parts with a null partType. Refer to the the
                  Formatting Name section (2.23.1.4) in Abstract Data
                  Types Specification for full details on interpretation
                  of <emph>EN</emph> content.
               </p><!-- This was supposed to be the generic part. The formally
     correct schema way of doing that would involve defining
     all the special part elements as substitution group
     members for part. But that entails global elements
     is unsafe scoping. So, we don't get into that here.
     
     xs:element name='part' type='ENXP'/ --><div3 id="comp-EN.use"><head>Use : SET&lt;CS&gt;</head><p><emph role="strong">Definition:     </emph>
                     A set of codes advising a system or user which name
                     in a set of like names to select for a given purpose.
                     A name without specific use code might be a default
                     name useful for any purpose, but a name with a specific
                     use code would be preferred for that respective purpose.
                  </p><p>
                  The entity names use codes are defined by the EntityNameUse
                  domain (<tabref ref="domain-EntityNameUse"/>).
               </p><table id="domain-EntityNameUse"><caption>Domain EntityNameUse</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><td>C</td><td>License</td><td>As recorded on a license, record, certificate, etc. (only if different from legal name)</td></tr><tr valign="top"><td>I</td><td>Indigenous/Tribal</td><td>e.g. Chief Red Cloud</td></tr><tr valign="top"><td>L</td><td>Legal</td><td>Known as/conventional/the one you use</td></tr><tr valign="top"><td>P</td><td>pseudonym</td><td>A self asserted name that the person is using or has used.</td></tr><tr valign="top"><td>  A</td><td>Artist/Stage</td><td>Includes writer's pseudonym, stage name, etc</td></tr><tr valign="top"><td>R</td><td>Religious</td><td>e.g. Sister Mary Francis, Brother John</td></tr><tr valign="top"><td>SRCH</td><td>search</td><td>A name intended for use in searching or matching.</td></tr><tr valign="top"><td>  PHON</td><td>phonetic</td><td>A name spelled phonetically.</td></tr><tr valign="top"><td>  SNDX</td><td>Soundex</td><td>A name spelled according to the SoundEx algorithm.</td></tr><tr valign="top"><td>ABC</td><td>Alphabetic</td><td>Alphabetic transcription of name (Japanese: romaji)</td></tr><tr valign="top"><td>SYL</td><td>Syllabic</td><td>Syllabic transcription of name (e.g., Japanese kana, Korean hangul)</td></tr><tr valign="top"><td>IDE</td><td>Ideographic</td><td>Ideographic representation of name (e.g., Japanese kanji, Chinese characters)</td></tr></table><descriptive name="XML Representation"/><p><emph>use</emph> is represented by the XML attribute<emph>use</emph>
                     whose value, if present, must be 0 or more valid values
                     from the EntityNameUse domain
                     (<tabref ref="domain-EntityNameUse"/>)  separated by
                     whitespace.
                  </p></div3><div3 id="comp-EN.validTime"><head>Valid Time : IVL&lt;TS&gt;</head><p><emph role="strong">Definition:     </emph>
                        An interval of time specifying the time during which
                        the name is or was used for the entity. This
                        accomodates the fact that people change names for
                        people, places and things.
                     </p><descriptive name="XML Representation"/><p><emph>validTime</emph> is represented by 0 or more
                     XML elements<emph>validTime</emph> each of which
                     must be a valid
                     <termref ref="dtimpl-IVL">IVL</termref>&lt;<termref ref="dtimpl-TS">TS</termref>&gt;.
                  </p></div3><div3 id="EN-examples"><head>Examples</head><p>
            		See the examples in
            		<specref ref="PN-examples"/>, <specref ref="ON-examples"/>
            		and <specref ref="TN-examples"/>.
            	</p></div3></div2><!-- PERSON NAME --><div2 id="dtimpl-PN"><head><anchor id="PN"/>Person Name (PN) specializes <termref ref="dtimpl-EN">EN</termref></head><p><emph role="strong">Definition:     </emph>
            A name for a person. A sequence of name parts, such as
            given name or family name, prefix, suffix, etc. PN differs
            from EN because the qualifier type cannot include LS
            (Legal Status).
         </p><table id="dtimpl-PN-comp-summary"><caption>Components of
      Person Name</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="comp-PN.use">use</termref></td><td>SET&lt;CS&gt;</td><td>
                     A set of codes advising a system or user which name
                     in a set of like names to select for a given purpose.
                     A name without specific use code might be a default
                     name useful for any purpose, but a name with a specific
                     use code would be preferred for that respective purpose.
                  </td></tr><tr><td><termref ref="comp-PN.validTime">validTime</termref></td><td>IVL&lt;TS&gt;</td><td>
                        An interval of time specifying the time during which
                        the name is or was used for the entity. This
                        accomodates the fact that people change names for
                        people, places and things.
                     </td></tr></tbody></table><descriptive name="XML Representation"/><p><emph>PN</emph> is represented by an XML element
                  whose name is determined by the context in which it is
                  used. The element has attributes and child elements as
                  described in the template and the sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type PN --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   use = CS*
   &gt;
   <emph>Content</emph>: ( (delimiter | family | given | prefix | suffix | #PCDATA)*, validTime )
&lt;/x&gt;
</exhibit><p>
                  Any non whitespace text in the <emph>PN</emph> content is interpreted
                  as <termref ref="dtimpl-ENXP">ENXP</termref> parts with a null partType. Refer to the the
                  Formatting Name section (2.23.1.4) in Abstract Data
                  Types Specification for full details on interpretation
                  of <emph>PN</emph> content.
               </p><div3 id="comp-PN.use"><head><anchor id=""/>Use : SET&lt;CS&gt; (inherited from <termref ref="dtimpl-EN">EN</termref>)</head><p><emph role="strong">Definition:     </emph>
                     A set of codes advising a system or user which name
                     in a set of like names to select for a given purpose.
                     A name without specific use code might be a default
                     name useful for any purpose, but a name with a specific
                     use code would be preferred for that respective purpose.
                  </p></div3><descriptive name="XML Representation"/><p><emph>use</emph> is represented by the XML attribute<emph>use</emph>
                     whose value, if present, must be 0 or more valid values
                     from the EntityNameUse domain (<tabref ref="domain-EntityNameUse"/>)
                     separated by whitespace.
                  </p><div3 id="comp-PN.validTime"><head><anchor id=""/>Valid Time : IVL&lt;TS&gt; (inherited from <termref ref="dtimpl-EN">EN</termref>)</head><p><emph role="strong">Definition:     </emph>
                        An interval of time specifying the time during which
                        the name is or was used for the entity. This
                        accomodates the fact that people change names for
                        people, places and things.
                     </p></div3><descriptive name="XML Representation"/><p><emph>validTime</emph> is represented by 0 or more
                     XML elements<emph>validTime</emph>	each of which must
                     be a valid
                     <termref ref="dtimpl-IVL">IVL</termref>&lt;<termref ref="dtimpl-TS">TS</termref>&gt;.
                  </p><div3 id="PN-examples"><head>Examples</head><p>
						A very simple encoding of  "Adam A. Everyman" would be:
					</p><exhibit role="example" verbatim="yes">
&lt;name&gt;
   &lt;given&gt;Adam&lt;/given&gt;
   &lt;given&gt;A.&lt;/given&gt;
   &lt;family&gt;Everyman&lt;/family&gt;
&lt;/name&gt;</exhibit><p>
						None of the special qualifiers need to be mentioned if they are
						unknown or irrelevant. The next example shows extensive use of
						multiple given names, prefixes, suffixes, for academic degrees,
						nobility titles, <emph>vorvoegsels</emph> ("van"), and professional
						designations.
					</p><exhibit role="example" verbatim="yes">
&lt;name&gt;
   &lt;prefix qualifier='AC'&gt;Dr. phil. &lt;/prefix&gt;
   &lt;given&gt;Regina&lt;/given&gt;
   &lt;given&gt;Johanna&lt;/given&gt;
   &lt;given&gt;Maria&lt;/given&gt;
   &lt;prefix qualifier='NB'&gt;Gr&amp;auml;fin &lt;/prefix&gt;
   &lt;family qualifier='BR'&gt;Hochheim&lt;/family&gt;-&lt;family qualifier='SP'&gt;Weilenfels&lt;/family&gt;
   &lt;suffix qualifier='PR'&gt;NCFSA&lt;/suffix&gt;
&lt;/name&gt;</exhibit><p>
						The following example shows a Japanese name in the three forms:
						ideographic (Kanji), syllabic (Hiragana), and alphabetic (Romaji).
					</p><exhibit role="example" verbatim="yes">
&lt;name use='IDE'&gt;
   &lt;family&gt;&#26408;&#26449;&lt;/family&gt;
   &lt;given&gt;&#36947;&#30007;&lt;/given&gt;
&lt;/name&gt;
&lt;name use="SYL"&gt;
   &lt;family&gt;&#12365;&#12416;&#12425;&lt;/family&gt;
   &lt;given&gt;&#12415;&#12385;&#12362;&lt;/given&gt;
&lt;/name&gt;
&lt;name use="ABC"&gt;
   &lt;family&gt;KIMURA&lt;/family&gt;
   &lt;given&gt;MICHIO&lt;/given&gt;
&lt;/name&gt;</exhibit></div3></div2><!-- ORGANIZATION NAME --><div2 id="dtimpl-ON"><head><anchor id="ON"/>Organization Name (ON) specializes <termref ref="dtimpl-EN">EN</termref></head><p><emph role="strong">Definition:     </emph>
            A name for an organization. A sequence of name parts.
         </p><table id="dtimpl-ON-comp-summary"><caption>Components of
      Organization Name</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="comp-ON.use">use</termref></td><td>SET&lt;CS&gt;</td><td>
                     A set of codes advising a system or user which name
                     in a set of like names to select for a given purpose.
                     A name without specific use code might be a default
                     name useful for any purpose, but a name with a specific
                     use code would be preferred for that respective purpose.
                  </td></tr><tr><td><termref ref="comp-ON.validTime">validTime</termref></td><td>IVL&lt;TS&gt;</td><td>
                        An interval of time specifying the time during which
                        the name is or was used for the entity. This
                        accomodates the fact that people change names for
                        people, places and things.
                     </td></tr></tbody></table><descriptive name="XML Representation"/><p><emph>ON</emph> is represented by an XML element
                  whose name is determined by the context in which it
                  is used. The element has attributes and child elements
                  as described in the template and the sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type ON --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   use = CS*
   &gt;
   <emph>Content</emph>: ( (delimiter | prefix | suffix | #PCDATA)*, validTime )
&lt;/x&gt;
</exhibit><!-- pvb: 20050715: the section reference to the abstract spec below
     should really be an xspecref but pubs have mucked with the xslt template
     that processes those so much I can't figure out how to reference
     with it now --><p>
                  Any non whitespace text in the <emph>ON</emph> content is interpreted
                  as <termref ref="dtimpl-ENXP">ENXP</termref> parts with a null partType. Refer to the the Formatting
                  Name section (2.23.1.4) in Abstract Data Types Specification for
                  full details on interpretation of <emph>ON</emph> content.
               </p><div3 id="comp-ON.use"><head><anchor id=""/>Use : SET&lt;CS&gt; (inherited from <termref ref="dtimpl-EN">EN</termref>)</head><p><emph role="strong">Definition:     </emph>
                     A set of codes advising a system or user which name
                     in a set of like names to select for a given purpose.
                     A name without specific use code might be a default
                     name useful for any purpose, but a name with a specific
                     use code would be preferred for that respective purpose.
                  </p></div3><descriptive name="XML Representation"/><p><emph>use</emph> is represented by the XML attribute<emph>use</emph>
                     whose value, if present, must be 0 or more valid
                     values from the EntityNameUse domain
                     (<tabref ref="domain-EntityNameUse"/>)
                     separated by whitespace.
                  </p><div3 id="comp-ON.validTime"><head><anchor id=""/>Valid Time : IVL&lt;TS&gt; (inherited from <termref ref="dtimpl-EN">EN</termref>)</head><p><emph role="strong">Definition:     </emph>
                        An interval of time specifying the time during which
                        the name is or was used for the entity. This
                        accomodates the fact that people change names for
                        people, places and things.
                     </p></div3><descriptive name="XML Representation"/><p><emph>validTime</emph> is represented by 0 or more
                     XML elements<emph>validTime</emph> each of which must
                     be a valid
                     <termref ref="dtimpl-IVL">IVL</termref>&lt;<termref ref="dtimpl-TS">TS</termref>&gt;.
                  </p><div3 id="ON-examples"><head>Examples</head><p>
                  The following is the name of HL7 with the legal status <code>"Inc."</code>
                  as a distinguished name part:
               </p><exhibit role="example" verbatim="yes">
&lt;name&gt;Health Level Seven, &lt;suffix qualifier='LS'&gt;Inc.&lt;/suffix&gt;&lt;/name&gt;</exhibit></div3></div2><!-- TRIVIAL NAME --><div2 id="dtimpl-TN"><head><anchor id="TN"/>Trivial Name (TN) specializes <termref ref="dtimpl-EN">EN</termref></head><p><emph role="strong">Definition:     </emph>
            A restriction of entity name that is effectively a simple string used
            for a simple name for things and places.
         </p><table id="dtimpl-TN-comp-summary"><caption>Components of
      Trivial Name</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="comp-TN.use">use</termref></td><td>SET&lt;CS&gt;</td><td>
                     A set of codes advising a system or user which name
                     in a set of like names to select for a given purpose.
                     A name without specific use code might be a default
                     name useful for any purpose, but a name with a specific
                     use code would be preferred for that respective purpose.
                  </td></tr><tr><td><termref ref="comp-TN.validTime">validTime</termref></td><td>IVL&lt;TS&gt;</td><td>
                        An interval of time specifying the time during which
                        the name is or was used for the entity. This
                        accomodates the fact that people change names for
                        people, places and things.
                     </td></tr></tbody></table><descriptive name="XML Representation"/><p><emph>TN</emph> is represented by an XML element
                  whose name is determined by the context in which it is
                  used. The element has attributes and child elements as
                  described in the template and the sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type TN --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   use = CS*
   &gt;
   <emph>Content</emph>: ( #PCDATA, validTime )
&lt;/x&gt;
</exhibit><div3 id="comp-TN.use"><head><anchor id=""/>Use : SET&lt;CS&gt; (inherited from <termref ref="dtimpl-EN">EN</termref>)</head><p><emph role="strong">Definition:     </emph>
                     A set of codes advising a system or user which name
                     in a set of like names to select for a given purpose.
                     A name without specific use code might be a default
                     name useful for any purpose, but a name with a specific
                     use code would be preferred for that respective purpose.
                  </p></div3><descriptive name="XML Representation"/><p><emph>use</emph> is represented by the XML attribute<emph>use</emph>
                     whose value, if present, must be 0 or more valid values
                     from the EntityNameUse domain
                     (<tabref ref="domain-EntityNameUse"/>)
                     separated by whitespace.
                  </p><div3 id="comp-TN.validTime"><head><anchor id=""/>Valid Time : IVL&lt;TS&gt; (inherited from <termref ref="dtimpl-EN">EN</termref>)</head><p><emph role="strong">Definition:     </emph>
                        An interval of time specifying the time during which
                        the name is or was used for the entity. This
                        accomodates the fact that people change names for
                        people, places and things.
                     </p></div3><descriptive name="XML Representation"/><p><emph>validTime</emph> is represented by 0 or more
                     XML elements<emph>validTime</emph>	each of which
                     must be a valid
                     <termref ref="dtimpl-IVL">IVL</termref>&lt;<termref ref="dtimpl-TS">TS</termref>&gt;.
                  </p><div3 id="TN-examples"><head>Examples</head><p>
                  The following is the organization name, "Health Level Seven,
                  Inc." in a simple string form:
               </p><exhibit role="example" verbatim="yes">
&lt;name&gt;Health Level Seven, Inc.&lt;/name&gt;</exhibit></div3></div2><!-- ********************************************** 
     QUANTITY
     ********************************************** --><div2 id="dtimpl-QTY"><head><anchor id="QTY"/>Quantity (QTY)</head><p><emph role="strong">Definition:     </emph><emph>QTY</emph> is an abstract generalization
            for all data types (1) whose value set has an order
            relation (less-or-equal) and (2) where difference is
            defined in all of the data type's totally ordered value
            subsets.  The quantity type abstraction is needed in
            defining certain other types, such as the interval and
            the probability distribution.
         </p><p>
               The Data Types Abstract Specification defines a
               <emph>diff</emph> property of a data <emph role="strong">type</emph>
               (not data value) that is the data type of the difference
               value between two data values of the quantity type. By
               default the <emph>diff</emph> property equals the same
               data type, but it may be overridden by a specialization
               of QTY.  For instance, the difference between two
               <termref ref="dtimpl-TS">TS</termref> values has the data type
               <termref ref="dtimpl-PQ">PQ</termref> (in the dimension of elapsed
               time.)
            </p><descriptive name="XML Representation"/><p><emph>QTY</emph> is an abstract data type and cannot
                  be used directly in the XML instance, so it has no XML
                  representation. Instead, a specific descendent type
                  must be used.
               </p></div2><!-- INTEGER --><div2 id="dtimpl-INT"><head><anchor id="INT"/>Integer Number (INT) specializes <termref ref="dtimpl-QTY">QTY</termref></head><p><emph role="strong">Definition:     </emph>
            Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise
            numbers that are results of counting and enumerating.
            Integer numbers are discrete, the set of integers is
            infinite but countable.  No arbitrary limit is imposed on
            the range of integer numbers. Two NULL flavors are
            defined for the positive and negative infinity.
         </p><descriptive name="XML Representation"/><p><emph>INT</emph> is represented by both Element and
                  Attribute forms. In the Element form, the name of the
                  element is determined by the context in which it
                  is used. The element has attributes as described in the
                  template and the sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type INT --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   value = xs:integer
   /&gt;
</exhibit><p>
                  XML instances may carry either a nullFlavor or a value,
                  but not both.
               </p><p>
                  The Attribute form of <emph>INT</emph> is used when properties of
                  other data types have type <emph>INT</emph>.  The name of the attribute
                  is determined by the context in which it is used.
                  The attribute value is the integer value.
               </p></div2><!-- REAL --><div2 id="dtimpl-REAL"><head><anchor id="REAL"/>Real Number (REAL) specializes <termref ref="dtimpl-QTY">QTY</termref></head><p><emph role="strong">Definition:     </emph>
            Fractional numbers. Typically used whenever quantities
            are measured, estimated, or computed from other real
            numbers.  The typical representation is decimal, where
            the number of significant decimal digits is known as the
            precision. Real numbers are needed beyond integers
            whenever quantities of the real world are measured,
            estimated, or computed from other real numbers. The term
            "Real number" in this specification is used to mean
            that fractional values are covered without necessarily
            implying the full set of the mathematical real numbers.
         </p><descriptive name="XML Representation"/><p><emph>REAL</emph> is represented by both Element and
                  Attribute forms. In the Element form, the name of the
                  element is determined by the context in which it is used.
                  The element has attributes as described in the template
                  and the sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type REAL --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   value = Union of (xs:decimal xs:double)
   /&gt;
</exhibit><p>
                  XML instances may carry either a nullFlavor or a value,
                  but not both.
               </p><p>
                  The Attribute form of <emph>REAL</emph> is used when properties of
                  other data types have type <emph>REAL</emph>.  The name of the attribute
                  is determined by the context in which it is used. The
                  attribute value is the real value.
               </p><p>
                  For both the element and Attribute form, the value of the
                  <emph>REAL</emph> as represented must conform to either of the XML Schema
                  data types decimal or double.
               </p></div2><div2 id="dtimpl-PQ"><head><anchor id="PQ"/>Physical Quantity (PQ) specializes <termref ref="dtimpl-QTY">QTY</termref></head><p><emph role="strong">Definition:     </emph>
            A dimensioned quantity expressing the result of a
            measurement act.
        </p><table id="dtimpl-PQ-comp-summary"><caption>Components of
      Physical Quantity</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">value</termref></td><td><termref ref="dtimpl-REAL">REAL</termref></td><td>
                     The magnitude of the quantity measured in terms of
                     the unit.
                  </td></tr><tr><td><termref ref="">unit</termref></td><td><termref ref="dtimpl-CS">CS</termref></td><td>
                     The unit of measure specified in the Unified Code for
                     Units of Measure (UCUM)
                     [<loc href="http://aurora.rg.iupui.edu/UCUM" xlink-form="simple" show="embed" actuate="auto"/>].
                  </td></tr><tr><td><termref ref="">translation</termref></td><td><termref ref="dtimpl-PQR">PQR</termref></td><td>
                        An alternative representation of the same physical
                        quantity expressed in a different unit, of a different
                        unit code system and possibly with a different value.
                     </td></tr></tbody></table><descriptive name="XML Representation"/><p><emph>PQ</emph> is represented by an XML element whose
                  name is determined by the context in which it is used. The
                  element has attributes and child elements as described in
                  the template and the sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type PQ --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   value = REAL
   unit = CS
   &gt;
   <emph>Content</emph>: ( translation* )
&lt;/x&gt;
</exhibit><p>
                  XML instances may carry either a nullFlavor or a value, but
                  not both. The unit attribute must be populated if the value
                  attribute is present, and cannot be present when the value
                  attribute is not present.
               </p><!-- FIXME: this, again will be a problem with making defaults
     for unit and the null value.
--><div3 id="comp-PQ.value"><head>Value : <termref ref="dtimpl-REAL">REAL</termref></head><p><emph role="strong">Definition:     </emph>
                     The magnitude of the quantity measured in terms of
                     the unit.
                  </p><descriptive name="XML Representation"/><p><emph>value</emph> is represented by the XML attribute<emph>value</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-REAL">REAL</termref>.
                  </p></div3><!-- FIXME: the UCUM is an external coding system and the
	 vocabulary tables incomplete. I cannot refer to the
	 HL7 tables.... --><div3 id="comp-PQ.unit"><head>Unit of Measure : <termref ref="dtimpl-CS">CS</termref></head><p><emph role="strong">Definition:     </emph>
                     The unit of measure specified in the Unified Code for
                     Units of Measure (UCUM)
                     [<loc href="http://aurora.rg.iupui.edu/UCUM" xlink-form="simple" show="embed" actuate="auto"/>].
                  </p><p>
                  More detail on the Unified Code for Units of Measure,
                  and example tables of units commonly seen in practice
                  with HL7 are provided in an appendix of the Data Types
                  Abstract Specification.
               </p><p>
                  The default unit of measure is <emph>1</emph>
                  (the "unity").
               </p><descriptive name="XML Representation"/><p><emph>unit</emph> is represented by the XML attribute<emph>unit</emph>
                     whose value, if present, must be a valid unit of
                     measure as defined in UCUM
                     [<loc href="http://aurora.rg.iupui.edu/UCUM" xlink-form="simple" show="embed" actuate="auto"/>].
                  </p></div3><div3 id="comp-PQ.translation"><head>Translation : <termref ref="dtimpl-PQR">PQR</termref></head><p><emph role="strong">Definition:     </emph>
                        An alternative representation of the same physical
                        quantity expressed in a different unit, of a different
                        unit code system and possibly with a different value.
                     </p><descriptive name="XML Representation"/><p><emph>translation</emph> is represented by 0 or more
                     XML elements<emph>translation</emph>
                     each of which must be a valid
                     <termref ref="dtimpl-PQR">PQR</termref>.
                  </p></div3><div3 id="PQ-examples"><head>Examples</head><p>
                  This example shows a value of 22.35 millimoles per milliliter.
               </p><exhibit role="example" verbatim="yes">
&lt;value value='22.35' unit='mmol/mL'/&gt;</exhibit><p>
                  The final example shows a value of 1.77 meters as well as
                  a <termref ref="comp-PQ.translation">translation</termref> into inches.
               </p><exhibit role="example" verbatim="yes">
&lt;value value='1.77' unit='m'&gt;
   &lt;translation value='69.7' code='[in_I]'
      codeSystem='2.16.840.1.113883.19.6.8' codeSystemName='UCUM'/&gt;
&lt;/value&gt;</exhibit></div3></div2><div2 id="dtimpl-PQR"><head><anchor id="PQR"/>Physical Quantity Representation (PQR) specializes <termref ref="dtimpl-CV">CV</termref></head><p><emph role="strong">Definition:     </emph>
            A representation of a physical quantity in a unit from
            any code system. Used to show alternative representation
            for a physical quantity.
         </p><table id="dtimpl-PQR-comp-summary"><caption>Components of
      Physical Quantity Representation</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">value</termref></td><td><termref ref="dtimpl-REAL">REAL</termref></td><td>
                     The magnitude of the measurement value in terms of
                     the unit specified in the code.
                  </td></tr><tr><td><termref ref="comp-PQR.code">code</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     The plain code symbol defined by the code system.
                     For example, "784.0" is the code symbol of the ICD-9
                     code "784.0" for headache.
                  </td></tr><tr><td><termref ref="comp-PQR.codeSystem">codeSystem</termref></td><td>UID</td><td>
                     Specifies the code system that defines the code.
                  </td></tr><tr><td><termref ref="comp-PQR.codeSystemName">codeSystemName</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     A common name of the coding system.
                  </td></tr><tr><td><termref ref="comp-PQR.codeSystemVersion">codeSystemVersion</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     If applicable, a version descriptor defined
                     specifically for the given code system.
                  </td></tr><tr><td><termref ref="comp-PQR.displayName">displayName</termref></td><td><termref ref="dtimpl-ST">ST</termref></td><td>
                     A name or title for the code, under which the sending
                     system shows the code value to its users.
                  </td></tr><tr><td><termref ref="comp-PQR.originalText">originalText</termref></td><td><termref ref="dtimpl-ED">ED</termref></td><td>
                        The text or phrase used as the basis for the coding.
                     </td></tr></tbody></table><p>
               This is an extension of the coded value data type.
            </p><descriptive name="XML Representation"/><p><emph>PQR</emph> is represented by an XML element
                  whose name is determined by the context in which it is
                  used. The element has attributes and child elements as
                  described in the template and the sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type PQR --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   code = ST
   codeSystem = UID
   codeSystemName = ST
   codeSystemVersion = ST
   displayName = ST
   value = REAL
   &gt;
   <emph>Content</emph>: ( originalText )
&lt;/x&gt;
</exhibit><div3 id="comp-PQR.value"><head>Value : <termref ref="dtimpl-REAL">REAL</termref></head><p><emph role="strong">Definition:     </emph>
                     The magnitude of the measurement value in terms of
                     the unit specified in the code.
                  </p><descriptive name="XML Representation"/><p><emph>value</emph> is represented by the XML attribute<emph>value</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-REAL">REAL</termref>.
                  </p></div3><!--
		 		 		 		 <comp id="comp-PQR.code" base="comp-CV.code"/>
		 		 		 		 <comp id="comp-PQR.codeSystem" base="comp-CV.codeSystem"/>
		 		 		 		 <comp id="comp-PQR.codeSystemName" base="comp-CV.codeSystemName"/>
		 		 		 		 <comp id="comp-PQR.codeSystemVersion" base="comp-CV.codeSystemVersion"/>
		 		 		 		 <comp id="comp-PQR.displayName" base="comp-CV.displayName"/>
		 		 		 		 <comp id="comp-PQR.originalText" base="comp-CV.originalText"/>
  --><div3 id="comp-PQR.code"><head><anchor id=""/>Code : <termref ref="dtimpl-ST">ST</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     The plain code symbol defined by the code system.
                     For example, "784.0" is the code symbol of the ICD-9
                     code "784.0" for headache.
                  </p></div3><descriptive name="XML Representation"/><p><emph>code</emph> is represented by the XML attribute<emph>code</emph>
                     whose value, if present, must be a valid
                     <loc href="http://www.w3.org/TR/xmlschema-2/#token" target="schema-rec" xlink-form="simple" show="embed" actuate="auto">xs:token</loc>
                     with no internal whitespace.
                  </p><div3 id="comp-PQR.codeSystem"><head><anchor id=""/>Code System : UID (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     Specifies the code system that defines the code.
                  </p></div3><descriptive name="XML Representation"/><p><emph>codeSystem</emph> is represented by the XML attribute<emph>codeSystem</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-UID">UID</termref>.
                  </p><div3 id="comp-PQR.codeSystemName"><head><anchor id=""/>Code System Name : <termref ref="dtimpl-ST">ST</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     A common name of the coding system.
                  </p></div3><descriptive name="XML Representation"/><p><emph>codeSystemName</emph> is represented by the XML attribute<emph>codeSystem</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-ST">ST</termref>.
                  </p><div3 id="comp-PQR.codeSystemVersion"><head><anchor id=""/>Code System Version : <termref ref="dtimpl-ST">ST</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     If applicable, a version descriptor defined
                     specifically for the given code system.
                  </p></div3><descriptive name="XML Representation"/><p><emph>codeSystemVersion</emph> is represented by the XML attribute<emph>codeSystemVersion</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-ST">ST</termref>.
                  </p><div3 id="comp-PQR.displayName"><head><anchor id=""/>Display Name : <termref ref="dtimpl-ST">ST</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                     A name or title for the code, under which the sending
                     system shows the code value to its users.
                  </p></div3><descriptive name="XML Representation"/><p><emph>displayName</emph> is represented by the XML attribute<emph>displayName</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-ST">ST</termref>.
                  </p><div3 id="comp-PQR.originalText"><head><anchor id=""/>Original Text : <termref ref="dtimpl-ED">ED</termref> (inherited from <termref ref="dtimpl-CD">CD</termref>)</head><p><emph role="strong">Definition:     </emph>
                        The text or phrase used as the basis for the coding.
                     </p></div3><descriptive name="XML Representation"/><p><emph>originalText</emph> is represented by the XML element<emph>originalText</emph>
                     which, if present, must be a valid <termref ref="dtimpl-ED">ED</termref>.
                  </p><!--
            <comp id="comp-PQR.translation" base="comp-CV.translation" role="exclude">
               <xmlrep>
                  &standard-exclude-text;
               </xmlrep>
            </comp>
            --><div3 id="PQR-examples"><head>Examples</head><p>
            		See the example using <termref ref="comp-PQ.translation">PQ.translation</termref> in
            		<specref ref="PQ-examples"/>.
            	</p></div3></div2><div2 id="dtimpl-MO"><head><anchor id="MO"/>Monetary Amount (MO) specializes <termref ref="dtimpl-QTY">QTY</termref></head><p><emph role="strong">Definition:     </emph>
            A monetary amount is a quantity expressing the amount of
            money in some currency. Currencies are the units in which
            monetary amounts are denominated in different economic
            regions. While the monetary amount is a single kind of
            quantity (money) the exchange rates between the different
            units are variable.  This is the principle difference
            between physical quantity and monetary amounts, and the
            reason why currency units are not physical units.
         </p><table id="dtimpl-MO-comp-summary"><caption>Components of
      Monetary Amount</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">value</termref></td><td><termref ref="dtimpl-REAL">REAL</termref></td><td>
                     The magnitude of the monetary amount in terms of the
                     currency unit.
                  </td></tr><tr><td><termref ref="">currency</termref></td><td><termref ref="dtimpl-CS">CS</termref></td><td>
                     The currency unit as defined in ISO 4217.
                  </td></tr></tbody></table><descriptive name="XML Representation"/><p><emph>MO</emph> is represented by an XML element whose
                  name is determined by the context in which it is used.
                  The element has attributes as described in the template
                  and the sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type MO --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   value = REAL
   currency = CS
   /&gt;
</exhibit><div3 id="comp-MO.value"><head>Value : <termref ref="dtimpl-REAL">REAL</termref></head><p><emph role="strong">Definition:     </emph>
                     The magnitude of the monetary amount in terms of the
                     currency unit.
                  </p><descriptive name="XML Representation"/><p><emph>value</emph> is represented by the XML attribute<emph>value</emph>
                     whose value, if present, must be a valid <termref ref="dtimpl-REAL">REAL</termref>.
                  </p></div3><div3 id="comp-MO.currency"><head>Currency : <termref ref="dtimpl-CS">CS</termref></head><p><emph role="strong">Definition:     </emph>
                     The currency unit as defined in ISO 4217.
                  </p><table id="domain-Currency"><caption>Domain Currency</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><td>ARS</td><td>Argentine Peso</td><td>Argentine Peso, monetary currency of Argentina</td></tr><tr valign="top"><td>AUD</td><td>Australian Dollar</td><td>Australian Dollar, monetary currency of Australia</td></tr><tr valign="top"><td>BRL</td><td>Brazilian Real</td><td>Brazilian Real, monetary currency of Brazil</td></tr><tr valign="top"><td>CAD</td><td>Canadian Dollar</td><td>Canadian Dollar, monetary currency of Canada</td></tr><tr valign="top"><td>CHF</td><td>Swiss Franc</td><td>Swiss Franc, monetary currency of Switzerland</td></tr><tr valign="top"><td>CLF</td><td>Unidades de Formento</td><td>Unidades de Formento, monetary currency of Chile</td></tr><tr valign="top"><td>CNY</td><td>Yuan Renminbi</td><td>Yuan Renminbi, monetary currency of China</td></tr><tr valign="top"><td>DEM</td><td>Deutsche Mark</td><td>Deutsche Mark, monetary currency of Germany</td></tr><tr valign="top"><td>ESP</td><td>Spanish Peseta</td><td>Spanish Peseta, monetary currency of Spain</td></tr><tr valign="top"><td>EUR</td><td>Euro</td><td>Euro, monetary currency of European Union</td></tr><tr valign="top"><td>FIM</td><td>Markka</td><td>Markka, monetary currency of Finland</td></tr><tr valign="top"><td>FRF</td><td>French Franc</td><td>French Franc, monetary currency of France</td></tr><tr valign="top"><td>GBP</td><td>Pound Sterling</td><td>Pound Sterling, monetary currency of United Kingdom</td></tr><tr valign="top"><td>ILS</td><td>Shekel</td><td>Shekel, monetary currency of Israel</td></tr><tr valign="top"><td>INR</td><td>Indian Rupee</td><td>Indian Rupee, monetary currency of India</td></tr><tr valign="top"><td>JPY</td><td>Yen</td><td>Yen, monetary currency of Japan</td></tr><tr valign="top"><td>KRW</td><td>Won</td><td>Won, monetary currency of Korea (South)</td></tr><tr valign="top"><td>MXN</td><td>Mexican Nuevo Peso</td><td>Mexican Nuevo Peso, monetary currency of Mexico</td></tr><tr valign="top"><td>NLG</td><td>Netherlands Guilder</td><td>Netherlands Guilder, monetary currency of Netherlands</td></tr><tr valign="top"><td>NZD</td><td>New Zealand Dollar</td><td>New Zealand Dollar, monetary currency of New Zealand</td></tr><tr valign="top"><td>PHP</td><td>Philippine Peso</td><td>Philippine Peso, monetary currency of Philippines</td></tr><tr valign="top"><td>RUR</td><td>Russian Ruble</td><td>Russian Ruble, monetary currency of Russian Federation</td></tr><tr valign="top"><td>THB</td><td>Baht</td><td>Baht, monetary currency of Thailand</td></tr><tr valign="top"><td>TRL</td><td>Lira</td><td>Lira, monetary currency of Turkey</td></tr><tr valign="top"><td>TWD</td><td>Taiwan Dollar</td><td>Taiwan Dollar, monetary currency of Taiwan</td></tr><tr valign="top"><td>USD</td><td>US Dollar</td><td>US Dollar, monetary currency of United States</td></tr><tr valign="top"><td>ZAR</td><td>Rand</td><td>Rand, monetary currency of South Africa</td></tr></table><p>
                  This table only shows a representative subset of the
                  codes defined by ISO 4217. All codes from ISO 4127 are 
                  valid for this attribute.
               </p><descriptive name="XML Representation"/><p><emph>currency</emph> is represented by the XML attribute<emph>value</emph>
                     whose value, if present, must be a valid currency code
                     as defined by ISO 4217.
                  </p></div3><div3 id="MO-examples"><head>Examples</head><p>
                  This example shows an amount of 10 Euros.
               </p><exhibit role="example" verbatim="yes">
&lt;amt value='10' currency='EUR'/&gt;</exhibit></div3></div2><!-- RATIO --><div2 id="dtimpl-RTO"><head><anchor id="RTO"/>Ratio (RTO) specializes <termref ref="dtimpl-QTY">QTY</termref></head><p><emph role="strong">Definition:     </emph>
            A quantity constructed as the quotient of a numerator
            quantity divided by a denominator quantity. Common
            factors in the numerator and denominator are not
            automatically cancelled out.  <emph>RTO</emph> supports titers
            (e.g., "1:128") and other quantities produced by
            laboratories that truly represent ratios. Ratios are
            not simply "structured numerics", particularly blood
            pressure measurements (e.g. "120/60") are not ratios.
            In many cases <termref ref="dtimpl-REAL">REAL</termref> should be used instead
            of <emph>RTO</emph>.
         </p><note><p> 
                  This data type is not defined to generally represent
                  rational numbers. It is used only if common factors in
                  numerator and denominator are not supposed to cancel out.
                  This is only rarely the case. For observation values,
                  ratios occur almost exclusively with titers.
               </p></note><table id="dtimpl-RTO-comp-summary"><caption>Components of
      Ratio</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">numerator</termref></td><td><termref ref="dtimpl-QTY">QTY</termref></td><td>
                        The quantity that is being divided in the ratio.  The
                        default is the integer number <emph>1</emph> (one).
                     </td></tr><tr><td><termref ref="">denominator</termref></td><td><termref ref="dtimpl-QTY">QTY</termref></td><td>
                        The quantity that devides the numerator in the ratio.
                        The default is the integer number <emph>1</emph> (one).
                        The denominator must not be zero.
                     </td></tr></tbody></table><p>
               The default value for both numerator and denominator is
               the integer number <emph>1</emph> (one.) The denominator
               may not be zero.
            </p><note><p>
                  This data type is defined as a generic data type but
                  discussed in the context of the other quantity-related
                  data types. The reason for defining <emph>RTO</emph> as a generic
                  data type is so that it can be constrained precisely
                  as to what the numerator and denominator types should be.
               </p></note><descriptive name="XML Representation"/><p><emph>RTO</emph> is represented by an XML element whose
                  name is determined by the context in which it is used.
                  The element has attributes as described in the template
                  and the sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type RTO --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   &gt;
   <emph>Content</emph>: ( numerator, denominator )
&lt;/x&gt;
</exhibit><p>
                  Both numerator and denominator are required for a ratio
                  or else it has a NULL value. (Note that both numerator
                  and denominator have <emph>1</emph> (one) as their
                  default.)
               </p><p>
                  XML instances must use the
                  <loc href="http://www.w3.org/TR/xmlschema-1/#xsi_type" target="schema-rec" xlink-form="simple" show="embed" actuate="auto">xsi:type schema type assertion</loc>
                  mechanism to specify the particular restriction of <termref ref="dtimpl-QTY">QTY</termref>
                  being used for numerator and denominator respectively.
                  The types may be asserted on the numerator or denominator
                  directly (as in <exref ref="rto1"/> and <exref ref="rto3"/>),
                  or the combined type may be asserted on the element
                  representing the <emph>RTO</emph> value (as in <exref ref="rto2"/>).
                  In the later case, the type name to be asserted follows
                  the rules described in
                  <specref ref="Use-of-attributes-from-XML-specifications"/>.
               </p><div3 id="comp-RTO.numerator"><head>Numerator : <termref ref="dtimpl-QTY">QTY</termref></head><p><emph role="strong">Definition:     </emph>
                        The quantity that is being divided in the ratio.  The
                        default is the integer number <emph>1</emph> (one).
                     </p><descriptive name="XML Representation"/><p><emph>numerator</emph> is represented by the
                     XML element<emph>numerator</emph> which, if present, must
                     be valid instance of a descendant of
                     <termref ref="dtimpl-QTY">QTY</termref>.
                  </p></div3><div3 id="comp-RTO.denominator"><head>Denominator : <termref ref="dtimpl-QTY">QTY</termref></head><p><emph role="strong">Definition:     </emph>
                        The quantity that devides the numerator in the ratio.
                        The default is the integer number <emph>1</emph> (one).
                        The denominator must not be zero.
                     </p><descriptive name="XML Representation"/><p><emph>denominator</emph> is represented by the
                     XML element<emph>denominator</emph> which, if present,
                     must be valid instance of a descendant
                     of <termref ref="dtimpl-QTY">QTY</termref>.
                  </p></div3><div3 id="RTO-examples"><head>Examples</head><p>
                  The first example shows a ratio of <termref ref="dtimpl-INT">INT</termref>s, where the
                  types of the <termref ref="comp-RTO.numerator">numerator</termref> and
                  <termref ref="comp-RTO.demoninator">demoninator</termref> are asserted
                  individually.
               </p><exhibit role="example" verbatim="yes" id="rto1">
&lt;unitQuanity&gt;
   &lt;numerator value='1' xsi:type='INT'/&gt;
   &lt;denominator value='64' xsi:type='INT'/&gt;
&lt;/unitQuanity&gt;</exhibit><p>
                  The second example shows a ratio of <termref ref="dtimpl-MO">MO</termref>
                  and <termref ref="dtimpl-PQ">PQ</termref> where the
                  types of the <termref ref="comp-RTO.numerator">numerator</termref> and
                  <termref ref="comp-RTO.demoninator">demoninator</termref> are asserted on
                  the element representing the <emph>RTO</emph> value.
               </p><exhibit role="example" verbatim="yes" id="rto2">
&lt;unitPriceAmount xsi:type='RTO_MO_PQ'&gt;
   &lt;numerator value='1.15' currency='USD'/&gt;
   &lt;denominator value='1' unit='[gal_us]'/&gt;
&lt;/unitPriceAmount&gt;</exhibit><p>
                  The final example shows a ratio of <termref ref="dtimpl-PQ">PQ</termref>s, where the
                  types of the <termref ref="comp-RTO.numerator">numerator</termref> and
                  <termref ref="comp-RTO.demoninator">demoninator</termref> are asserted
                  individually.
               </p><exhibit role="example" verbatim="yes" id="rto3">
&lt;maxDoseQuantity&gt;
   &lt;numerator xsi:type='PQ' value='25' unit='mg'/&gt;
   &lt;denominator xsi:type='PQ' value='5' unit='mL'/&gt;
&lt;/maxDoseQuantity&gt;</exhibit></div3></div2><!-- TS --><div2 id="dtimpl-TS"><head><anchor id="TS"/>Point in Time (TS) specializes <termref ref="dtimpl-QTY">QTY</termref></head><p><emph role="strong">Definition:     </emph>
            A quantity specifying a point on the axis of natural time.
            A point in time is most often represented as a calendar
            expression.
         </p><descriptive name="XML Representation"/><p><emph>TS</emph> is represented by an XML element
                  whose name is determined by the context in which it
                  is used. The element has attributes as described in
                  the template below. The format of the value attribute
                  is described below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type TS --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   value = ST
   /&gt;
</exhibit><p>
                  XML instances may carry either a nullFlavor or a value,
                  but not both.
               </p><!-- no use of the Attribute form at the present time (Jun 2005 Grahame Grieve)
               <p>
                  In addition there is an Attribute form for <dtimplname/>
                  which may be used when properties of other
                  data types have the type <dtimplname/>. In this form <dtimplname/>
                  is represented by an XML attribute whose name is
                  determined by the context in which it is used. The
                  format of this attribute is specified below.
               </p>
--><p>
                  The value of a point in time is represented using the
                  ISO 8601 compliant form traditionally in use with HL7.
                  This is the form that has no decorating dashes, colons
                  and no "T" between the date and time. In short, the
                  syntax is "YYYYMMDDHHMMSS.UUUU[+|-ZZzz]" where digits
                  can be omitted from the right side to express less precision.
                  Common forms are "YYYYMMDD" and "YYYYMMDDHHMM", but the
                  ability to truncate on the right side is not limited to
                  these two variants. See the Data Types Abstract
                  Specification for detail.
               </p><note><p>
                     This is not the W3C Schema form for dateTime. The
                     W3C Schema time data types do not lend themselves
                     as well to representing the varying precision as
                     well as the simpler ISO 8601 variant that is
                     well established in HL7.
                  </p></note><div3 id="TS-examples"><head>Examples</head><p>
                  This example shows April 7, 2000.
               </p><exhibit role="example" verbatim="yes">
&lt;effectiveTime value="20000407"/&gt;</exhibit><p>
                  The next example shows 12:42 pm (in the time zone that is 8 hours
                  before UTC) on September 21, 2005.
               </p><exhibit role="example" verbatim="yes">
&lt;effectiveTime value="200509211242-08"/&gt;</exhibit></div3></div2></div1><!-- *******************************************************
     Collections and Generic Type Extensions
     ******************************************************* --><div1 id="generics" ballotStatus="NormativeStandard"><head>Generic Data Types</head><p>
            The Data Types Abstract Specification defines generic
            types, also called "parameterized types" (UML), "generics"
            (ADA) or "templates" (C++). Generic types are incomplete
            types with parameters such that they define actual types
            (sometimes called "instantiated" types) when their parameters
            are specified. For example, a <termref ref="dtimpl-LIST">LIST</termref> is a generic
            sequence of any values of a parameter type T. Given this
            generic type we can specify specific types such as
            <termref ref="dtimpl-LIST">LIST</termref>&lt;<termref ref="dtimpl-CE">CE</termref>&gt; as sequences of codes or
            <termref ref="dtimpl-LIST">LIST</termref>&lt;<termref ref="dtimpl-PQ">PQ</termref>&gt; for a
            sequences of physical quantities.
         </p><p>
            The Data Types Abstract Specification specifies two different
            kinds of generic types, "generic collections" and "generic
            type extensions". Generic collections specify sets, sequences
            or other groups of data values. Generic type extensions provide
            extensions to normal types that are of general use, such as a
            valid-time for a "history item" or a probability for an
            "uncertain value".
         </p><p>
            In this XML specification, however, we will present these two
            kinds of types together. The reason is that enumerated
            collection types do not exist in the common use of XML. Instead
            it is common practice in XML to represent enumerated collections
            as a sequence of XML elements with the same name (repeated
            element). Therefore we define all such enumerated collection
            types as generic type extensions of their element type. For
            example, instead of having an XML element that stands for a
            whole <termref ref="dtimpl-BAG">BAG</termref>, we have generic type
            extension for bag-item (<termref ref="dtimpl-BXIT">BXIT</termref>) so that
            the XML-element of type <termref ref="dtimpl-BAG">BAG</termref> is defined
            in the schema as a bag-item that can repeat.
         </p><!-- SET --><div2 id="dtimpl-SET"><head><anchor id="SET"/>Set (SET)</head><p><emph role="strong">Definition:     </emph>
            A value that contains other distinct values in no particular order.
         </p><p>
               Exceptional values (NULL-values) can not be elements
               of a set.
            </p><p>
               The empty set is a set without any elements. The empty set
               is a proper set value, not an exceptional value (NULL-value).
            </p><descriptive name="XML Representation"/><p><emph>SET</emph> is represented by both Element
                  and Attribute forms. In the Element form, <emph>SET</emph> is
                  represented by a sequence of XML elements, each of whose
                  name is determined by the context in which it is used.
                  The elements are of type T or <termref ref="dtimpl-SXCM">SXCM</termref>,
                  and have attributes and child elements as described for the
                  data type T and also the attributes described below for
                  <termref ref="dtimpl-SXCM">SXCM</termref>.
               </p><p>
                  The Attribute form of <emph>SET</emph> is used when properties
                  of other data types have type <emph>SET</emph> and T also has
                  an Attribute form with no whitespace content. The name
                  of the attribute is determined by the context in which it
                  is used. The attribute value is a series of values of type
                  T separated by whitespace.
               </p><!-- FIXME: define a SET generic type using the gsd mechanism
  this will probably only (need to) work for xs:element things.
  There we have to just set the type attribute to T and set the
  default maxOccurs to unbounded. However, unbounded is only
  right if there is no other maxOccurs value asserted, because
  a set may also be constrained to maxOccurs = 1 or any other
  number, which we don't want to wipe out. That's possible to
  do.

  The biggest problem is that we cannot use the SET as a
  base for restriction, such as IVL&lt;TS> restricts SET&lt;TS>.
  This method of implementing sets is only good for
  enumerated sets.

  What if SET is a type choice, either one or more SET-element
  or one or more subsets determined by other means. For instance

  position : SET<INT>

  can have the following instance:

  <position xsi:type='SXEL_lt_INT_gt_' value='1'>
  <position xsi:type='SXEL_lt_INT_gt_' value='16'>
  <position xsi:type='SXEL_lt_INT_gt_' value='5'>

  This form can make sense for the BAG because a Bag Item (BXIT)
  is an extension of T with a qty : INT attribute. One could
  argue that for LIST you could have a LXIT that is extended by
  a position number (to compress sparse lists). But for SET it
  appears completely useless to have a SXEL.

  but, position might be an INT

  <position xsi:type='IVL_lt_INT_gt_'>
	<low ...>
	<high ...>
  </position>

  or it might be a set expression

  <position xsi:type='SXPR'>
	<union>
	   IVL
	   SET (enumerated)
	   <intersection>
		 IVL
	 IVL
	   </iintersection>
	</union>
  </position>

or the like. The latter form is needed for the GTS (which is
nothing else than a SET&lt;TS>. But how do we reconcile that
with the simple enumerated set?

We could make a generalized data type SXCM<T> (there is the
Set Component) and T needs to be a restriction of SXCM<T>,
which of course isn't possible, except if we say that every
type T is a restriction of an SXCM<T> to begin with, which
we could not do because multiple inheritance isn't possible
in XML Schema.

We could say that ANY type has a content that can be used to
do a compressed collection of some kind:

  <position>
	<interval>
	  <low>
	  <high>
	</interval>
  </position>

<schema id='schema-set' for='dtimpl-SET'>
  <gsd:template name='SET'>
	<gsd:param name='T' type='ANY'/>

	<gsd:modifyElement>
	  <gsd:attribute name='type' type='T'/>
	  <gsd:attribute name='maxOccurs' default='unbounded'/>
	</gsd:modifyElement>
  </gsd:template>

  <xs:complexType name='test'>
	<xs:complexContent>
	  <xs:sequence>
		<xs:element name='contact'>
	  <gsd:template as='type' name='SET'>
		<gsd:withParam name='T' type='TEL'/>
	  </gsd:template>
		</xs:element>
	  <xs:sequence>
	</xs:complexContent>
  </xs:complexType>
</schema>
--><div3 id="SET-examples"><head>Examples</head><p>
                  The first example shows an Act with a set of id's.
               </p><exhibit role="example" verbatim="yes">
&lt;act&gt;
   &lt;id root='2.16.840.1.113883.19' extension='123A45'/&gt;
   &lt;id root='343EA54F-D0E0-CE95-56C7-23108D6E25B8' extension='N8718349'/&gt;
   ...
&lt;/act&gt;</exhibit><p>
                  The next example shows an Act with a set of reasonCode's.
               </p><exhibit role="example" verbatim="yes">
&lt;act&gt;
   ...
   &lt;reasonCode code='PHY' codeSystem='2.16.840.1.113883.19.5.8'
      codeSystemName='ActReason' displayName='Physician request'/&gt;
   &lt;reasonCode code='MEDNEC' codeSystem='2.16.840.1.113883.19.5.8'
      codeSystemName='ActReason' displayName='Medical Necessity'/&gt;
   ...
&lt;/act&gt;</exhibit><p>
                  The final example shows an Act with an effectiveTime that uses
                  the <emph>intersect</emph> <termref ref="comp-SXCM.operator">SXCM.operator</termref>.
               </p><exhibit role="example" verbatim="yes">
&lt;act&gt;
   ...
   &lt;effectiveTime xsi:type='IVL_TS'&gt;
      &lt;low value='20040204'/&gt;
   &lt;/effectiveTime&gt;
   &lt;effectiveTime xsi:type='PIVL_TS' operator='A'&gt;
      &lt;phase&gt;
         &lt;center value='200402041200'/&gt;
      &lt;/phase&gt;
      &lt;period value='1' unit='d'/&gt;
   &lt;/effectiveTime&gt;
   ...
&lt;/act&gt;</exhibit></div3></div2><div2 id="dtimpl-SXCM"><head><anchor id="SXCM"/>Set Component (SXCM)</head><p><emph role="strong">Definition:     </emph>
            An ITS-defined generic type extension for the base data
            type of a set, representing a component of a general set
            over a discrete or continuous value domain. Its use is
            mainly for continuous value domains. Discrete (enumerable)
            set components are the individual elements of the base
            data type.
         </p><!--
            <p>
               Rationale: the more appropriate design would have been
               to make a discrete set element a set item (SXIT), subtype
               of <dtimplname/>. Then the other continuous <dtimplname/> would be mutually
               exclusive siblings of SXIT instead of inheritors of a
               singular element value which does not make sense for
               continuous set components. However, we do it this way such
               that one can enumerate sets without having to use xsi:type
               assertions, such that the <dtimplname/> is rarely a bother ever.
            </p>
 --><table id="dtimpl-SXCM-comp-summary"><caption>Components of
      Set Component</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">operator</termref></td><td><termref ref="dtimpl-CS">CS</termref></td><td>
                     A code specifying whether the set component is included
                     (union) or excluded (set-difference) from the set, or
                     other set operations with the current set component and
                     the set as constructed from the representation stream
                     up to the current point.
                  </td></tr></tbody></table><descriptive name="XML Representation"/><p><emph>SXCM</emph> is represented by an XML element
                  whose name is determined by the context in
                  which it is used. <emph>SXCM</emph> has all the
                  attributes and child elements described for the Element
                  form of T and adds an XML attribute<emph>operator</emph>
                  as described in the template and sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type SXCM --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   <emph>{any attributes from T}</emph>
   operator = (I | E | A | H | P) : I
   &gt;
   <emph>Content</emph>: ( <emph>{any elements from T}</emph> )
&lt;/x&gt;
</exhibit><div3 id="comp-SXCM.operator"><head>Operator : <termref ref="dtimpl-CS">CS</termref></head><p><emph role="strong">Definition:     </emph>
                     A code specifying whether the set component is included
                     (union) or excluded (set-difference) from the set, or
                     other set operations with the current set component and
                     the set as constructed from the representation stream
                     up to the current point.
                  </p><table id="domain-SetOperator"><caption>Domain SetOperator</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><td>A</td><td>intersect</td><td>Form the intersection with the value.</td></tr><tr valign="top"><td>E</td><td>exclude</td><td>Form the set-difference with this value, i.e., exclude this element or set from the resulting set.</td></tr><tr valign="top"><td>H</td><td>convex hull</td><td>Form the convex hull with the value. The convex hull is defined over ordered domains and is the smallest contiguous superset (interval) that of all the operand sets.</td></tr><tr valign="top"><td>I</td><td>include</td><td>Form the union with this value, i.e., include this element or set in the resulting set.</td></tr><tr valign="top"><td>P</td><td>periodic hull</td><td>Form the periodic hull with the value. The periodic hull is defined over ordered domains and is the periodic set that contains all contiguous supersets of pairs of intervals generated by the operand periodic intervals.</td></tr></table><!--
                  <entry code="E"/>
                  <entry code="A"/>
                  <entry code="H"/>
                  <entry code="I"/>
                  <entry code="P"/>
               </domain>
  --><descriptive name="XML Representation"/><p><emph>operator</emph> is represented as the
                     XML attribute<emph>operator</emph>, whose value, if present,
                     must be a valid code from the SetOperator domain
                     (<tabref ref="domain-SetOperator"/>). The default
                     value is <emph>I</emph>.
                  </p></div3><div3 id="SXCM-examples"><head>Examples</head><p>
            		See the examples using <termref ref="comp-SXCM.operator">operator</termref> in
            		<specref ref="SET-examples"/>.
            	</p></div3></div2><div2 id="dtimpl-LIST"><head><anchor id="LIST"/>Sequence (LIST)</head><p><emph role="strong">Definition:     </emph>
            A value that contains other discrete values in a
            defined sequence.
         </p><descriptive name="XML Representation"/><p><emph>LIST</emph> is represented by both Element
                  and Attribute forms. In the Element form, the list is
                  represented by a sequence of XML elements, each of whose
                  name is determined by the context in which it is used.
                  The elements have attributes and element children as
                  described for the data type T.
               </p><p>
                  The Attribute form of <emph>LIST</emph> is used when properties
                  of other data types have type <emph>LIST</emph> and T also has
                  an Attribute form which does not allow whitespace. The
                  name of the attribute is determined by the context in
                  which it is used. The attribute value is a series of
                  values of type T separated by whitespace.
               </p><div3 id="LIST-examples"><head>Examples</head><p>
            		The first example shows a list of templateId's.
            	</p><exhibit role="example" verbatim="yes">
&lt;act&gt;
   ...
   &lt;templateId root='2.16.840.1.113883.19' extension='Acme Template 1'/&gt;
   &lt;templateId root='2.16.840.1.113883.19' extension='Acme Template 2'/&gt;
   ...
&lt;/act&gt;</exhibit><p>
            		The second example shows a regionOfInterest whose
            		value is a list of <termref ref="dtimpl-INT">INT</termref> (that
            		specifies the coordinates of the endpoints of the
            		major and minor axes.
            	</p><exhibit role="example" verbatim="yes">
&lt;regionOfInterest classCode='ROIOVL'&gt;
   &lt;code code='ELLIPSE'/&gt;
   &lt;value value='3'/&gt;
   &lt;value value='1'/&gt;
   &lt;value value='3'/&gt;
   &lt;value value='7'/&gt;
   &lt;value value='2'/&gt;
   &lt;value value='4'/&gt;
   &lt;value value='4'/&gt;
   &lt;value value='4'/&gt;
&lt;/regionOfInterest&gt;</exhibit></div3></div2><div2 id="dtimpl-GLIST"><head><anchor id="GLIST"/>Generated Sequence (GLIST)</head><p><emph role="strong">Definition:     </emph>
            A periodic or monotone sequence of values generated
            from a few parameters, rather than being enumerated.
            Used to specify regular sampling points for biosignals.
         </p><table id="dtimpl-GLIST-comp-summary"><caption>Components of
      Generated Sequence</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">head</termref></td><td>T</td><td>
                     This is the start-value of the generated list. 
                  </td></tr><tr><td><termref ref="">increment</termref></td><td>T.diff</td><td>
                     The difference between one value and its previous
                     different value. For example, to generate the sequence
                     (1; 4; 7; 10; 13; ...) the increment is 3; likewise to
                     generate the sequence (1; 1; 4; 4; 7; 7; 10; 10; 13;
                     13; ...) the increment is also 3.
                  </td></tr><tr><td><termref ref="">period</termref></td><td><termref ref="dtimpl-INT">INT</termref></td><td>
                     If non-NULL, specifies that the sequence alternates,
                     i.e., after this many increments, the sequence item
                     values roll over to start from the initial sequence
                     item value. For example, the sequence (1; 2; 3; 1; 2;
                     3; 1; 2; 3; ...) has period 3; also the sequence
                     (1; 1; 2; 2; 3; 3; 1; 1; 2; 2; 3; 3; ...) has period
                     3 too.
                  </td></tr><tr><td><termref ref="">denominator</termref></td><td><termref ref="dtimpl-INT">INT</termref></td><td>
                     The integer by which the index for the sequence is
                     divided, effectively the number of times the sequence
                     generates the same sequence item value before
                     incrementing to the next sequence item value. For
                     example, to generate the sequence (1; 1; 1; 2; 2; 2; 3; 3;
                     3; ...)  the denominator is 3.
                  </td></tr></tbody></table><p>
               The item at a certain index in the list is calculated
               by performing an integer division on the index (<emph>i</emph>)
               with the <termref ref="comp-GLIST.denominator">denominator</termref>
               (<emph>d</emph>) and then take that value's remainder with
               the <termref ref="comp-GLIST.period">period</termref> (<emph>p</emph>).
               Multiply this value with the <termref ref="comp-GLIST.increment">increment</termref>
               (<emph>&#916;x</emph>) and add to the <termref ref="comp-GLIST.head">head</termref>
               (<emph>x</emph><emph role="sub">0</emph>.)
            </p><descriptive name="XML Representation"/><p><emph>GLIST</emph> is represented in Element form
                  as described in the template and sub-sections below. The
                  name of the element is determined by the context in which
                  it is used.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type GLIST --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   period = INT
   denominator = INT
   &gt;
   <emph>Content</emph>: ( head, increment )
&lt;/x&gt;
</exhibit><div3 id="comp-GLIST.head"><head>Head : T</head><p><emph role="strong">Definition:     </emph>
                     This is the start-value of the generated list. 
                  </p><descriptive name="XML Representation"/><p><emph>head</emph> is represented as XML element<emph>head</emph>
                     which, if present, must be a valid T.
                  </p></div3><div3 id="comp-GLIST.increment"><head>Increment : T.diff</head><p><emph role="strong">Definition:     </emph>
                     The difference between one value and its previous
                     different value. For example, to generate the sequence
                     (1; 4; 7; 10; 13; ...) the increment is 3; likewise to
                     generate the sequence (1; 1; 4; 4; 7; 7; 10; 10; 13;
                     13; ...) the increment is also 3.
                  </p><descriptive name="XML Representation"/><p><emph>increment</emph> is represented as the
                     XML element<emph>increment</emph> which, if present, must
                     be a valid T.diff.
                  </p></div3><div3 id="comp-GLIST.period"><head>Period Step Count : <termref ref="dtimpl-INT">INT</termref></head><p><emph role="strong">Definition:     </emph>
                     If non-NULL, specifies that the sequence alternates,
                     i.e., after this many increments, the sequence item
                     values roll over to start from the initial sequence
                     item value. For example, the sequence (1; 2; 3; 1; 2;
                     3; 1; 2; 3; ...) has period 3; also the sequence
                     (1; 1; 2; 2; 3; 3; 1; 1; 2; 2; 3; 3; ...) has period
                     3 too.
                  </p><descriptive name="XML Representation"/><p><emph>period</emph> is represented as the XML attribute<emph>period</emph>,
                     whose value, if present, must be a valid
                     <termref ref="dtimpl-INT">INT</termref>.
                  </p></div3><div3 id="comp-GLIST.denominator"><head>Denominator : <termref ref="dtimpl-INT">INT</termref></head><p><emph role="strong">Definition:     </emph>
                     The integer by which the index for the sequence is
                     divided, effectively the number of times the sequence
                     generates the same sequence item value before
                     incrementing to the next sequence item value. For
                     example, to generate the sequence (1; 1; 1; 2; 2; 2; 3; 3;
                     3; ...)  the denominator is 3.
                  </p><descriptive name="XML Representation"/><p><emph>denominator</emph> is represented as the XML attribute<emph>denominator</emph>,
                     whose value, if present, must be a valid
                     <termref ref="dtimpl-INT">INT</termref>.
                  </p></div3><div3 id="GLIST-examples"><head>Examples</head><p>
                  The first example shows the time base for an EKG strip written
                  at October 29, 2002 at 16:51:13 at a per 2 ms sampling rate.
               </p><exhibit role="example" verbatim="yes">
&lt;value xsi:type='GLIST_TS'&gt;
   &lt;head value='20021029165113'/&gt;
   &lt;increment value='2' unit='ms'/&gt;
&lt;/value&gt;</exhibit><p>
                  The second example shows a RADAR scan that increments in 2
                  degrees and has a period of 360 degrees, i.e., of 180 increments.
               </p><exhibit role="example" verbatim="yes">
&lt;value xsi:type='GLIST_PQ' period='180'&gt;
   &lt;head value='0'/&gt;
   &lt;increment value='2' unit='deg'/&gt;
&lt;/value&gt;</exhibit></div3></div2><div2 id="dtimpl-SLIST"><head><anchor id="SLIST"/>Sampled Sequence (SLIST)</head><p><emph role="strong">Definition:     </emph>
            A sequence of sampled values scaled and translated from a
            list of integer values.  Used to specify sampled biosignals.
         </p><table id="dtimpl-SLIST-comp-summary"><caption>Components of
      Sampled Sequence</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">origin</termref></td><td>T</td><td>
                     The origin of the list item value scale, i.e., the
                     physical quantity that a zero-digit in the sequence
                     would represent.
                  </td></tr><tr><td><termref ref="">scale</termref></td><td>T.diff</td><td>
                     A ratio-scale quantity that is factored out of the
                     digit sequence.
                  </td></tr><tr><td><termref ref="">digits</termref></td><td>LIST&lt;INT&gt;</td><td>
                     A sequence of raw digits for the sample values. This is
                     typically the raw output of an A/D converter.
                  </td></tr></tbody></table><p>
               The item at a certain index (<emph>i</emph>) in the list
               is calculated by multiplying the item at the same index
               in the <termref ref="comp-SLIST.digits">digits</termref> sequence
               (<emph>d</emph><emph role="sub"><emph>i</emph></emph>) with the
               <termref ref="comp-SLIST.scale">scale</termref> (<emph>s</emph>)
               and then add that value to the <termref ref="comp-SLIST.origin">origin</termref>
               (<emph>x</emph><emph role="sub"><emph>o</emph></emph>).
            </p><descriptive name="XML Representation"/><p><emph>SLIST</emph> is represented in Element
                  form as described in the template and sub-sections
                  below. The name of the element is determined by the
                  context in which it is used.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type SLIST --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   &gt;
   <emph>Content</emph>: ( origin, scale, digits )
&lt;/x&gt;
</exhibit><div3 id="comp-SLIST.origin"><head>Origin : T</head><p><emph role="strong">Definition:     </emph>
                     The origin of the list item value scale, i.e., the
                     physical quantity that a zero-digit in the sequence
                     would represent.
                  </p><descriptive name="XML Representation"/><p><emph>origin</emph> is represented as the XML element<emph>origin</emph>
                     which, if present, must be a valid T.
                  </p></div3><div3 id="comp-SLIST.scale"><head>Scale Factor : T.diff</head><p><emph role="strong">Definition:     </emph>
                     A ratio-scale quantity that is factored out of the
                     digit sequence.
                  </p><descriptive name="XML Representation"/><p><emph>scale</emph> is represented as the XML element<emph>scale</emph>
                     which, if present, must be a valid T.diff.
                  </p></div3><div3 id="comp-SLIST.digits"><head>Sampled Digits : LIST&lt;INT&gt;</head><p><emph role="strong">Definition:     </emph>
                     A sequence of raw digits for the sample values. This is
                     typically the raw output of an A/D converter.
                  </p><descriptive name="XML Representation"/><p><emph>digits</emph> is represented as the XML element<emph>digits</emph>
                     which, if present, is a whitespace separated list of
                     the Attribute form of <termref ref="dtimpl-INT">INT</termref>.
                  </p><note><p>
                        The representation of this property does not match
                        any of the allowed representations for
                        <termref ref="dtimpl-LIST">LIST</termref>&lt;<termref ref="dtimpl-INT">INT</termref>&gt;.
                     </p></note></div3><div3 id="SLIST-examples"><head>Examples</head><p>
                  This example shows Lead II of an EKG tracing, with origin calibrated at
                  0 &#956;V and with a scale factor of 2.5 &#956;V.
               </p><exhibit role="example" verbatim="yes">
&lt;value xsi:type='SLIST_PQ'&gt;
   &lt;origin value='0' unit='uV'/&gt;
   &lt;scale value='2.5' unit='uV'/&gt;
   &lt;digits&gt;-4 -13 -18 -18 -18 -17 -16 -16 -16 -16 -16 -17 -18 -18 -18
      -17 -16 -16 -16 -15 -13 -11 -10 -10 -9 -6 -4 -5 -5 -3 -2 -2 -1 1 2 3 5
      7 8 9 10 11 12 13 15 17 19 21 23 25 27 29 30 30 31 34 37 40 43 45 46
      46 46 46 46 47 49 51 53 55 57 59 60 59 58 58 58 57 56 56 56 57 57 55
      53 50 47 45 74 51 38 33 31 28 25 21 16 14 15 13 9 7 4 1 -1 -3 -4 -6
      -10 -12 -13 -12 -12 -17 -18 -18 -18 -19 -20 -21 -20 -20 -20 -20 -20
      ...
      2 1 0 0 0 1 2 2 1 1 1 0 -1 0 1 1 1 1 2 1&lt;/digits&gt;
&lt;/value&gt;</exhibit></div3></div2><div2 id="dtimpl-BAG"><head><anchor id="BAG"/>Bag (BAG)</head><p><emph role="strong">Definition:     </emph>
            An unordered collection of values, where each value can
            be contained more than once in the bag.
         </p><descriptive name="XML Representation"/><p><emph>BAG</emph> is represented by both Element
                  and Attribute forms. In the Element form, the bag is
                  represented by a sequence of XML elements, each of whose
                  name is determined by the context in which it is used.
                  The elements are of type T or <termref ref="dtimpl-BXIT">BXIT</termref>,
                  and have attributes and child elements as described for
                  the data type T and may also the attributes described
                  below for <termref ref="dtimpl-BXIT">BXIT</termref>.
               </p><p>
                  The Attribute form of <emph>BAG</emph> is used when properties
                  of other data types have type <emph>BAG</emph> and T also has
                  an Attribute form with no whitespace content. The name
                  of the attribute is determined by the context in which it
                  is used. The attribute value is a series of values of
                  type T separated by whitespace.
               </p><div3 id="BAG-examples"><head>Examples</head><p>
            		This example shows an Organization with multiple addresses.
            	</p><exhibit role="example" verbatim="yes">
&lt;organization&gt;
   ...
   &lt;addr use='DIR'&gt;123 Main St., Anytown, CA, US&lt;/addr&gt;
   &lt;addr use='PUB'&gt;456 Boradway St., Anytown, CA, US&lt;/addr&gt;
   ...
&lt;/organization&gt;</exhibit></div3></div2><div2 id="dtimpl-BXIT"><head><anchor id="BXIT"/>Bag Item (BXIT)</head><p><emph role="strong">Definition:     </emph>
            An ITS-defined generic data type extension that
            represents a collection of a certain number of identical
            items in a bag.
         </p><table id="dtimpl-BXIT-comp-summary"><caption>Components of
      Bag Item</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">qty</termref></td><td><termref ref="dtimpl-INT">INT</termref></td><td>
                     The quantity in which the bag item occurs in its containing bag.
                  </td></tr></tbody></table><p><emph>BXIT</emph> allows a "compressed" representation of <termref ref="dtimpl-BAG">BAG</termref>,
               where the same bag items need not be represented repeatedly,
               but can be quantified by a number. This representation of a
               bag is useful if relatively few different items occur in
               relatively large numbers, as it is the case in statistical
               data collections.
            </p><p><emph>BXIT</emph>, although it is fully consistent with the
               Data Types Abstract Specification, is only defined in the ITS,
               because it only specifies a certain form in which a bag of
               values can be represented more efficiently without adding
               any special semantics that was not already given in the
               definition of the bag data type.
            </p><descriptive name="XML Representation"/><p><emph>BXIT</emph> is represented by an XML element
                  whose name is determined by the context in which it is used.
                  <emph>BXIT</emph> type has all the attributes and child
                  elements described for the Element form of T and adds the
                  XML attribute<emph>qty</emph> as described in the template and
                  sub-sections below.
               </p><!-- pvb: 20050719: shouldn't this template have a nullFlavor? --><exhibit role="template" verbatim="yes">
&lt;!-- type BXIT --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   <emph>{any attributes from T}</emph>
   qty = INT : 1
   &gt;
   <emph>Content</emph>: <emph>{any elements from T}</emph>
&lt;/x&gt;
</exhibit><div3 id="comp-BXIT.qty"><head>Quantity : <termref ref="dtimpl-INT">INT</termref></head><p><emph role="strong">Definition:     </emph>
                     The quantity in which the bag item occurs in its containing bag.
                  </p><descriptive name="XML Representation"/><p><emph>qty</emph> is represented as the XML attribute<emph>qty</emph>,
                     whose value, if present, must be a valid
                     <termref ref="dtimpl-INT">INT</termref>.	The default value
                     is <emph>1</emph>, i.e., the qty attribute need not
                     be specified if items are not quantified but simply
                     repeated.
                  </p></div3><div3 id="BXIT-examples"><head>Examples</head><p>
            		See the examples in
            		<specref ref="BAG-examples"/>.
            	</p></div3></div2><div2 id="dtimpl-IVL"><head><anchor id="IVL"/>Interval (IVL) specializes <termref ref="dtimpl-SXCM">SXCM</termref></head><p><emph role="strong">Definition:     </emph>
            A set of consecutive values of an ordered base data type.
         </p><p>
               Note that the interval boundaries must be of comparable
               types. It makes no sense to specify the interval between
               2 meters and 4 seconds.
            </p><table id="dtimpl-IVL-comp-summary"><caption>Components of
      Interval</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">low</termref></td><td><termref ref="dtimpl-IVXB">IVXB</termref></td><td>
                           The low limit of the interval.
                        </td></tr><tr><td><termref ref="">high</termref></td><td><termref ref="dtimpl-IVXB">IVXB</termref></td><td>
                           The high limit of the interval.
                        </td></tr><tr><td><termref ref="">center</termref></td><td>T</td><td>
                           The arithmetic mean of the interval (low plus high
                           divided by 2). The purpose of distinguishing the center
                           as a semantic property is for conversions of intervals
                           from and to point values.
                        </td></tr><tr><td><termref ref="">width</termref></td><td>T.diff</td><td>
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width need
                           to be stated and the third can be derived.
                        </td></tr></tbody></table><p>
               In any interval representation only two of the four
               properties high, low, width and center need to be stated
               and the other two can be derived. Incomplete intervals exist,
               where only one property is valued, particularly, when no
               boundary or center is known, the width may still be known.
               For example, one knows that an activity takes about 30
               minutes, but one may not yet know when that activity is
               started.
            </p><descriptive name="XML Representation"/><p><emph>IVL</emph> is represented by an XML element
                  whose name is determined by the context in which it is
                  used. <emph>IVL</emph> type has all the attributes and
                  child elements as described in the template and
                  sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type IVL --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   operator = (I | E | A | H | P) : I
   &gt;
   <emph>Content</emph>: ( low, high, center, width )
&lt;/x&gt;
</exhibit><p>
                  You can have any of these combinations of children:
               </p><list role="unordered"><item>low</item><item>width</item><item>high</item><item>low, width</item><item>width, high</item><item>low, high</item><item>center</item><item>center, width</item></list><div3 id="comp-IVL.low"><head>Low Boundary : <termref ref="dtimpl-IVXB">IVXB</termref></head><p><emph role="strong">Definition:     </emph>
                           The low limit of the interval.
                        </p><descriptive name="XML Representation"/><p><emph>low</emph> is represented as the XML element<emph>low</emph>
                     which, if present, must be a valid
                     <termref ref="dtimpl-IVXB">IVXB</termref>.
                  </p></div3><div3 id="comp-IVL.high"><head>High Boundary : <termref ref="dtimpl-IVXB">IVXB</termref></head><p><emph role="strong">Definition:     </emph>
                           The high limit of the interval.
                        </p><descriptive name="XML Representation"/><p><emph>high</emph> is represented as the XML element<emph>high</emph>
                     which, if present, must be a valid <termref ref="dtimpl-IVXB">IVXB</termref>.
                  </p></div3><div3 id="comp-IVL.center"><head>Center : T</head><p><emph role="strong">Definition:     </emph>
                           The arithmetic mean of the interval (low plus high
                           divided by 2). The purpose of distinguishing the center
                           as a semantic property is for conversions of intervals
                           from and to point values.
                        </p><p>
                  Note that a center doesn't always exist for every
                  interval. Notably intervals that are infinite on one
                  side do not have a center. Also intervals of discrete
                  base types with an even number of elements do not have
                  a center. If an interval is unknown on one (or both)
                  boundaries, the center can still be asserted. In fact,
                  the main use case for the center is to be asserted when
                  no boundary is known.
               </p><descriptive name="XML Representation"/><p><emph>center</emph> is represented as the XML element<emph>center</emph>
                     which, if present, must be a valid T.
                  </p></div3><div3 id="comp-IVL.width"><head>Width : T.diff</head><p><emph role="strong">Definition:     </emph>
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width need
                           to be stated and the third can be derived.
                        </p><p>
                  When both boundaries are known, width can be derived as
                  high minus low. When one boundary and the width is known,
                  the other boundary is also known. When no boundary is
                  known, the width may still be known. For example, one
                  knows that an activity takes about 30 minutes, but one
                  may not yet know when that activity is started.
               </p><p>
                  Note that the data type of the width is not always the
                  same as for the boundaries. For ratio scale quantities
                  (<termref ref="dtimpl-REAL">REAL</termref>, <termref ref="dtimpl-PQ">PQ</termref>,
                  <termref ref="dtimpl-MO">MO</termref>) it is the same. For difference scale
                  quantities (e.g., <termref ref="dtimpl-TS">TS</termref>) is the data type of the difference
                  (e.g., <termref ref="dtimpl-PQ">PQ</termref> in the dimension of time for
                  <termref ref="dtimpl-TS">TS</termref>).
<!--
                  For discrete elements (<dtimplref ref='dtimpl-INT'/>) the
                  width may be a <dtimplref ref='dtimpl-REAL'/>
                  indicating the number of elements in the interval
                  divided by 2.
  --></p><descriptive name="XML Representation"/><p><emph>width</emph> is represented as the XML element<emph>width</emph>
                     which, if present, must be a valid T.diff.
                  </p></div3><!-- FIXME: an XML equivalent of the hull form is missing for
  IVL&lt;TS>. We either need to say that an IVL&lt;TS> is exceptional
  in that it always implements the hull-form or we need to
  devise a special flag or tag for the hull form. --><div3 id="IVL-examples"><head>Examples</head><p>
                  The first example shows a simple interval of <termref ref="dtimpl-INT">INT</termref>
                  between 2 and 4.
               </p><exhibit role="example" verbatim="yes">
&lt;value xsi:type='IVL_INT'&gt;
   &lt;low value='2'/&gt;
   &lt;high value='4'/&gt;
&lt;/value&gt;</exhibit><!--
               <p>
                  Real numbers between 2.01 and 3.95, exclusive
               </p>
               <example><![CDATA[
<value xsi:type='IVL_REAL'>
   <low value='2.01' inclusive='false'/>
   <high value='3.95' inclusive='false'/>
</value>]]></example>
  --><p>
                  The second example shows an interval of <termref ref="dtimpl-PQ">PQ</termref>
                  between 2.8 meters, inclusive, and 4.6 meters, exclusive.
               </p><exhibit role="example" verbatim="yes">
&lt;offset&gt;
   &lt;low value='2.8' unit='m' inclusive='true'/&gt;
   &lt;high value='4.6' unit='m' inclusive='false'/&gt;
&lt;/offset&gt;</exhibit><p>
                  Finally, the last example shows an interval of <termref ref="dtimpl-TS">TS</termref>
                  on December 4, 2000, between 10:00 am and 10:30 am.
               </p><exhibit role="example" verbatim="yes">
&lt;effectiveTime&gt;
   &lt;low value='200012041000'/&gt;
   &lt;high value='200012041030'/&gt;
&lt;/effectiveTime&gt;</exhibit></div3></div2><div2 id="dtimpl-IVXB"><head><anchor id="IVXB"/>Interval Boundary (IVXB)</head><p><emph role="strong">Definition:     </emph>
            An ITS-defined generic type extension representing the
            boundary value for an interval.
         </p><table id="dtimpl-IVXB-comp-summary"><caption>Components of
      Interval Boundary</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">inclusive</termref></td><td><termref ref="dtimpl-BL">BL</termref></td><td>
                     Specifies whether the limit is included in the
                     interval (interval is closed) or excluded from the
                     interval (interval is open).
                  </td></tr></tbody></table><p>
               In any interval representation the low and high boundaries
               may be either inclusive or exclusive. This generic extension
               type adds the component <emph>inclusive</emph> to the
               <termref ref="dtimpl-QTY">QTY</termref> type T.
            </p><descriptive name="XML Representation"/><p><emph>IVXB</emph> is represented by an XML element
                  whose name is determined by the context in
                  which it is used. <emph>IVXB</emph> has all the
                  attributes and child elements described for the Element
                  form of T and adds the <emph>inclusive</emph> attribute as
                  described in the template and sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type IVXB - used internally within IVL --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   <emph>{any attributes from T}</emph>
   inclusive = (true | false) : true
   &gt;
   <emph>Content</emph>: ( <emph>{any elements from T}</emph> )
&lt;/x&gt;
</exhibit><div3 id="comp-IVXB.inclusive"><head>Inclusive : <termref ref="dtimpl-BL">BL</termref></head><p><emph role="strong">Definition:     </emph>
                     Specifies whether the limit is included in the
                     interval (interval is closed) or excluded from the
                     interval (interval is open).
                  </p><descriptive name="XML Representation"/><p><emph>inclusive</emph> is represented as the XML attribute<emph>inclusive</emph>,
                     whose value, if present, must be either <emph>true</emph>
                     or <emph>false</emph>.	The default value is <emph>true</emph>.
                  </p></div3></div2><div2 id="dtimpl-HIST"><head><anchor id="HIST"/>History (HIST)</head><p><emph role="strong">Definition:     </emph>
            A set of data values that conform to the history item
            (<termref ref="dtimpl-HXIT">HXIT</termref>) type, (i.e., that have a valid-time
            property). The history information is not limited to the
            past; expected future values can also appear.
         </p><descriptive name="XML Representation"/><p><emph>HIST</emph> is represented by a sequence of XML elements
                  whose name is determined by the context in which
                  it is used.   Each element is of type
                  <termref ref="dtimpl-HXIT">HXIT</termref>.
               </p><!-- FIXME: this is where time-series go! And we then want a
  compressed time series representation. --></div2><div2 id="dtimpl-HXIT"><head><anchor id="HXIT"/>History Item (HXIT)</head><p><emph role="strong">Definition:     </emph>
            A generic data type extension that tags a time range to
            any data value of any data type.  The time range is the
            time in which the information represented by the value
            is (was) valid.
         </p><table id="dtimpl-HXIT-comp-summary"><caption>Components of
      History Item</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">validTime</termref></td><td>IVL&lt;TS&gt;</td><td>
                        The time interval during which the given information
                        was, is, or is expected to be valid. The interval can
                        be open or closed, as well as infinite or undefined on
                        either side.
                     </td></tr></tbody></table><!-- pvb: 20050629: hxit_cs --><p>
               For example, a value of type <emph>HXIT</emph>&lt;<termref ref="dtimpl-CS">CS</termref>&gt;
               extended from <termref ref="dtimpl-CS">CS</termref>
               has all of the properties of the original
               <termref ref="dtimpl-CS">CS</termref> value, plus a time range
               indicating when that code is or was valid.
            </p><p>
               Data types that already have a valid time range property
               (i.e., <termref ref="dtimpl-EN">EN</termref> and specializations)
               obviously do not need these extensions. Their valid time
               range property can be mapped to the valid time property
               of the <emph>HXIT</emph>, in fact, those data types are considered
               history items by themselves. For example, <termref ref="dtimpl-EN">EN</termref>
               is the same data type as <emph>HXIT</emph>&lt;<termref ref="dtimpl-EN">EN</termref>&gt;.
            </p><descriptive name="XML Representation"/><p><emph>HXIT</emph> is represented by an XML element
                  whose name is determined by the context in which
                  it is used. <emph>HXIT</emph> has all the attributes
                  and child elements described for the Element form of T
                  and adds the XML element<emph>validTime</emph> as described in the
                  template and sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type HXIT --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   <emph>{any attributes from T}</emph>
   &gt;
   <emph>Content</emph>: ( <emph>{any elements from T}</emph>, validTime )
&lt;/x&gt;
</exhibit><div3 id="comp-HXIT.validTime"><head>Valid Time : IVL&lt;TS&gt;</head><p><emph role="strong">Definition:     </emph>
                        The time interval during which the given information
                        was, is, or is expected to be valid. The interval can
                        be open or closed, as well as infinite or undefined on
                        either side.
                     </p><descriptive name="XML Representation"/><p><emph>validTime</emph> is represented as the XML element<emph>validTime</emph>
                     which, if present, must be a valid
                     <termref ref="dtimpl-IVL">IVL</termref>&lt;<termref ref="dtimpl-TS">TS</termref>&gt;.
                  </p></div3></div2><div2 id="dtimpl-UVP"><head><anchor id="UVP"/>Uncertain Value - Probabilistic (UVP)</head><p><emph role="strong">Definition:     </emph>
            A generic data type extension used to specify a
            probability expressing the information producer's belief
            that the given value holds.
         </p><table id="dtimpl-UVP-comp-summary"><caption>Components of
      Uncertain Value - Probabilistic</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">probability</termref></td><td><termref ref="dtimpl-REAL">REAL</termref></td><td>
               The probability assigned to the value, a decimal number
               between 0 (very uncertain) and 1 (certain).
            </td></tr></tbody></table><p>
               Probabilities are subjective and (as any data value)
               must be interpreted in their individual context, for
               example, when new information is found the probability
               might change. Thus, for any message (document, or other
               information representation) the information - and
               particularly the probabilities - reflect what the
               information producer believed was appropriate for the
               purpose and at the time the message (document) was created.
            </p><p>
               For example, at the beginning of the 2000 baseball season
               (May), the Las Vegas odds makers may have given the New
               York Yankees a probability of 1 in 10 (0.100) of winning
               the World Series. At the time of this writing, the Yankees
               and Mets have won their respective pennants, but the World
               Series has yet to begin. The probability of the Yankees
               winning the World Series is obviously significantly greater
               at this point in time, perhaps 6 in 10 (0.600). The context,
               and in particular the time of year, made all the difference
               in the world.
            </p><p>
               Since probabilities are subjective measures of belief, they
               can be stated without being "correct" or "incorrect" per se,
               let alone "precise" or "imprecise". Notably, one does not
               have to conduct experiments to measure a frequency of some
               outcome in order to specify a probability. In fact, whenever
               statements about individual people or events are made, it
               is not possible to confirm such probabilities with
               "frequentists" experiments.
            </p><p>
               Returning to our example, the Las Vegas odds makers can
               not insist on the Yankees and Mets playing 1000 trial games
               prior to the Series; even if they could, they would not
               have the fervor of the real Series and therefore not be
               accurate. Instead, the odds makers must derive the probability
               from past history, player statistics, injuries, etc.
            </p><descriptive name="XML Representation"/><p><emph>UVP</emph> is represented by an XML element
                  whose name is determined by the context in which it is
                  used. <emph>UVP</emph> has all the attributes and
                  child elements described for the Element form of T and
                  adds the XML attribute<emph>probability</emph> as described in
                  the template and sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type UVP --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   <emph>{any attributes from T}</emph>
   probability = REAL
   &gt;
   <emph>Content</emph>: ( <emph>{any elements from T}</emph> )
&lt;/x&gt;
</exhibit><div3 id="comp-UVP.probability"><head>Probability : <termref ref="dtimpl-REAL">REAL</termref></head><p><emph role="strong">Definition:     </emph>
               The probability assigned to the value, a decimal number
               between 0 (very uncertain) and 1 (certain).
            </p><descriptive name="XML Representation"/><p><emph>probability</emph> is represented as the XML attribute<emph>probability</emph>,
                     whose value, if present, must be a valid <termref ref="dtimpl-REAL">REAL</termref>.
                  </p></div3></div2><div2 id="dtimpl-NPPD"><head><anchor id="NPPD"/>Non-Parametric Probability Distribution (NPPD)</head><p><emph role="strong">Definition:     </emph>
            A set of uncertain values with probabilities (also known
            as a histogram).
         </p><p>
               The easiest way to visualize this is a bar chart as
               shown below.
            </p><graphic source="graphics/DT-NPPD-ex1.gif" alt="Example of a Histogram"/><p>
               This example illustrates the probability of selected
               major league baseball teams winning the World Series
               (prior to the season start). Each team is mutually
               exclusive, and were we to include all of the teams, the
               sum of the probabilities would equal 1 (i.e., it is
               certain that one of the teams will win).
            </p><p>
               Semantically, a non-parametric probability distribution
               contains <emph>all</emph> possible values and assigns
               probabilities to each of them. Our example has left out
               quite a few teams. The rules for this data type tell us
               that the other teams would share the "leftover" probability
               equally. The 8 teams in the example have a collective
               probability of winning the World Series of 0.47. If there
               were a total of 24 teams in the league, then 16 are not
               shown. Each of these teams would be assigned a probability
               of (1.00 - 0.47) / 16 = 0.033125.
            </p><descriptive name="XML Representation"/><p><emph>NPPD</emph> is represented by a sequence of
                  XML elements, each of whose name is determined by the
                  context in which it is used. Each element is of type
                  <termref ref="dtimpl-UVP">UVP</termref>.
               </p><!-- FIXME: add the general generic type stuff as for SET --></div2></div1><div1 id="dtimpltiming" ballotStatus="NormativeStandard"><head>Timing Specification</head><p>
            The timing specification suite of data types is used to
            specify the complex timing of events and actions such as those
            that occur in order management and scheduling systems. It also
            supports the cyclical validity patterns that may exist for
            certain kinds of information, such as phone numbers (evening,
            daytime), addresses (so called "snowbirds," residing closer
            to the equator during winter and farther from the equator
            during summer) and office hours.
         </p><p>
            The timing specification data types include point in time
            (<termref ref="dtimpl-TS">TS</termref>) and the interval of time
            (<termref ref="dtimpl-IVL">IVL</termref>&lt;<termref ref="dtimpl-T">T</termref>&gt;)
            and add types that are specifically suited to repeated schedules.
            These additional types include periodic interval, event-related
            periodic interval, and finally the general timing specification
            types itself. All these timing types describe the time
            distribution of repeating states or events.
         </p><div2 id="dtimpl-PIVL"><head><anchor id="PIVL"/>Periodic Interval of Time (PIVL) specializes <termref ref="dtimpl-SXCM">SXCM</termref></head><p><emph role="strong">Definition:     </emph>
            An interval of time that recurs periodically. Periodic
            intervals have two properties, phase and period. The
            phase specifies the "interval prototype" that is repeated
            every period.
         </p><table id="dtimpl-PIVL-comp-summary"><caption>Components of
      Periodic Interval of Time</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">phase</termref></td><td><termref ref="dtimpl-IVL">IVL</termref></td><td>
                        A prototype of the repeating interval specifying the
                        duration of each occurrence and anchors the periodic
                        interval sequence at a certain point in time.
                     </td></tr><tr><td><termref ref="">period</termref></td><td>T.diff</td><td>
                        A time duration specifying a reciprocal measure of
                        the frequency at which the periodic interval repeats.
                     </td></tr><tr><td><termref ref="">alignment</termref></td><td><termref ref="dtimpl-CS">CS</termref></td><td>
                     Specifies if and how the repetitions are aligned to
                     the cycles of the underlying calendar (e.g., to
                     distinguish every 30 days from "the 5th of every
                     month".) A non-aligned periodic interval recurs
                     independently from the calendar. An aligned periodic
                     interval is synchronized with the calendar.
                  </td></tr><tr><td><termref ref="">institutionSpecified</termref></td><td><termref ref="dtimpl-BL">BL</termref></td><td>
                     Indicates whether the exact timing is up to the party
                     executing the schedule (e.g., to distinguish "every 8
                     hours" from "3 times a day".)
                  </td></tr></tbody></table><p>
               For example, "every eight hours for two minutes" is a
               periodic interval where the interval's width equals two
               minutes and the period at which the interval recurs
               equals eight hours.
            </p><p>
               The phase also marks the anchor point in time for the
               entire series of periodically recurring intervals. The
               recurrence of a periodic interval has no beginning or
               ending, but is infinite in both future and past.
            </p><descriptive name="XML Representation"/><p><emph>PIVL</emph> is represented by an XML element
                  whose name is determined by the context in
                  which it is used. <emph>PIVL</emph> has all the
                  attributes and child elements as described in the
                  template and sub-sections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type PIVL --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   operator = (I | E | A | H | P)
   alignment = CS
   institutionSpecified = (true | false} : false
   &gt;
   <emph>Content</emph>: ( phase, period )
&lt;/x&gt;
</exhibit><div3 id="comp-PIVL.phase"><head>Phase : <termref ref="dtimpl-IVL">IVL</termref></head><p><emph role="strong">Definition:     </emph>
                        A prototype of the repeating interval specifying the
                        duration of each occurrence and anchors the periodic
                        interval sequence at a certain point in time.
                     </p><p><emph>phase</emph> also marks the anchor point in time for the entire series of
                  periodically recurring intervals. The recurrence of a periodic
                  interval has no begin or end but is infinite in both future and
                  past. A phase must be specified for every non-NULL periodic
                  interval. The width of the phase must be less or equal the period.
               </p><descriptive name="XML Representation"/><p><emph>phase</emph> is represented as the XML element<emph>phase</emph>
                     which, if present, must be a valid <termref ref="dtimpl-IVL">IVL</termref>.
                  </p></div3><div3 id="comp-PIVL.period"><head>Period : T.diff</head><p><emph role="strong">Definition:     </emph>
                        A time duration specifying a reciprocal measure of
                        the frequency at which the periodic interval repeats.
                     </p><p><emph>period</emph> is a <termref ref="dt-QTY">QTY</termref> in the dimension of time
					(T.diff).
					For an uncertain <emph>PIVL</emph><emph/> is a probability
					distribution over elapsed time.
               </p><descriptive name="XML Representation"/><p><emph>period</emph> is represented as the XML element<emph>period</emph>
                     which, if present, must be a valid T.diff.
                  </p></div3><div3 id="comp-PIVL.alignment"><head>Alignment to the Calendar : <termref ref="dtimpl-CS">CS</termref></head><p><emph role="strong">Definition:     </emph>
                     Specifies if and how the repetitions are aligned to
                     the cycles of the underlying calendar (e.g., to
                     distinguish every 30 days from "the 5th of every
                     month".) A non-aligned periodic interval recurs
                     independently from the calendar. An aligned periodic
                     interval is synchronized with the calendar.
                  </p><p><emph>alignment</emph> specifies a calendar cycle to which the
                  periodic interval is aligned. The even flow of time will then be
                  partitioned by the calendar cycle. The partitioning is called the
                  calendar "grid" generated by the aligned-to calendar cycle. The
                  boundaries of each occurrence interval will then have equal distance
                  from the earliest point in each partition. In other words, the
                  distance from the next lower grid-line to the beginning of the
                  interval is constant.
               </p><table id="domain-CalendarCycle"><caption>Domain CalendarCycle</caption><thead><tr valign="bottom"><th>name</th><th>code</th><th>counter</th><th>digits</th><th>start</th><th>condition</th></tr></thead><tbody><tr valign="top"><td>year </td><td>CY </td><td>1 </td><td>4 </td><td>0 </td><td> </td></tr><tr valign="top"><td>month of the year </td><td>MY </td><td>2 </td><td>2 </td><td>1 </td><td> </td></tr><tr valign="top"><td>month (continuous) </td><td>CM </td><td> </td><td> </td><td>0 </td><td> </td></tr><tr valign="top"><td>week (continuous) </td><td>CW </td><td> </td><td> </td><td>0 </td><td> </td></tr><tr valign="top"><td>week of the year </td><td>WY </td><td> </td><td>2 </td><td>1 </td><td> </td></tr><tr valign="top"><td>day of the month </td><td>DM </td><td>3 </td><td>2 </td><td>1 </td><td> </td></tr><tr valign="top"><td>day (continuous) </td><td>CD </td><td> </td><td> </td><td>0 </td><td> </td></tr><tr valign="top"><td>day of the year </td><td>DY </td><td> </td><td>3 </td><td>1 </td><td> </td></tr><tr valign="top"><td>day of the week (begins with Monday) </td><td>DW </td><td> </td><td>1 </td><td>1 </td><td> </td></tr><tr valign="top"><td>hour of the day </td><td>HD </td><td>4 </td><td>2 </td><td>0 </td><td> </td></tr><tr valign="top"><td>hour (continuous) </td><td>CH </td><td> </td><td> </td><td>0 </td><td> </td></tr><tr valign="top"><td>minute of the hour </td><td>NH </td><td>5 </td><td>2 </td><td>0 </td><td> </td></tr><tr valign="top"><td>minute (continuous) </td><td>CN </td><td> </td><td> </td><td>0 </td><td> </td></tr><tr valign="top"><td>second of the minute </td><td>SN </td><td>6 </td><td>2 </td><td>0 </td><td> </td></tr><tr valign="top"><td>second (continuous) </td><td>CS </td><td> </td><td> </td><td>0 </td><td> </td></tr></tbody></table><p>
                  For example, with <emph>every 5th of the month</emph>
                  the alignment calendar cycle would be month of the year
                  (MY.)  The even flow of time is partitioned in months
                  of the year. The distance between the beginning of each
                  month and the beginning of its occurrence interval is 4
                  days (4 days because day of month (DM) starts counting
                  with 1.)  Thus, as months differ in their number of days,
                  the distances between the recurring intervals will vary
                  slightly, so that the interval occurs always on the 5th.
               </p><descriptive name="XML Representation"/><p><emph>alignment</emph> is represented as the XML attribute<emph>alignment</emph>,
                     whose value, if present, must be a valid code from the
                     domain CalenderCycle (<tabref ref="domain-CalendarCycle"/>).
                  </p></div3><div3 id="comp-PIVL.institutionSpecified"><head>Institution Specified Timing : <termref ref="dtimpl-BL">BL</termref></head><p><emph role="strong">Definition:     </emph>
                     Indicates whether the exact timing is up to the party
                     executing the schedule (e.g., to distinguish "every 8
                     hours" from "3 times a day".)
                  </p><p>
                  For example, with a schedule "three times a day" the average
                  time between repetitions is 8 hours, however, with institution
                  specified time indicator <emph>true</emph>, the timing could
                  follow some rule made by the executing person or organization
                  ("institution"), that, e.g., three times a day schedules are
                  executed at 7 am, noon, and 7 pm.
               </p><descriptive name="XML Representation"/><p><emph>institutionSpecified</emph> is represented as the XML attribute<emph>institutionSpecified</emph>,
                     whose value, if present, must be a valid <termref ref="dtimpl-BL">BL</termref>.
                     The default	value is <emph>false</emph>.
                  </p></div3><div3 id="PIVL-examples"><head>Examples</head><p>
                  The first example shows twice a day (BID), i.e.,
                  every 2 hours, at institution specified times.
               </p><exhibit role="example" verbatim="yes">
&lt;effectiveTime xsi:type='PIVL_TS' institutionSpecified='true'&gt;
   &lt;period value='12' unit='h'/&gt;
&lt;/effectiveTime&gt;</exhibit><p>
                  The next examples shows twice a day for ten minutes.
               </p><exhibit role="example" verbatim="yes">
&lt;effectiveTime xsi:type='PIVL_TS'&gt;
   &lt;phase&gt;
      &lt;width value='10' unit='min'/&gt;
   &lt;/phase&gt;
   &lt;period value='12' unit='h'/&gt;
&lt;/effectiveTime&gt;</exhibit><p>
                  The next example is slightly more complex and shows
                  the month of September that recurs every year (note that in the
                  year 1987 in this form is irrelevant since the
                  periodic interval recurs every year past and future.)
               </p><exhibit role="example" verbatim="yes">
&lt;effectiveTime xsi:type='PIVL_TS' alignment='MY'&gt;
   &lt;phase&gt;
      &lt;low value='198709' inclusive='true'/&gt;
      &lt;high value='198710' inclusive='false'/&gt;
   &lt;/phase&gt;
   &lt;period value='1' unit='a'/&gt;
&lt;/effectiveTime&gt;</exhibit><p>
                  The next example shows every other Saturday.
               </p><exhibit role="example" verbatim="yes">
&lt;effectiveTime xsi:type='PIVL_TS' alignment='DW'&gt;
   &lt;phase&gt;
      &lt;low value='20001202' inclusive='true'/&gt;
      &lt;high value='20001203' inclusive='false'/&gt;
   &lt;/phase&gt;
   &lt;period value='2' unit='wk'/&gt;
&lt;/effectiveTime&gt;</exhibit><p>
                  The last example shows every four to six hours.
               </p><exhibit role="example" verbatim="yes">
&lt;effectiveTime xsi:type='PIVL_PPD_TS'&gt;
   &lt;period value='5' unit='h' distributionType='U'&gt;
      &lt;standardDeviation value='0.57735' unit='h'/&gt;
   &lt;/period&gt;
&lt;/effectiveTime&gt;</exhibit></div3></div2><div2 id="dtimpl-EIVL"><head><anchor id="EIVL"/>Event-Related Interval of Time (EIVL) specializes <termref ref="dtimpl-SXCM">SXCM</termref></head><p><emph role="strong">Definition:     </emph>
            Specifies a periodic interval of time where the
            recurrence is based on activities of daily living
            or other important events that are time-related but
            not fully determined by time.
         </p><p>
               For example, "one hour after breakfast" specifies the
               beginning of the interval at one hour after breakfast is
               finished. Breakfast is assumed to occur before lunch but
               is not determined to occur at any specific time.
            </p><table id="dtimpl-EIVL-comp-summary"><caption>Components of
      Event-Related Interval of Time</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">event</termref></td><td><termref ref="dtimpl-CS">CS</termref></td><td>
                        A code for a common (periodical) activity of daily
                        living based on which the event related periodic
                        interval is specified.
                     </td></tr><tr><td><termref ref="">offset</termref></td><td>IVL&lt;T.diff&gt;</td><td>
                        An interval of elapsed time (duration, not absolute
                        point in time) that marks the offsets for the
                        beginning, width and end of the event-related periodic
                        interval measured from the time each such event
                        actually occurred.
                     </td></tr></tbody></table><descriptive name="XML Representation"/><p><emph>EIVL</emph> is represented by an XML element
                  whose name is determined by the context in which it is
                  used. <emph>EIVL</emph> has all the attributes and child
                  elements as described in the template and sub-sections
                  below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type EIVL --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   operator = (I | E | A | H | P)
   &gt;
   <emph>Content</emph>: ( event, offset )
&lt;/x&gt;
</exhibit><div3 id="comp-EIVL.event"><head>Event : <termref ref="dtimpl-CS">CS</termref></head><p><emph role="strong">Definition:     </emph>
                        A code for a common (periodical) activity of daily
                        living based on which the event related periodic
                        interval is specified.
                     </p><p>
                  Such events qualify for being adopted in the domain of this
                  attribute for which all of the following is true:
               </p><list role="unordered"><item>the event commonly occurs on a regular basis,</item><item>the event is being used for timing activities, and</item><item>the event is not entirely determined by time.</item></list><table id="domain-TimingEvent"><caption>Domain TimingEvent</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><td>AC</td><td>AC</td><td>before meal (from lat. ante cibus)</td></tr><tr valign="top"><td>ACD</td><td>ACT</td><td>before lunch (from lat. ante cibus diurnus)</td></tr><tr valign="top"><td>ACM</td><td>ACM</td><td>before breakfast (from lat. ante cibus matutinus)</td></tr><tr valign="top"><td>ACV</td><td>ACV</td><td>before dinner (from lat. ante cibus vespertinus)</td></tr><tr valign="top"><td>HS</td><td>HS</td><td>the hour of sleep</td></tr><tr valign="top"><td>IC</td><td>IC</td><td>between meals (from lat. inter cibus)</td></tr><tr valign="top"><td>ICD</td><td>ICD</td><td>between lunch and dinner</td></tr><tr valign="top"><td>ICM</td><td>ICM</td><td>between breakfast and lunch</td></tr><tr valign="top"><td>ICV</td><td>ICV</td><td>between dinner and the hour of sleep</td></tr><tr valign="top"><td>PC</td><td>PC</td><td>after meal (from lat. post cibus)</td></tr><tr valign="top"><td>PCD</td><td>PCD</td><td>after lunch (from lat. post cibus diurnus)</td></tr><tr valign="top"><td>PCM</td><td>PCM</td><td>after breakfast (from lat. post cibus matutinus)</td></tr><tr valign="top"><td>PCV</td><td>PCV</td><td>after dinner (from lat. post cibus vespertinus)</td></tr></table><!--
                  <entry code="AC" printName="before meal"/>
                  <entry code="ACM" printName="before breakfast"/>
                  <entry code="ACD" printName="before lunch"/>
                  <entry code="ACV" printName="before dinner"/>
                  <entry code="HS" printName="hour of sleep"/>
                  <entry code="IC" printName="between meals"/>
                  <entry code="ICM" printName="between breakfast and lunch"/>
                  <entry code="ICD" printName="between lunch and dinner"/>
                  <entry code="ICV" printName="between dinner and the hour of sleep"/>
                  <entry code="PC" printName="after meals"/>
                  <entry code="PCM" printName="after breakfast"/>
                  <entry code="PCD" printName="after lunch"/>
                  <entry code="PCV" printName="after dinner"/>
               </domain>
  --><descriptive name="XML Representation"/><p><emph>event</emph> is represented as the XML element<emph>event</emph>
                     which, if present, must be a valid <termref ref="dtimpl-CE">CE</termref>,
                     whose <termref ref="comp-CE.code">CE.code</termref> must be a valid value from
                     the TimingEvent domain (<tabref ref="domain-TimingEvent"/>).
                  </p><!-- FIXME: how do we bind the CWE domain here? --></div3><div3 id="comp-EIVL.offset"><head>Offset : IVL&lt;T.diff&gt;</head><p><emph role="strong">Definition:     </emph>
                        An interval of elapsed time (duration, not absolute
                        point in time) that marks the offsets for the
                        beginning, width and end of the event-related periodic
                        interval measured from the time each such event
                        actually occurred.
                     </p><p>
                  For example: if the specification is "one hour before
                  breakfast for 10 minutes" the offset's low boundary is
                  1 h and the offset's width is 10 min (consequently the
                  offset's high boundary is 50 min).
                  <!-- gg: todo remove brackets from abastract --></p><descriptive name="XML Representation"/><p><emph>offset</emph> is represented as the XML element<emph>offset</emph>
                     which, if present, must be a valid <termref ref="dtimpl-IVL">IVL</termref>&lt;T.diff&gt;.
                  </p></div3><div3 id="EIVL-examples"><head>Examples</head><p>
                  The first example shows one hour before
                  breakfast for 10 minutes.
               </p><exhibit role="example" verbatim="yes">
&lt;effectiveTime xsi:type='EIVL_TS'&gt;
   &lt;event code='ACM' codeSystem='2.16.840.1.113883.5.139'/&gt;
   &lt;offset&gt;
      &lt;low value='1' unit ='h'/&gt;
      &lt;width value='10' unit='min'/&gt;
   &lt;/offset&gt;
&lt;/effectiveTime&gt;</exhibit><p>
					The next example shows 30 minutes after dinner.
				</p><exhibit role="example" verbatim="yes">
&lt;effectiveTime xsi:type='EIVL_TS'&gt;
   &lt;event code='PCV' codeSystem='2.16.840.1.113883.5.139'/&gt;
   &lt;offset&gt;
      &lt;center value='30' unit ='min'/&gt;
   &lt;/offset&gt;
&lt;/effectiveTime&gt;</exhibit></div3></div2><div2 id="dtimpl-SXPR"><head><anchor id="SXPR"/>Parenthetic Set Expression (SXPR) specializes <termref ref="dtimpl-SXCM">SXCM</termref></head><p><emph role="strong">Definition:     </emph>
            A set-component that is itself made up of set-components
            that are evaluated as one value.
         </p><descriptive name="XML Representation"/><p><emph>SXPR</emph> is represented by an XML element
                  whose name is determined by the context in
                  which it is used. <emph>SXPR</emph> has all the
                  attributes and child elements as described in the
                  template and sub-sections below. <emph>SXPR</emph>
                  can be used in place of any
                  <termref ref="dtimpl-SXCM">SXCM</termref>.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type SXPR --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   operator = (I | E | A | H | P)
   &gt;
   <emph>Content</emph>: ( comp, comp+ )
&lt;/x&gt;
</exhibit><p>
                  There must be at least 2 comp elements.
               </p><div3 id="comp-SXPR.expr"><head>Sub-Expression : <termref ref="dtimpl-SXCM">SXCM</termref></head><p><emph role="strong">Definition:     </emph>
                     A component of a parenthetic set expression.
                  </p><descriptive name="XML Representation"/><p><emph>comp</emph> is represented by the
                     XML element<emph>comp</emph> which, if present, must be a
                     valid <termref ref="dtimpl-SXCM">SXCM</termref>.
                  </p></div3><div3 id="SXPR-examples"><head>Examples</head><p>
					The first example shows daily at noon, starting on February 4 2004.
				</p><exhibit role="example" verbatim="yes">
&lt;effectiveTime xsi:type='SXPR_TS'&gt;
   &lt;comp xsi:type='IVL_TS'&gt;
      &lt;low value='20040204'/&gt;
   &lt;/comp&gt;
   &lt;comp xsi:type='PIVL_TS' operator='A'&gt;
      &lt;phase&gt;
         &lt;center value='200402041200'/&gt;
      &lt;/phase&gt;
      &lt;period value='1' unit='d' /&gt;
   &lt;/comp&gt;
&lt;/effectiveTime&gt;</exhibit><p>
					The first example shows four times a day (at insitution specified times)
					starting on June 3, 2005.
				</p><exhibit role="example" verbatim="yes">
&lt;effectiveTime xsi:type='SXPR_TS'&gt;
   &lt;comp xsi:type='IVL_TS'&gt;
      &lt;low value='20050603' /&gt;
   &lt;/comp&gt;
   &lt;comp xsi:type='PIVL_TS' operator='A' institutionSpecified='true'&gt;
      &lt;period value='6' unit='h' /&gt;
   &lt;/comp&gt;
&lt;/effectiveTime&gt;</exhibit></div3></div2></div1></body><back><div1 id="informative" ballotStatus="Reference"><head>Informative Types</head><p>
            These types are currently marked as informative while known
            issues relating to their design are being resolved.
         </p><div2 id="dtimpl-PPD"><head><anchor id="PPD"/>Parametric Probability Distribution (PPD)</head><p><emph role="strong">Definition:     </emph>
            A generic data type extension specifying uncertainty of
            quantitative data using a distribution function and its
            parameters. Aside from the specific parameters of the
            distribution, a mean (expected value) and standard
            deviation is always given to help maintain a minimum layer
            of interoperability if receiving applications cannot deal
            with a certain probability distribution.
         </p><p>
               For example, the most common college entrance exam in the
               United States is the SAT, which is comprised of two parts:
               verbal and math. Each part has a minimum score of 400 (no
               questions answered correctly) and a perfect score of 800.
               In 1998, according to the College Board, 1,172,779
               college-bound seniors took the test. The mean score for the
               math portion of the test was 512, and the standard deviation
               112. These parameter values (512, 112), tagged as the normal
               distribution parameters, paint a pretty good picture of test
               score distribution. In most cases, there is no need to
               specify all 1-million+ points of data when just 2 parameters
               will do!
            </p><graphic source="graphics/DT-PPD-ex1.gif" alt="Parametric Probability Distribution"/><p>
               Note that the normal distribution is only one of several
               distributions defined for HL7.
            </p><table id="dtimpl-PPD-comp-summary"><caption>Components of
      Parametric Probability Distribution</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="">standardDeviation</termref></td><td>T.diff</td><td>
                        The primary measure of variance/uncertainty of the
                        value (the square root of the sum of the squares of
                        the differences between all data points and the mean).
                        The standard deviation is used to normalize the data
                        for computing the distribution function. Applications
                        that cannot deal with probability distributions can
                        still get an idea about the confidence level by looking
                        at the standard deviation.
                     </td></tr><tr><td><termref ref="">distributionType</termref></td><td><termref ref="dtimpl-CS">CS</termref></td><td>
                     A code specifying the type of probability distribution.
                     Possible values are as shown in the attached table.
                     The NULL value (unknown) for the type code indicates
                     that the probability distribution type is unknown. In
                     that case, the standard deviation has the meaning of an
                     informal guess.
                  </td></tr></tbody></table><p>
               Since <emph>PPD</emph> extends its parameter type T, a simple T value
               is the mean (expected value or first moment) of the
               probability distribution. Applications that cannot deal with
               distributions will take the simple T value neglecting the
               uncertainty. That simple value of type T is also used to
               standardize the data for computing the distribution.
            </p><p>
               Probability distributions are defined over integer or
               real numbers and normalized to a certain reference point
               (typically zero) and reference unit (e.g., standard
               deviation = 1). When other quantities defined in this
               specification are used as base types, the mean and the
               standard deviation are used to scale the probability
               distribution. For example, if a PPD&lt;<termref ref="dtimpl-PQ">PQ</termref>&gt; for a length is given with mean 20 ft
               and a standard deviation of 2 in, the normalized
               distribution function <emph>f</emph>(<emph>x</emph>) that
               maps a real number <emph>x</emph> to a probability density
               would be translated to
               <emph>f</emph>&#8242;(<emph>x</emph>&#8242;) that maps
               a length <emph>x</emph>&#8242; to a probability density as
               <emph>f</emph>&#8242;(<emph>x</emph>&#8242;) =
               <emph>f</emph>((<emph>x</emph>&#8242; - &#956;) / &#963;).
            </p><p>
               Where applicable, <emph>PPD</emph> conforms to the
               ISO <emph>Guide to the Expression of Uncertainty in
               Measurement</emph> (GUM) as reflected by NIST publication
               1297 <emph>Guidelines for Evaluating and Expressing the
               Uncertainty of NIST Measurement Results</emph>.
               <emph>PPD</emph> does not describe how uncertainty
               is to be evaluated but only how it is expressed. The
               concept of "standard uncertainty" as set forth by the
               ISO GUM corresponds to <termref ref="comp-PPD.standardDeviation">standardDeviation</termref>.
            </p><descriptive name="XML Representation"/><p><emph>PPD</emph> is represented by an XML element
                  whose name is determined by the context in which it is
                  used. <emph>PPD</emph> has all the attributes and
                  child elements defined for the type T and adds the
                  attributes and elements defined in the type template
                  and subsections below.
               </p><exhibit role="template" verbatim="yes">
&lt;!-- type PPD --&gt;
&lt;x
   nullFlavor = (NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | NP)
   <emph>{any attributes from T}</emph>
   distributionType  = CS
   &gt;
   <emph>Content</emph>: ( <emph>{any elements from T}</emph>, standardDeviation )
&lt;/x&gt;
</exhibit><div3 id="comp-PPD.standardDeviation"><head>Standard Deviation : T.diff</head><p><emph role="strong">Definition:     </emph>
                        The primary measure of variance/uncertainty of the
                        value (the square root of the sum of the squares of
                        the differences between all data points and the mean).
                        The standard deviation is used to normalize the data
                        for computing the distribution function. Applications
                        that cannot deal with probability distributions can
                        still get an idea about the confidence level by looking
                        at the standard deviation.
                     </p><descriptive name="XML Representation"/><p><emph>standardDeviation</emph> is represented by the
                     XML element<emph>standardDeviation</emph> which, if present,
                     must be a valid T.diff.
                  </p></div3><div3 id="comp-PPD.distributionType"><head>Probability Distribution Type : <termref ref="dtimpl-CS">CS</termref></head><p><emph role="strong">Definition:     </emph>
                     A code specifying the type of probability distribution.
                     Possible values are as shown in the attached table.
                     The NULL value (unknown) for the type code indicates
                     that the probability distribution type is unknown. In
                     that case, the standard deviation has the meaning of an
                     informal guess.
                  </p><p><tabref ref="domain-ProbabilityDistributionType"/> lists the defined
                     probability distributions. Many distribution types are defined in
                     terms of special parameters (e.g., the parameters &#945; and &#946;
                     for the &#947;-distribution, number of degrees of freedom for the
                     <emph>t</emph>-distribution, etc.)  For all distribution types,
                     however, the mean and standard deviation are defined. <emph>PPD</emph>
                     is specified with the parameters mean and standard distribution
                     only. The definition column contains the relationship between the
                     special parameters and the mean &#956; and standard deviation &#963;.
                  </p><table id="domain-ProbabilityDistributionType"><caption>Domain ProbabilityDistributionType</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><td>(NULL)</td><td>unknown</td><td>
                        Used to indicate that the mean is estimated without
                        any closer consideration of its probability distribution.
                        In this case, the meaning of the standard deviation is not
                        crisply defined. However, interpretation should be along
                        the lines of the normal distribution, e.g., the interval
                        covered by the mean ±1 standard deviation
                        should be at the level of about two thirds confidence.
                     </td></tr><tr valign="top"><td>U</td><td>uniform</td><td>
                        The uniform distribution assigns a constant probability
                        over the entire interval of possible outcomes, while
                        all outcomes outside this interval are assumed to have
                        zero probability. The width of this interval is 2 &#963;
                        &#8730;3. Thus, the uniform distribution assigns the
                        probability densities <emph>f</emph>(x) = (2 &#963; &#8730;3)
                        <emph role="sup">-1</emph> to values &#956; - &#963; &#8730;3
                        &#8805; x &#8804; &#956; + &#963; &#8730;3 and <emph>f</emph>(x)
                        = 0 otherwise.
                     </td></tr><tr valign="top"><td>N</td><td>normal (Gaussian)</td><td>
                        This is the well-known bell-shaped normal distribution.
                        Because of the central limit theorem, the normal
                        distribution is the distribution of choice for an
                        unbounded random variable that is an outcome of a
                        combination of many stochastic processes. Even for
                        values bounded on a single side (i.e. greater than
                        0) the normal distribution may be accurate enough
                        if the mean is "far away" from the bound of the scale
                        measured in terms of standard deviations.
                     </td></tr><tr valign="top"><td>LN</td><td>log-normal</td><td>
                        The logarithmic normal distribution is used to
                        transform skewed random variable X into a normally
                        distributed random variable <emph>U</emph>
                        = log <emph>X</emph>. The log-normal distribution
                        can be specified with the properties mean &#956; and
                        standard deviation &#963;. Note however that mean
                        &#956; and standard deviation &#963; are the
                        parameters of the raw value distribution, not the
                        transformed parameters of the lognormal distribution
                        that are conventionally referred to by the same
                        letters. Those log-normal parameters &#956;
                        <emph role="sub">log</emph> and &#963;<emph role="sub">log</emph> relate to the mean &#956; and
                        standard deviation &#963; of the data value through
                        &#963;<emph role="sub">log</emph><emph role="sup">2</emph>
                        = log (&#963;<emph role="sup">2</emph>/&#956;<emph role="sup">2</emph> + 1) and &#956;log = log &#956; -
                        &#963;<emph role="sub">log</emph><emph role="sup">2</emph>/2.
                     </td></tr><tr valign="top"><td>G</td><td>&#947; (gamma)</td><td>
                        The gamma-distribution used for data that is
                        skewed and bounded to the right, i.e. where the
                        maximum of the distribution curve is located
                        near the origin. The &#947;-distribution has
                        two parameters &#945; and &#946;. The relationship
                        to mean &#956; and variance &#963;
                        <emph role="sup">2</emph> is &#956; = &#945; &#946;
                        and &#963;<emph role="sup">2</emph> = &#945;
                        &#946;<emph role="sup">2</emph>.
                     </td></tr><tr valign="top"><td>E</td><td>exponential</td><td>
                        Used for data that describes extinction. The
                        exponential distribution is a special form of
                        &#947;-distribution where &#945; = 1, hence,
                        the relationship to mean &#956; and variance &#963;
                        <emph role="sup">2</emph> are &#956; = &#946; and &#963;
                        <emph role="sup">2</emph> = &#946;<emph role="sup">2</emph>.
                     </td></tr><tr valign="top"><td>X2</td><td>&#967;</td><td>
                        Used to describe the sum of squares of random
                        variables that occurs when a variance is
                        estimated (rather than presumed) from the
                        sample. The only parameter of the &#967;<emph role="sup">2</emph>-distribution is &#965;,
                        so called the <emph>number of degrees of
                        freedom</emph> (which is the number of independent
                        parts in the sum). The
                        &#967;<emph role="sup">2</emph>-distribution is a
                        special type of &#947;-distribution with parameter
                        &#945; = &#965; /2 and &#946; = 2. Hence,
                        &#956; = &#965; and &#963;<emph role="sup">2</emph>
                        = 2 &#965;.
                     </td></tr><tr valign="top"><td>T</td><td>t (Student)</td><td>
                        Used to describe the quotient of a normal random
                        variable and the square root of a &#967;<emph role="sup">2</emph> random variable. The
                        <emph>t</emph>-distribution has one parameter
                        &#965;, the number of degrees of freedom.
                        The relationship to mean &#956; and variance
                        &#963;<emph role="sup">2</emph> are: &#956; = 0
                        and &#963; <emph role="sup">2</emph> = &#965;
                        / (&#965; - 2).
                     </td></tr><tr valign="top"><td>F</td><td>F</td><td>
                        Used to describe the quotient of two &#967;<emph role="sup">2</emph> random variables. The
                        <emph>F</emph>-distribution has two parameters
                        &#965;<emph role="sub">1</emph> and &#965;<emph role="sub">2</emph>, which are the numbers of
                        degrees of freedom of the numerator and denominator
                        variable respectively. The relationship to mean
                        &#956; and variance &#963;<emph role="sup">2</emph>
                        are: &#956; = &#965;<emph role="sub">2</emph> /
                        (&#965;<emph role="sub">2</emph> - 2) and
                        &#963;<emph role="sup">2</emph> = (2 &#965;<emph role="sub">2</emph> (&#965;<emph role="sub">2</emph>
                        + &#965;<emph role="sub">1</emph> - 2)) / (&#965;
                        <emph role="sub">1</emph> (&#965;<emph role="sub">2</emph> - 2)
                        <emph role="sup">2</emph> (&#965;<emph role="sub">2</emph> - 4)).
                     </td></tr><tr valign="top"><td>B</td><td>&#946; (beta)</td><td>
                        The beta-distribution is used for data that is
                        bounded on both sides and may or may not be skewed
                        (e.g., occurs when probabilities are estimated.)
                        Two parameters &#945; and &#946; are available to
                        adjust the curve. The mean &#956; and variance
                        &#963;<emph role="sup">2</emph> relate as follows:
                        &#956; = &#945; / (&#945; + &#946;) and
                        (&#963;<emph role="sup">2</emph> = &#945;
                        &#946;/((&#945; + &#946;)<emph role="sup">2</emph>
                        (&#945; + &#946; + 1)).
                     </td></tr></table><p>
                  The three distribution-types <emph>unknown</emph> (NULL),
                  <emph>uniform</emph> and <emph>normal</emph> must be
                  supported by every system that claims to support PPD.
                  All other distribution types are optional. When a
                  system interpreting a <emph>PPD</emph> representation encounters an
                  unknown distribution type, it maps this type to the
                  unknown (NULL) distribution-type.
               </p><!--
	pvb: 20050704
	since this *is* an ITS, we don't need this note
	
               <note role="its">
                  <p>
                     An ITS does not need to represent any of the
                     specialized parameters for the distribution types.
                     As it turns out, all of these specialized
                     parameters can be calculated from the mean and
                     standard deviation.
                  </p>
               </note>
  --><descriptive name="XML Representation"/><p><emph>distributionType</emph> is represented by the
                     XML attribute<emph>standardDeviation</emph>	whose value, if
                     present, must be a valid code from the
                     ProbabilityDistributionType domain
                     (<tabref ref="domain-ProbabilityDistributionType"/>).
                  </p></div3></div2><div2 id="dtimpl-GTS"><head><anchor id="GTS"/>General Timing Specification (GTS)</head><p><emph role="strong">Definition:     </emph>
            A set of points in time, specifying the timing of events
            and actions and the cyclical validity-patterns that may
            exist for certain kinds of information, such as phone
            numbers (evening, daytime), addresses (so called
            "snowbirds," residing closer to the equator during winter
            and farther from the equator during summer) and office
            hours.
         </p><note><p><emph>GTS</emph> is conceptually nothing other than
                  <termref ref="dtimpl-SET">SET</termref>&lt;<termref ref="dtimpl-TS">TS</termref>&gt;.
               </p></note><p>
               The XML representation of <emph>GTS</emph> is informative but not the
               <emph>GTS</emph> type itself.
            </p><descriptive name="XML Representation"/><p><emph>GTS</emph> is represented as a sequence of XML elements of
                  type <termref ref="dtimpl-SXCM">SXCM</termref>
                  or its specializations, including
                  <termref ref="dtimpl-IVL_TS">IVL&lt;TS&gt;</termref>,
                  <termref ref="dtimpl-PIVL">PIVL</termref>,
                  <termref ref="dtimpl-EIVL">EIVL</termref>,
                  <termref ref="dtimpl-SXPR">SXPR</termref>.
               </p><div3 id="GTS-examples"><head>Examples</head><p>
                  This example shows every other Tuesday in the season from the (US holidays)
                  Memorial Day to Labor Day in the years 2002 and 2003.
               </p><exhibit role="example" verbatim="yes">
&lt;effectiveTime xsi:type='SXPR_TS'&gt;
&lt;!-- memorial day --&gt;
   &lt;comp xsi:type='SXPR_TS'&gt;
      &lt;comp xsi:type='PIVL_TS'&gt;
         &lt;phase&gt;
           &lt;low value='19870525'/&gt;
           &lt;high value='19870601' inclusive='false'/&gt;
         &lt;/phase&gt;
         &lt;period value='1' unit='a'/&gt;
      &lt;/comp&gt;
      &lt;comp xsi:type='PIVL_TS' operator='A'&gt;
         &lt;phase&gt;
            &lt;low value='19870105'/&gt;
            &lt;high value='19870106' inclusive='false'/&gt;
         &lt;/phase&gt;
         &lt;period value='1' unit='wk'/&gt;
      &lt;/comp&gt;
   &lt;/comp&gt;
&lt;!-- labor day --&gt;
   &lt;comp xsi:type='SXPR_TS' operator='P'&gt;
      &lt;comp xsi:type='PIVL_TS'&gt;
         &lt;phase&gt;
            &lt;low value='19870901'/&gt;
            &lt;high value='19870908' inclusive='false'/&gt;
         &lt;/phase&gt;
         &lt;period value='1' unit='a'/&gt;
      &lt;/comp&gt;
      &lt;comp xsi:type='PIVL_TS' operator='A'&gt;
         &lt;phase&gt;
            &lt;low value='19870105'/&gt;
            &lt;high value='19870106' inclusive='false'/&gt;
         &lt;/phase&gt;
         &lt;period value='1' unit='wk'/&gt;
      &lt;/comp&gt;
   &lt;/comp&gt;
&lt;/effectiveTime&gt;
&lt;effectiveTime xsi:type='PIVL_TS' alignment='DW' operator='A'&gt;
&lt;!-- every other Tuesday --&gt;
   &lt;phase&gt;
      &lt;low value='20001202' inclusive='true'/&gt;
      &lt;high value='20001203' inclusive='false'/&gt;
   &lt;/phase&gt;
   &lt;period value='2' unit='wk'/&gt;
&lt;/effectiveTime&gt;
&lt;effectiveTime xsi:type='IVL_TS' operator='A'&gt;
&lt;!-- from 2002 and 2003 --&gt;
   &lt;low value='20020101' inclusive='true'/&gt;
   &lt;high value='20040101' inclusive='false'/&gt;
&lt;/effectiveTime&gt;</exhibit></div3></div2></div1><div1 id="completeSchema" ballotStatus="Reference"><head>W3C XML Schema</head><p>
            The schema representations are provided for convenience,
            as the XML schema is a compact and specific way to describe
            the XML representation. However the schema is not in itself
            a normative part of this specification. While HL7 publishes
            schema for the HL7 data types, other schemas could be
            proposed that describes the same XML representation, and
            these schemas are no less valid, though they may differ in
            their usefulness for a given task. It is the XML
            representation of the data type that is normative.
         </p><p>
            This schema defines a
            <loc href="http://www.w3.org/TR/xmlschema-1#Complex_Type_Definitions" target="schema-rec" xlink-form="simple" show="embed" actuate="auto">complex type</loc>
            for each data type described in this specification as having
            an Element form (e.g., <termref ref="dtimpl-ED">ED</termref> and
            <termref ref="dtimpl-CD">CD</termref>), the name of the
            <loc href="http://www.w3.org/TR/xmlschema-1#Complex_Type_Definitions" target="schema-rec" xlink-form="simple" show="embed" actuate="auto">complex type</loc> is the value of the
            "Symbol" column for the type as given in <tabref ref="dtimpl-summary-table"/>.
         </p><p>
            This schema also defines a
            <loc href="http://www.w3.org/TR/xmlschema-2" target="schema-rec" xlink-form="simple" show="embed" actuate="auto">simple type</loc> for each data type
            described in this specification as having an Attribute form
            (e.g., <termref ref="dtimpl-ST">ST</termref> and
            <termref ref="dtimpl-CS">CS</termref>), the name of the
            <loc href="http://www.w3.org/TR/xmlschema-2" target="schema-rec" xlink-form="simple" show="embed" actuate="auto">simple type</loc> is the lower-case
            version of the "Symbol" column for the type as given in
            <tabref ref="dtimpl-summary-table"/>.
         </p><p>
            For some data types, one or more Schematron [<loc href="http://www.schematron.com" xlink-form="simple" show="embed" actuate="auto"/>] patterns are defined as
            <loc href="http://www.w3.org/TR/xmlschema-1/#cAnnotations" xlink-form="simple" show="embed" actuate="auto">xs:appinfo</loc>
            annotations in either the
            <loc href="http://www.w3.org/TR/xmlschema-1#Complex_Type_Definitions" target="schema-rec" xlink-form="simple" show="embed" actuate="auto">complex type</loc> or
            <loc href="http://www.w3.org/TR/xmlschema-2" target="schema-rec" xlink-form="simple" show="embed" actuate="auto">simple type</loc> defintion.  These
            patterns define additional validation rules that go
            above-and-beyond what can be expressed in XML Schema.  The
            most common rule checks the condition that an instance of
            a type can have either an <attribute>nullFlavor</attribute>
            or some combination of other <attribute/>s but not both.
            Please refer to the Schematron specification
            [<loc href="http://www.schematron.com" xlink-form="simple" show="embed" actuate="auto"/>] for further information.
         </p><p>
            This schema does not completely represent all constraints for
            every data type as specified in the Data Types Abstract
            Specification.  For example, the distinction between
            <termref ref="dtimpl-SET">SET</termref>, <termref ref="dtimpl-BAG">BAG</termref>
            and <termref ref="dtimpl-LIST">LIST</termref> (unique/unordered,
            non-unique/unordered and non-unique/ordered) are not enforced
            by this schema.  The Schematron rules described in above can
            be used to check some, but not all, of these additional
            contraints.  This has the implication that an instance which
            validates against the schema may still not be a valid HL7
            instance.
         </p><p>
            The schema is contained in two separate
            <loc href="http://www.w3.org/TR/xmlschema-1/#key-schemaDoc" xlink-form="simple" show="embed" actuate="auto">schema documents</loc>,
            one for the base types and a smaller one for instantiations
            of generic types. Note: at present, definitions for generic
            types that are used as the type of data type components are
            defined in the <loc href="http://www.w3.org/TR/xmlschema-1/#key-schemaDoc" xlink-form="simple" show="embed" actuate="auto">schema document</loc>
            for the base types.
         </p><div2 id="datatypes-base.xsd"><head>Base Types</head><exhibit role="schema" verbatim="yes">
               
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--
    This schema is generated from a Generic Schema Definition (GSD)
    by gsd2xsl. Do not edit this file.
  --&gt;
&lt;xs:schema xmlns:sch="http://www.ascc.net/xml/schematron"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"
      elementFormDefault="qualified"&gt;
   &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
           Copyright (c) 2001, 2002, 2003, 2004, 2005 Health Level Seven.
           All rights reserved.

           Redistribution and use in source and binary forms, with or
           without modification, are permitted provided that the following
           conditions are met:
           1. Redistributions of source code must retain the above
              copyright notice, this list of conditions and the following
              disclaimer.
           2. Redistributions in binary form must reproduce the above
              copyright notice, this list of conditions and the following
              disclaimer in the documentation and/or other materials
              provided with the distribution.
           3. All advertising materials mentioning features or use of this
              software must display the following acknowledgement:
           
           This product includes software developed by Health Level Seven.
 
           THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS
           ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
           NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
           FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT
           SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
           INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
           DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
           GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
           INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
           WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
           NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
           OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
           DAMAGE.
        
           Generated by $Id: gsd2xsd.xsl,v 1.4 2005/04/17 03:20:15 lmckenzi
           Exp $
&lt;/xs:documentation&gt;
   &lt;/xs:annotation&gt;
   &lt;xs:include schemaLocation="voc.xsd"/&gt;
   &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        Generated by $Id: v3dt-schema.xsl,v 1.5 2005/05/24 05:44:38 lmckenzi
        Exp $
&lt;/xs:documentation&gt;
   &lt;/xs:annotation&gt;
   &lt;xs:complexType name="ANY" abstract="true"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            Defines the basic properties of every data value. This
            is an abstract type, meaning that no value can be just
            a data value without belonging to any concrete type.
            Every concrete type is a specialization of this
            general abstract DataValue type.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:attribute name="nullFlavor" type="NullFlavor" use="optional"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation&gt;
               An exceptional value expressing missing information
               and possibly the reason why the information is missing.
            &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
      &lt;/xs:attribute&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:simpleType name="bl"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            The Boolean type stands for the values of two-valued logic.
            A Boolean value can be either true or
            false, or, as any other value may be NULL.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:restriction base="xs:boolean"&gt;
         &lt;xs:pattern value="true|false"/&gt;
      &lt;/xs:restriction&gt;
   &lt;/xs:simpleType&gt;
   &lt;xs:complexType name="BL"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            The Boolean type stands for the values of two-valued logic.
            A Boolean value can be either true or
            false, or, as any other value may be NULL.
         &lt;/xs:documentation&gt;
         &lt;xs:appinfo&gt;
            &lt;sch:pattern name="validate BL"&gt;
               &lt;sch:rule abstract="true" id="rule-BL"&gt;
                  &lt;sch:report test="(@nullFlavor or @value) and
                     not(@nullFlavor and @value)"/&gt;
               &lt;/sch:rule&gt;
            &lt;/sch:pattern&gt;
         &lt;/xs:appinfo&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="ANY"&gt;
            &lt;xs:attribute name="value" use="optional" type="bl"/&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:simpleType name="bn"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            The BooleanNonNull type is used where a Boolean cannot
            have a null value. A Boolean value can be either
            true or false.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:restriction base="bl"/&gt;
   &lt;/xs:simpleType&gt;
   &lt;xs:complexType name="ANYNonNull"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            The BooleanNonNull type is used where a Boolean cannot
            have a null value. A Boolean value can be either
            true or false.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ANY"&gt;
            &lt;xs:attribute name="nullFlavor" type="NullFlavor"
               use="prohibited"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="BN"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            The BooleanNonNull type is used where a Boolean cannot
            have a null value. A Boolean value can be either
            true or false.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="ANYNonNull"&gt;
            &lt;xs:attribute name="value" use="optional" type="bn"/&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="BIN" abstract="true" mixed="true"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            Binary data is a raw block of bits. Binary data is a
            protected type that MUST not be used outside the data
            type specification.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="ANY"&gt;
            &lt;xs:attribute name="representation" use="optional"
                  type="BinaryDataEncoding" default="TXT"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Specifies the representation of the binary data that
                     is the content of the binary data value.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:simpleType name="bin"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            Binary data is a raw block of bits. Binary data is a
            protected type that MUST not be used outside the data
            type specification.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:restriction base="xs:base64Binary"/&gt;
   &lt;/xs:simpleType&gt;
   &lt;xs:simpleType name="BinaryDataEncoding"&gt;
      &lt;xs:restriction base="xs:NMTOKEN"&gt;
         &lt;xs:enumeration value="B64"/&gt;
         &lt;xs:enumeration value="TXT"/&gt;
      &lt;/xs:restriction&gt;
   &lt;/xs:simpleType&gt;
   &lt;xs:complexType name="ED" mixed="true"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            Data that is primarily intended for human interpretation
            or for further machine processing is outside the scope of
            HL7. This includes unformatted or formatted written language,
            multimedia data, or structured information as defined by a
            different standard (e.g., XML-signatures.)  Instead of the
            data itself, an ED may contain 
            only a reference (see TEL.) Note
            that the ST data type is a
            specialization of the ED data type
            when the ED media type is text/plain.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="BIN"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="reference" type="TEL" minOccurs="0"
                     maxOccurs="1"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        A telecommunication address (TEL), such as a URL
                        for HTTP or FTP, which will resolve to precisely
                        the same binary data that could as well have been
                        provided as inline data.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:element name="thumbnail" minOccurs="0" maxOccurs="1"
                  type="thumbnail"/&gt;
            &lt;/xs:sequence&gt;
            &lt;xs:attribute name="mediaType" type="cs" use="optional"
                  default="text/plain"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Identifies the type of the encapsulated data and
                     identifies a method to interpret or render the data.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="language" type="cs" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     For character based information the language property
                     specifies the human language of the text.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="compression" type="CompressionAlgorithm"
                  use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Indicates whether the raw byte data is compressed,
                     and what compression algorithm was used.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="integrityCheck" type="bin" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     The integrity check is a short binary value representing
                     a cryptographically strong checksum that is calculated
                     over the binary data. The purpose of this property, when
                     communicated with a reference is for anyone to validate
                     later whether the reference still resolved to the same
                     data that the reference resolved to when the encapsulated
                     data value with reference was created.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="integrityCheckAlgorithm"
                  type="IntegrityCheckAlgorithm" use="optional"
                  default="SHA-1"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Specifies the algorithm used to compute the
                     integrityCheck value.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="thumbnail" mixed="true"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
                     A thumbnail is an abbreviated rendition of the full
                     data. A thumbnail requires significantly fewer
                     resources than the full data, while still maintaining
                     some distinctive similarity with the full data. A
                     thumbnail is typically used with by-reference
                     encapsulated data. It allows a user to select data
                     more efficiently before actually downloading through
                     the reference.
                  &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ED"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="reference" type="TEL" minOccurs="0"
                  maxOccurs="1"/&gt;
               &lt;xs:element name="thumbnail" type="thumbnail" minOccurs="0"
                  maxOccurs="0"/&gt;
            &lt;/xs:sequence&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:simpleType name="st"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            The character string data type stands for text data,
            primarily intended for machine processing (e.g.,
            sorting, querying, indexing, etc.) Used for names,
            symbols, and formal expressions.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:restriction base="xs:string"&gt;
         &lt;xs:minLength value="1"/&gt;
      &lt;/xs:restriction&gt;
   &lt;/xs:simpleType&gt;
   &lt;xs:complexType name="ST" mixed="true"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            The character string data type stands for text data,
            primarily intended for machine processing (e.g.,
            sorting, querying, indexing, etc.) Used for names,
            symbols, and formal expressions.
         &lt;/xs:documentation&gt;
         &lt;xs:appinfo&gt;
            &lt;sch:pattern name="validate ST"&gt;
               &lt;sch:rule abstract="true" id="rule-ST"&gt;
                  &lt;sch:report test="(@nullFlavor or text()) and
                        not(@nullFlavor and text())"&gt;
                     &lt;p&gt;
                        Text content is only allowed in non-NULL
                        values.
                     &lt;/p&gt;
                  &lt;/sch:report&gt;
               &lt;/sch:rule&gt;
            &lt;/sch:pattern&gt;
         &lt;/xs:appinfo&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ED"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="reference" type="TEL" minOccurs="0"
                  maxOccurs="0"/&gt;
               &lt;xs:element name="thumbnail" type="ED" minOccurs="0"
                  maxOccurs="0"/&gt;
            &lt;/xs:sequence&gt;
            &lt;xs:attribute name="representation" type="BinaryDataEncoding"
               fixed="TXT"/&gt;
            &lt;xs:attribute name="mediaType" type="cs" fixed="text/plain"/&gt;
            &lt;xs:attribute name="language" type="cs" use="optional"/&gt;
            &lt;xs:attribute name="compression" type="CompressionAlgorithm"
               use="prohibited"/&gt;
            &lt;xs:attribute name="integrityCheck" type="bin" use="prohibited"/&gt;
            &lt;xs:attribute name="integrityCheckAlgorithm"
               type="IntegrityCheckAlgorithm" use="prohibited"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:simpleType name="cs"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            Coded data in its simplest form, consists of a code.
            The code system and code system version is fixed by 
            the context in which the CS value occurs. CS is used
            for coded attributes that have a single HL7-defined
            value set.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:restriction base="xs:token"&gt;
         &lt;xs:pattern value="[^\s]+"/&gt;
      &lt;/xs:restriction&gt;
   &lt;/xs:simpleType&gt;
   &lt;xs:complexType name="CD"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            A concept descriptor represents any kind of concept usually
            by giving a code defined in a code system.  A concept
            descriptor can contain the original text or phrase that
            served as the basis of the coding and one or more
            translations into different coding systems. A concept
            descriptor can also contain qualifiers to describe, e.g.,
            the concept of a "left foot" as a postcoordinated term built
            from the primary code "FOOT" and the qualifier "LEFT".
            In exceptional cases, the concept descriptor need not
            contain a code but only the original text describing
            that concept.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="ANY"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="originalText" type="ED" minOccurs="0"
                     maxOccurs="1"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        The text or phrase used as the basis for the coding.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:element name="qualifier" type="CR" minOccurs="0"
                     maxOccurs="unbounded"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        Specifies additional codes that increase the
                        specificity of the primary code.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:element name="translation" type="CD" minOccurs="0"
                     maxOccurs="unbounded"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        A set of other concept descriptors that translate
                        this concept descriptor into other code systems.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
            &lt;xs:attribute name="code" type="cs" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     The plain code symbol defined by the code system.
                     For example, "784.0" is the code symbol of the ICD-9
                     code "784.0" for headache.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="codeSystem" type="uid" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Specifies the code system that defines the code.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="codeSystemName" type="st" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A common name of the coding system.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="codeSystemVersion" type="st" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     If applicable, a version descriptor defined
                     specifically for the given code system.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="displayName" type="st" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A name or title for the code, under which the sending
                     system shows the code value to its users.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="CE"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            Coded data, consists of a coded value (CV)
            and, optionally, coded value(s) from other coding systems
            that identify the same concept. Used when alternative
            codes may exist.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="CD"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="originalText" type="ED" minOccurs="0"
                     maxOccurs="1"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        The text or phrase used as the basis for the coding.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:element name="qualifier" type="CR" minOccurs="0"
                  maxOccurs="0"/&gt;
               &lt;xs:element name="translation" type="CD" minOccurs="0"
                     maxOccurs="unbounded"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        A set of other concept descriptors that translate
                        this concept descriptor into other code systems.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
            &lt;xs:attribute name="code" type="cs" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     The plain code symbol defined by the code system.
                     For example, "784.0" is the code symbol of the ICD-9
                     code "784.0" for headache.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="codeSystem" type="uid" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Specifies the code system that defines the code.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="codeSystemName" type="st" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A common name of the coding system.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="codeSystemVersion" type="st" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     If applicable, a version descriptor defined
                     specifically for the given code system.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="displayName" type="st" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A name or title for the code, under which the sending
                     system shows the code value to its users.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="CV"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            Coded data, consists of a code, display name, code system,
            and original text. Used when a single code value must be sent.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="CE"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="originalText" type="ED" minOccurs="0"
                     maxOccurs="1"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        The text or phrase used as the basis for the coding.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:element name="translation" type="CD" minOccurs="0"
                  maxOccurs="0"/&gt;
            &lt;/xs:sequence&gt;
            &lt;xs:attribute name="code" type="cs" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     The plain code symbol defined by the code system.
                     For example, "784.0" is the code symbol of the ICD-9
                     code "784.0" for headache.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="codeSystem" type="uid" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Specifies the code system that defines the code.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="codeSystemName" type="st" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A common name of the coding system.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="codeSystemVersion" type="st" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     If applicable, a version descriptor defined
                     specifically for the given code system.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="displayName" type="st" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A name or title for the code, under which the sending
                     system shows the code value to its users.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="CS"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            Coded data, consists of a code, display name, code system,
            and original text. Used when a single code value must be sent.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="CV"&gt;
            &lt;xs:attribute name="code" type="cs" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     The plain code symbol defined by the code system.
                     For example, "784.0" is the code symbol of the ICD-9
                     code "784.0" for headache.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="codeSystem" type="uid" use="prohibited"/&gt;
            &lt;xs:attribute name="codeSystemName" type="st" use="prohibited"/&gt;
            &lt;xs:attribute name="codeSystemVersion" type="st" use="prohibited"/&gt;
            &lt;xs:attribute name="displayName" type="st" use="prohibited"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="CO"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            Coded data, where the domain from which the codeset comes
            is ordered. The Coded Ordinal data type adds semantics
            related to ordering so that models that make use of such
            domains may introduce model elements that involve statements
            about the order of the terms in a domain. 
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="CV"/&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="CR"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            A concept qualifier code with optionally named role.
            Both qualifier role and value codes must be defined by
            the coding system.  For example, if SNOMED RT defines a
            concept "leg", a role relation "has-laterality", and
            another concept "left", the concept role relation allows
            to add the qualifier "has-laterality: left" to a primary
            code "leg" to construct the meaning "left leg".
         &lt;/xs:documentation&gt;
         &lt;xs:appinfo&gt;
            &lt;sch:pattern name="validate CR"&gt;
               &lt;sch:rule abstract="true" id="rule-CR"&gt;
                  &lt;sch:report test="(value or @nullFlavor) and
                        not(@nullFlavor and node())"&gt;
                     &lt;p&gt;
                        A value component is required or else the
                        code role is NULL.
                     &lt;/p&gt;
                  &lt;/sch:report&gt;
               &lt;/sch:rule&gt;
            &lt;/sch:pattern&gt;
         &lt;/xs:appinfo&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="ANY"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="name" type="CV" minOccurs="0" maxOccurs="1"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        Specifies the manner in which the concept role value
                        contributes to the meaning of a code phrase.  For
                        example, if SNOMED RT defines a concept "leg", a role
                        relation "has-laterality", and another concept "left",
                        the concept role relation allows to add the qualifier
                        "has-laterality: left" to a primary code "leg" to
                        construct the meaning "left leg".  In this example
                        "has-laterality" is the CR.name.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:element name="value" type="CD" minOccurs="0" maxOccurs="1"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        The concept that modifies the primary code of a code
                        phrase through the role relation.  For example, if
                        SNOMED RT defines a concept "leg", a role relation
                        "has-laterality", and another concept "left", the
                        concept role relation allows adding the qualifier
                        "has-laterality: left" to a primary code "leg" to
                        construct the meaning "left leg".  In this example
                        "left" is the CR.value.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
            &lt;xs:attribute name="inverted" type="bn" use="optional"
                  default="false"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Indicates if the sense of the role name is inverted.
                     This can be used in cases where the underlying code
                     system defines inversion but does not provide reciprocal
                     pairs of role names. By default, inverted is false.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="SC" mixed="true"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            A ST that optionally may have a code attached.
            The text must always be present if a code is present. The
            code is often a local code.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="ST"&gt;
            &lt;xs:attribute name="code" type="cs" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     The plain code symbol defined by the code system.
                     For example, "784.0" is the code symbol of the ICD-9
                     code "784.0" for headache.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="codeSystem" type="uid" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Specifies the code system that defines the code.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="codeSystemName" type="st" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A common name of the coding system.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="codeSystemVersion" type="st" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     If applicable, a version descriptor defined
                     specifically for the given code system.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="displayName" type="st" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A name or title for the code, under which the sending
                     system shows the code value to its users.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:simpleType name="uid"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            A unique identifier string is a character string which
            identifies an object in a globally unique and timeless
            manner. The allowable formats and values and procedures
            of this data type are strictly controlled by HL7. At this
            time, user-assigned identifiers may be certain character
            representations of ISO Object Identifiers (OID) and DCE
            Universally Unique Identifiers (UUID). HL7 also reserves
            the right to assign other forms of UIDs, such as mnemonic
            identifiers for code systems.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:union memberTypes="oid uuid ruid"/&gt;
   &lt;/xs:simpleType&gt;
   &lt;xs:simpleType name="oid"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            A globally unique string representing an ISO Object Identifier
            (OID) in a form that consists only of non-negative numbers with
            no leading zeros and dots (e.g., "2.16.840.1.113883.3.1").
            According to ISO, OIDs are paths in a tree structure, with the
            left-most number representing the root and the right-most number
            representing a leaf.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:restriction base="xs:string"&gt;
         &lt;xs:pattern value="[0-2](\.(0|[1-9][0-9]*))*"/&gt;
      &lt;/xs:restriction&gt;
   &lt;/xs:simpleType&gt;
   &lt;xs:simpleType name="uuid"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            A DCE Universal Unique Identifier is a globally unique
            string consisting of 5 groups of upper- or lower-case
            hexadecimal digits having 8, 4, 4, 4, and 12 places
            respectively. UUIDs are assigned using Ethernet MAC
            addresses, the point in time of creation and some random
            components. This mix is believed to generate sufficiently
            unique identifiers without any organizational policy for
            identifier assignment (in fact this piggy-backs on the
            organization of MAC address assignment.)
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:restriction base="xs:string"&gt;
         &lt;xs:pattern value="[0-9a-zA-Z]{8}-[0-9a-zA-Z]{4}-
            [0-9a-zA-Z]{4}-[0-9a-zA-Z]{4}-[0-9a-zA-Z]{12}"/&gt;
      &lt;/xs:restriction&gt;
   &lt;/xs:simpleType&gt;
   &lt;xs:simpleType name="ruid"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            HL7 reserved identifiers are strings consisting only of
            (US-ASCII) letters, digits and hyphens, where the first
            character must be a letter. HL7 may assign these reserved
            identifiers as mnemonic identifiers for major concepts of
            interest to HL7.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:restriction base="xs:string"&gt;
         &lt;xs:pattern value="[A-Za-z][A-Za-z0-9\-]*"/&gt;
      &lt;/xs:restriction&gt;
   &lt;/xs:simpleType&gt;
   &lt;xs:complexType name="II"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            An identifier that uniquely identifies a thing or object.
            Examples are object identifier for HL7 RIM objects,
            medical record number, order id, service catalog item id,
            Vehicle Identification Number (VIN), etc. Instance
            identifiers are defined based on ISO object identifiers.
         &lt;/xs:documentation&gt;
         &lt;xs:appinfo&gt;
            &lt;sch:pattern name="validate II"&gt;
               &lt;sch:rule abstract="true" id="rule-II"&gt;
                  &lt;sch:report test="(@root or @nullFlavor) and
                        not(@root and @nullFlavor)"&gt;
                     A root component is required or else the II value is NULL.
                  &lt;/sch:report&gt;
               &lt;/sch:rule&gt;
            &lt;/sch:pattern&gt;
         &lt;/xs:appinfo&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="ANY"&gt;
            &lt;xs:attribute name="root" type="uid" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A unique identifier that guarantees the global uniqueness
                     of the instance identifier. The root alone may be the
                     entire instance identifier.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="extension" type="st" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A character string as a unique identifier within the
                     scope of the identifier root.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="assigningAuthorityName" type="st"
                  use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A human readable name or mnemonic for the assigning
                     authority. This name may be provided solely for the
                     convenience of unaided humans interpreting an II value
                     and can have no computational meaning. Note: no
                     automated processing must depend on the assigning
                     authority name to be present in any form.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="displayable" type="bl" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Specifies if the identifier is intended for human
                     display and data entry (displayable = true) as
                     opposed to pure machine interoperation (displayable
                     = false).
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:simpleType name="url"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            A telecommunications address  specified according to
            Internet standard RFC 1738
            [http://www.ietf.org/rfc/rfc1738.txt]. The
            URL specifies the protocol and the contact point defined
            by that protocol for the resource.  Notable uses of the
            telecommunication address data type are for telephone and
            telefax numbers, e-mail addresses, Hypertext references,
            FTP references, etc.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:restriction base="xs:anyURI"/&gt;
   &lt;/xs:simpleType&gt;
   &lt;xs:complexType name="URL" abstract="true"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            A telecommunications address  specified according to
            Internet standard RFC 1738
            [http://www.ietf.org/rfc/rfc1738.txt]. The
            URL specifies the protocol and the contact point defined
            by that protocol for the resource.  Notable uses of the
            telecommunication address data type are for telephone and
            telefax numbers, e-mail addresses, Hypertext references,
            FTP references, etc.
         &lt;/xs:documentation&gt;
         &lt;xs:appinfo&gt;
            &lt;sch:pattern name="validate URL"&gt;
               &lt;sch:rule abstract="true" id="rule-URL"&gt;
                  &lt;sch:report test="(@nullFlavor or @value) and
                     not(@nullFlavor and @value)"/&gt;
               &lt;/sch:rule&gt;
            &lt;/sch:pattern&gt;
         &lt;/xs:appinfo&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="ANY"&gt;
            &lt;xs:attribute name="value" type="url" use="optional"/&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:simpleType name="ts"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            A quantity specifying a point on the axis of natural time.
            A point in time is most often represented as a calendar
            expression.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:restriction base="xs:string"&gt;
         &lt;xs:pattern value="[0-9]{1,8}|([0-9]{9,14}|[0-9]{14,14}
            \.[0-9]+)([+\-][0-9]{1,4})?"/&gt;
      &lt;/xs:restriction&gt;
   &lt;/xs:simpleType&gt;
   &lt;xs:complexType name="TS"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            A quantity specifying a point on the axis of natural time.
            A point in time is most often represented as a calendar
            expression.
         &lt;/xs:documentation&gt;
         &lt;xs:appinfo&gt;
            &lt;diff&gt;PQ&lt;/diff&gt;
         &lt;/xs:appinfo&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="QTY"&gt;
            &lt;xs:attribute name="value" use="optional" type="ts"/&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="TEL"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            A telephone number (voice or fax), e-mail address, or
            other locator for a resource (information or service)
            mediated by telecommunication equipment. The address
            is specified as a Universal Resource Locator (URL)
            qualified by time specification and use codes that help
            in deciding which address to use for a given time and
            purpose.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="URL"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="useablePeriod" minOccurs="0"
                     maxOccurs="unbounded" type="SXCM_TS"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                     Specifies the periods of time during which the
                     telecommunication address can be used.  For a
                     telephone number, this can indicate the time of day
                     in which the party can be reached on that telephone.
                     For a web address, it may specify a time range in
                     which the web content is promised to be available
                     under the given address.
                  &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
            &lt;xs:attribute name="use" use="optional"
                  type="set_TelecommunicationAddressUse"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     One or more codes advising a system or user which
                     telecommunication address in a set of like addresses
                     to select for a given telecommunication need.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="ADXP" mixed="true"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            A character string that may have a type-tag signifying its
            role in the address. Typical parts that exist in about
            every address are street, house number, or post box,
            postal code, city, country but other roles may be defined
            regionally, nationally, or on an enterprise level (e.g. in
            military addresses). Addresses are usually broken up into
            lines, which are indicated by special line-breaking
            delimiter elements (e.g., DEL).
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="ST"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Specifies whether an address part names the street,
                     city, country, postal code, post box, etc. If the type
                     is NULL the address part is unclassified and would
                     simply appear on an address label as is.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.delimiter"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="DEL"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.country"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="CNT"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.state"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="STA"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.county"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="CPA"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.city"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="CTY"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.postalCode"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="ZIP"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.streetAddressLine"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="SAL"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.houseNumber"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="BNR"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.houseNumberNumeric"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="BNN"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.direction"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="DIR"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.streetName"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="STR"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.streetNameBase"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="STB"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;&lt;!--
   jaxb implementors note: the jaxb code generator (v1.0.?) will
   fail to append "Type" to streetNameType so that there will be
   duplicate definitions in the java source for streetNameType.
   You will have to fix this manually.
  --&gt;
   &lt;xs:complexType mixed="true" name="adxp.streetNameType"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType"
               fixed="STTYP"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.additionalLocator"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="ADL"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.unitID"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="UNID"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.unitType"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="UNIT"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.careOf"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="CAR"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.censusTract"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="CEN"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.deliveryAddressLine"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="DAL"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.deliveryInstallationType"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType"
               fixed="DINST"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.deliveryInstallationArea"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType"
               fixed="DINSTA"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.deliveryInstallationQualifier"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType"
               fixed="DINSTQ"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.deliveryMode"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="DMOD"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.deliveryModeIdentifier"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType"
               fixed="DMODID"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.buildingNumberSuffix"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="BNS"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.postBox"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="POB"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType mixed="true" name="adxp.precinct"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ADXP"&gt;
            &lt;xs:attribute name="partType" type="AddressPartType" fixed="PRE"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="AD" mixed="true"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            Mailing and home or office addresses. A sequence of
            address parts, such as street or post office Box, city,
            postal code, country, etc.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="ANY"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
                  &lt;xs:element name="delimiter" type="adxp.delimiter"/&gt;
                  &lt;xs:element name="country" type="adxp.country"/&gt;
                  &lt;xs:element name="state" type="adxp.state"/&gt;
                  &lt;xs:element name="county" type="adxp.county"/&gt;
                  &lt;xs:element name="city" type="adxp.city"/&gt;
                  &lt;xs:element name="postalCode" type="adxp.postalCode"/&gt;
                  &lt;xs:element name="streetAddressLine"
                     type="adxp.streetAddressLine"/&gt;
                  &lt;xs:element name="houseNumber" type="adxp.houseNumber"/&gt;
                  &lt;xs:element name="houseNumberNumeric"
                     type="adxp.houseNumberNumeric"/&gt;
                  &lt;xs:element name="direction" type="adxp.direction"/&gt;
                  &lt;xs:element name="streetName" type="adxp.streetName"/&gt;
                  &lt;xs:element name="streetNameBase"
                     type="adxp.streetNameBase"/&gt;
                  &lt;xs:element name="streetNameType"
                     type="adxp.streetNameType"/&gt;
                  &lt;xs:element name="additionalLocator"
                     type="adxp.additionalLocator"/&gt;
                  &lt;xs:element name="unitID" type="adxp.unitID"/&gt;
                  &lt;xs:element name="unitType" type="adxp.unitType"/&gt;
                  &lt;xs:element name="careOf" type="adxp.careOf"/&gt;
                  &lt;xs:element name="censusTract"
                     type="adxp.censusTract"/&gt;
                  &lt;xs:element name="deliveryAddressLine"
                     type="adxp.deliveryAddressLine"/&gt;
                  &lt;xs:element name="deliveryInstallationType"
                     type="adxp.deliveryInstallationType"/&gt;
                  &lt;xs:element name="deliveryInstallationArea"
                     type="adxp.deliveryInstallationArea"/&gt;
                  &lt;xs:element name="deliveryInstallationQualifier"
                     type="adxp.deliveryInstallationQualifier"/&gt;
                  &lt;xs:element name="deliveryMode"
                     type="adxp.deliveryMode"/&gt;
                  &lt;xs:element name="deliveryModeIdentifier"
                     type="adxp.deliveryModeIdentifier"/&gt;
                  &lt;xs:element name="buildingNumberSuffix"
                     type="adxp.buildingNumberSuffix"/&gt;
                  &lt;xs:element name="postBox" type="adxp.postBox"/&gt;
                  &lt;xs:element name="precinct" type="adxp.precinct"/&gt;
               &lt;/xs:choice&gt;
               &lt;xs:element name="useablePeriod" minOccurs="0"
                     maxOccurs="unbounded" type="SXCM_TS"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        A General Timing Specification (GTS) specifying the
                        periods of time during which the address can be used.
                        This is used to specify different addresses for
                        different times of the year or to refer to historical
                        addresses.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
            &lt;xs:attribute name="use" use="optional"
                  type="set_PostalAddressUse"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A set of codes advising a system or user which address
                     in a set of like addresses to select for a given purpose.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="isNotOrdered" type="bl" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A boolean value specifying whether the order of the
                     address parts is known or not. While the address parts
                     are always a Sequence, the order in which they are
                     presented may or may not be known. Where this matters, the
                     isNotOrdered property can be used to convey this
                     information.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="ENXP" mixed="true"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            A character string token representing a part of a name.
            May have a type code signifying the role of the part in
            the whole entity name, and a qualifier code for more detail
            about the name part type. Typical name parts for person
            names are given names, and family names, titles, etc.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="ST"&gt;
            &lt;xs:attribute name="partType" type="EntityNamePartType"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Indicates whether the name part is a given name,
                     family name, prefix, suffix, etc.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="qualifier" use="optional"
                  type="set_EntityNamePartQualifier"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     The qualifier is a set of codes each of which specifies
                     a certain subcategory of the name part in addition to
                     the main name part type. For example, a given name may
                     be flagged as a nickname, a family name may be a
                     pseudonym or a name of public records.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="en.delimiter" mixed="true"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ENXP"&gt;
            &lt;xs:attribute name="partType" type="EntityNamePartType"
               fixed="DEL"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="en.family" mixed="true"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ENXP"&gt;
            &lt;xs:attribute name="partType" type="EntityNamePartType"
               fixed="FAM"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="en.given" mixed="true"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ENXP"&gt;
            &lt;xs:attribute name="partType" type="EntityNamePartType"
               fixed="GIV"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="en.prefix" mixed="true"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ENXP"&gt;
            &lt;xs:attribute name="partType" type="EntityNamePartType"
               fixed="PFX"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="en.suffix" mixed="true"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="ENXP"&gt;
            &lt;xs:attribute name="partType" type="EntityNamePartType"
               fixed="SFX"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="EN" mixed="true"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            A name for a person, organization, place or thing. A
            sequence of name parts, such as given name or family
            name, prefix, suffix, etc. Examples for entity name
            values are "Jim Bob Walton, Jr.", "Health Level Seven,
            Inc.", "Lake Tahoe", etc. An entity name may be as simple
            as a character string or may consist of several entity name
            parts, such as, "Jim", "Bob", "Walton", and "Jr.", "Health
            Level Seven" and "Inc.", "Lake" and "Tahoe".
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="ANY"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
                  &lt;xs:element name="delimiter" type="en.delimiter"/&gt;
                  &lt;xs:element name="family" type="en.family"/&gt;
                  &lt;xs:element name="given" type="en.given"/&gt;
                  &lt;xs:element name="prefix" type="en.prefix"/&gt;
                  &lt;xs:element name="suffix" type="en.suffix"/&gt;
               &lt;/xs:choice&gt;
               &lt;xs:element name="validTime" minOccurs="0" maxOccurs="1"
                     type="IVL_TS"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        An interval of time specifying the time during which
                        the name is or was used for the entity. This
                        accomodates the fact that people change names for
                        people, places and things.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
            &lt;xs:attribute name="use" use="optional" type="set_EntityNameUse"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A set of codes advising a system or user which name
                     in a set of like names to select for a given purpose.
                     A name without specific use code might be a default
                     name useful for any purpose, but a name with a specific
                     use code would be preferred for that respective purpose.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="PN" mixed="true"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            A name for a person. A sequence of name parts, such as
            given name or family name, prefix, suffix, etc. PN differs
            from EN because the qualifier type cannot include LS
            (Legal Status).
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="EN"/&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="ON" mixed="true"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            A name for an organization. A sequence of name parts.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="EN"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
                  &lt;xs:element name="delimiter" type="en.delimiter"/&gt;
                  &lt;xs:element name="prefix" type="en.prefix"/&gt;
                  &lt;xs:element name="suffix" type="en.suffix"/&gt;
               &lt;/xs:choice&gt;
               &lt;xs:element name="validTime" minOccurs="0" maxOccurs="1"
                     type="IVL_TS"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        An interval of time specifying the time during which
                        the name is or was used for the entity. This
                        accomodates the fact that people change names for
                        people, places and things.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
            &lt;xs:attribute name="use" use="optional" type="set_EntityNameUse"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A set of codes advising a system or user which name
                     in a set of like names to select for a given purpose.
                     A name without specific use code might be a default
                     name useful for any purpose, but a name with a specific
                     use code would be preferred for that respective purpose.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="TN" mixed="true"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            A restriction of entity name that is effectively a simple
            string used for a simple name for things and places.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="EN"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="validTime" minOccurs="0" maxOccurs="1"
                     type="IVL_TS"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        An interval of time specifying the time during which
                        the name is or was used for the entity. This
                        accomodates the fact that people change names for
                        people, places and things.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="QTY" abstract="true"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            The quantity data type is an abstract generalization
            for all data types (1) whose value set has an order
            relation (less-or-equal) and (2) where difference is
            defined in all of the data type's totally ordered value
            subsets.  The quantity type abstraction is needed in
            defining certain other types, such as the interval and
            the probability distribution.
         &lt;/xs:documentation&gt;
         &lt;xs:appinfo&gt;
            &lt;diff&gt;QTY&lt;/diff&gt;
         &lt;/xs:appinfo&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="ANY"/&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:simpleType name="int"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise
            numbers that are results of counting and enumerating.
            Integer numbers are discrete, the set of integers is
            infinite but countable.  No arbitrary limit is imposed on
            the range of integer numbers. Two NULL flavors are
            defined for the positive and negative infinity.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:restriction base="xs:integer"/&gt;
   &lt;/xs:simpleType&gt;
   &lt;xs:complexType name="INT"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise
            numbers that are results of counting and enumerating.
            Integer numbers are discrete, the set of integers is
            infinite but countable.  No arbitrary limit is imposed on
            the range of integer numbers. Two NULL flavors are
            defined for the positive and negative infinity.
         &lt;/xs:documentation&gt;
         &lt;xs:appinfo&gt;
            &lt;diff&gt;INT&lt;/diff&gt;
            &lt;sch:pattern name="validate INT"&gt;
               &lt;sch:rule abstract="true" id="rule-INT"&gt;
                  &lt;sch:report test="(@value or @nullFlavor) and
                     not(@value and @nullFlavor)"/&gt;
               &lt;/sch:rule&gt;
            &lt;/sch:pattern&gt;
         &lt;/xs:appinfo&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="QTY"&gt;
            &lt;xs:attribute name="value" use="optional" type="int"/&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:simpleType name="real"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            Fractional numbers. Typically used whenever quantities
            are measured, estimated, or computed from other real
            numbers.  The typical representation is decimal, where
            the number of significant decimal digits is known as the
            precision. Real numbers are needed beyond integers
            whenever quantities of the real world are measured,
            estimated, or computed from other real numbers. The term
            "Real number" in this specification is used to mean
            that fractional values are covered without necessarily
            implying the full set of the mathematical real numbers.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:union memberTypes="xs:decimal xs:double"/&gt;
   &lt;/xs:simpleType&gt;
   &lt;xs:complexType name="REAL"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            Fractional numbers. Typically used whenever quantities
            are measured, estimated, or computed from other real
            numbers.  The typical representation is decimal, where
            the number of significant decimal digits is known as the
            precision. Real numbers are needed beyond integers
            whenever quantities of the real world are measured,
            estimated, or computed from other real numbers. The term
            "Real number" in this specification is used to mean
            that fractional values are covered without necessarily
            implying the full set of the mathematical real numbers.
         &lt;/xs:documentation&gt;
         &lt;xs:appinfo&gt;
            &lt;diff&gt;REAL&lt;/diff&gt;
            &lt;sch:pattern name="validate REAL"&gt;
               &lt;sch:rule abstract="true" id="rule-REAL"&gt;
                  &lt;sch:report test="(@nullFlavor or @value) and
                     not(@nullFlavor and @value)"/&gt;
               &lt;/sch:rule&gt;
            &lt;/sch:pattern&gt;
         &lt;/xs:appinfo&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="QTY"&gt;
            &lt;xs:attribute name="value" use="optional" type="real"/&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="PQR"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            A representation of a physical quantity in a unit from
            any code system. Used to show alternative representation
            for a physical quantity.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="CV"&gt;
            &lt;xs:attribute name="value" type="real" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     The magnitude of the measurement value in terms of
                     the unit specified in the code.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="PQ"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            A dimensioned quantity expressing the result of a
            measurement act.
        &lt;/xs:documentation&gt;
         &lt;xs:appinfo&gt;
            &lt;diff&gt;PQ&lt;/diff&gt;
         &lt;/xs:appinfo&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="QTY"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="translation" type="PQR" minOccurs="0"
                     maxOccurs="unbounded"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        An alternative representation of the same physical
                        quantity expressed in a different unit, of a different
                        unit code system and possibly with a different value.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
            &lt;xs:attribute name="value" type="real" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     The magnitude of the quantity measured in terms of
                     the unit.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="unit" type="cs" use="optional" default="1"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     The unit of measure specified in the Unified Code for
                     Units of Measure (UCUM)
                     [http://aurora.rg.iupui.edu/UCUM].
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="MO"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            A monetary amount is a quantity expressing the amount of
            money in some currency. Currencies are the units in which
            monetary amounts are denominated in different economic
            regions. While the monetary amount is a single kind of
            quantity (money) the exchange rates between the different
            units are variable.  This is the principle difference
            between physical quantity and monetary amounts, and the
            reason why currency units are not physical units.
         &lt;/xs:documentation&gt;
         &lt;xs:appinfo&gt;
            &lt;diff&gt;MO&lt;/diff&gt;
            &lt;sch:pattern name="validate MO"&gt;
               &lt;sch:rule abstract="true" id="rule-MO"&gt;
                  &lt;sch:report test="not(@nullFlavor and
                     (@value or @currency))"/&gt;
               &lt;/sch:rule&gt;
            &lt;/sch:pattern&gt;
         &lt;/xs:appinfo&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="QTY"&gt;
            &lt;xs:attribute name="value" type="real" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     The magnitude of the monetary amount in terms of the
                     currency unit.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="currency" type="cs" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     The currency unit as defined in ISO 4217.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="RTO"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            A quantity constructed as the quotient of a numerator
            quantity divided by a denominator quantity. Common
            factors in the numerator and denominator are not
            automatically cancelled out.  RTO supports titers
            (e.g., "1:128") and other quantities produced by
            laboratories that truly represent ratios. Ratios are
            not simply "structured numerics", particularly blood
            pressure measurements (e.g. "120/60") are not ratios.
            In many cases REAL should be used instead
            of RTO.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="RTO_QTY_QTY"/&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:simpleType name="probability"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
               The probability assigned to the value, a decimal number
               between 0 (very uncertain) and 1 (certain).
            &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:restriction base="xs:double"&gt;
         &lt;xs:minInclusive value="0.0"/&gt;
         &lt;xs:maxInclusive value="1.0"/&gt;
      &lt;/xs:restriction&gt;
   &lt;/xs:simpleType&gt;
   &lt;xs:complexType name="EIVL.event"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
                        A code for a common (periodical) activity of daily
                        living based on which the event related periodic
                        interval is specified.
                     &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:restriction base="CE"&gt;
            &lt;xs:attribute name="code" type="TimingEvent" use="optional"/&gt;
            &lt;xs:attribute name="codeSystem" type="uid"
               fixed="2.16.840.1.113883.5.139"/&gt;
            &lt;xs:attribute name="codeSystemName"
               type="st" fixed="TimingEvent"/&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
&lt;!--
      Instantiated templates
    --&gt;
   &lt;xs:complexType name="SXCM_TS"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="TS"&gt;
            &lt;xs:attribute name="operator" type="SetOperator"
                  use="optional" default="I"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A code specifying whether the set component is included
                     (union) or excluded (set-difference) from the set, or
                     other set operations with the current set component and
                     the set as constructed from the representation stream
                     up to the current point.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:simpleType name="set_TelecommunicationAddressUse"&gt;
      &lt;xs:list itemType="TelecommunicationAddressUse"/&gt;
   &lt;/xs:simpleType&gt;
   &lt;xs:simpleType name="set_PostalAddressUse"&gt;
      &lt;xs:list itemType="PostalAddressUse"/&gt;
   &lt;/xs:simpleType&gt;
   &lt;xs:simpleType name="set_EntityNamePartQualifier"&gt;
      &lt;xs:list itemType="EntityNamePartQualifier"/&gt;
   &lt;/xs:simpleType&gt;
   &lt;xs:complexType name="IVL_TS"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="SXCM_TS"&gt;
            &lt;xs:choice minOccurs="0"&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="low" minOccurs="1" maxOccurs="1"
                        type="IVXB_TS"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The low limit of the interval.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;xs:choice minOccurs="0"&gt;
                     &lt;xs:element name="width" minOccurs="0" maxOccurs="1"
                           type="PQ"&gt;
                        &lt;xs:annotation&gt;
                           &lt;xs:documentation&gt;
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width
                           need to be stated and the third can be derived.
                        &lt;/xs:documentation&gt;
                        &lt;/xs:annotation&gt;
                     &lt;/xs:element&gt;
                     &lt;xs:element name="high" minOccurs="0" maxOccurs="1"
                           type="IVXB_TS"&gt;
                        &lt;xs:annotation&gt;
                           &lt;xs:documentation&gt;
                           The high limit of the interval.
                        &lt;/xs:documentation&gt;
                        &lt;/xs:annotation&gt;
                     &lt;/xs:element&gt;
                  &lt;/xs:choice&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:element name="high" minOccurs="1" maxOccurs="1"
                     type="IVXB_TS"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation/&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="width" minOccurs="1" maxOccurs="1"
                        type="PQ"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width
                           need to be stated and the third can be derived.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;xs:element name="high" minOccurs="0" maxOccurs="1"
                        type="IVXB_TS"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The high limit of the interval.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="center" minOccurs="1" maxOccurs="1"
                        type="TS"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The arithmetic mean of the interval (low plus
                           high divided by 2). The purpose of distinguishing
                           the center as a semantic property is for
                           conversions of intervals from and to point values.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;xs:element name="width" minOccurs="0" maxOccurs="1"
                        type="PQ"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width
                           need to be stated and the third can be derived.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
               &lt;/xs:sequence&gt;
            &lt;/xs:choice&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="IVXB_TS"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="TS"&gt;
            &lt;xs:attribute name="inclusive" type="bl" use="optional"
                  default="true"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Specifies whether the limit is included in the
                     interval (interval is closed) or excluded from the
                     interval (interval is open).
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:simpleType name="set_EntityNameUse"&gt;
      &lt;xs:list itemType="EntityNameUse"/&gt;
   &lt;/xs:simpleType&gt;
   &lt;xs:complexType name="RTO_QTY_QTY"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:appinfo&gt;
            &lt;diff&gt;RTO_QTY_QTY&lt;/diff&gt;
         &lt;/xs:appinfo&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="QTY"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="numerator" type="QTY"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        The quantity that is being divided in the ratio.
                        The default is the integer number 1 (one).
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:element name="denominator" type="QTY"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        The quantity that devides the numerator in the ratio.
                        The default is the integer number 1 (one).
                        The denominator must not be zero.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;

            </exhibit></div2><div2 id="datatypes.xsd"><head>Generic Type Instantiations</head><exhibit role="schema" verbatim="yes">
               
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- $Id: datatypes-its-xml.xml,v 1.7 2006/05/22 19:16:19 dlloyd Exp $ --&gt;&lt;!--
    This schema is generated from a Generic Schema Definition (GSD)
    by gsd2xsl. Do not edit this file.
  --&gt;
&lt;xs:schema xmlns:sch="http://www.ascc.net/xml/schematron"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"
      elementFormDefault="qualified"&gt;
   &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
           Copyright (c) 2001, 2002, 2003, 2004, 2005 Health Level Seven.
           All rights reserved.

           Redistribution and use in source and binary forms, with or
           without modification, are permitted provided that the following
           conditions are met:
           1. Redistributions of source code must retain the above
              copyright notice, this list of conditions and the following
              disclaimer.
           2. Redistributions in binary form must reproduce the above
              copyright notice, this list of conditions and the following
              disclaimer in the documentation and/or other materials
              provided with the distribution.
           3. All advertising materials mentioning features or use of this
              software must display the following acknowledgement:
           
           This product includes software developed by Health Level Seven.
 
           THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS
           ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
           NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
           FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT
           SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
           INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
           DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
           GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
           INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
           WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
           NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
           OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
           DAMAGE.
        
           Generated by $Id: gsd2xsd.xsl,v 1.4 2005/04/17 03:20:15 lmckenzi
           Exp $
&lt;/xs:documentation&gt;
   &lt;/xs:annotation&gt;
   &lt;xs:include schemaLocation="datatypes-base.xsd"/&gt;
&lt;!--
      Instantiated templates
    --&gt;
   &lt;xs:complexType name="PIVL_TS"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            Note: because this type is defined as an extension of SXCM_T,
            all of the attributes and elements accepted for T are also
            accepted by this definition.  However, they are NOT allowed
            by the normative description of this type.  Unfortunately,
            we cannot write a general purpose schematron contraints to
            provide that extra validation, thus applications must be
            aware that instance (fragments) that pass validation with
            this might might still not be legal.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="SXCM_TS"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="phase" minOccurs="0" maxOccurs="1"
                     type="IVL_TS"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        A prototype of the repeating interval specifying the
                        duration of each occurrence and anchors the periodic
                        interval sequence at a certain point in time.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:element name="period" minOccurs="0" maxOccurs="1" type="PQ"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        A time duration specifying a reciprocal measure of
                        the frequency at which the periodic interval repeats.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
            &lt;xs:attribute name="alignment" type="CalendarCycle" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Specifies if and how the repetitions are aligned to
                     the cycles of the underlying calendar (e.g., to
                     distinguish every 30 days from "the 5th of every
                     month".) A non-aligned periodic interval recurs
                     independently from the calendar. An aligned periodic
                     interval is synchronized with the calendar.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="institutionSpecified" type="bl" use="optional"
                  default="false"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Indicates whether the exact timing is up to the party
                     executing the schedule (e.g., to distinguish "every 8
                     hours" from "3 times a day".)
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="EIVL_TS"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            Note: because this type is defined as an extension of SXCM_T,
            all of the attributes and elements accepted for T are also
            accepted by this definition.  However, they are NOT allowed
            by the normative description of this type.  Unfortunately,
            we cannot write a general purpose schematron contraints to
            provide that extra validation, thus applications must be
            aware that instance (fragments) that pass validation with
            this might might still not be legal.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="SXCM_TS"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="event" type="EIVL.event" minOccurs="0"
                     maxOccurs="1"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        A code for a common (periodical) activity of daily
                        living based on which the event related periodic
                        interval is specified.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:element name="offset" minOccurs="0" maxOccurs="1"
                     type="IVL_PQ"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        An interval of elapsed time (duration, not absolute
                        point in time) that marks the offsets for the
                        beginning, width and end of the event-related periodic
                        interval measured from the time each such event
                        actually occurred.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="IVL_PQ"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="SXCM_PQ"&gt;
            &lt;xs:choice minOccurs="0"&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="low" minOccurs="1" maxOccurs="1"
                        type="IVXB_PQ"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The low limit of the interval.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;xs:choice minOccurs="0"&gt;
                     &lt;xs:element name="width" minOccurs="0" maxOccurs="1"
                           type="PQ"&gt;
                        &lt;xs:annotation&gt;
                           &lt;xs:documentation&gt;
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width
                           need to be stated and the third can be derived.
                        &lt;/xs:documentation&gt;
                        &lt;/xs:annotation&gt;
                     &lt;/xs:element&gt;
                     &lt;xs:element name="high" minOccurs="0" maxOccurs="1"
                           type="IVXB_PQ"&gt;
                        &lt;xs:annotation&gt;
                           &lt;xs:documentation&gt;
                           The high limit of the interval.
                        &lt;/xs:documentation&gt;
                        &lt;/xs:annotation&gt;
                     &lt;/xs:element&gt;
                  &lt;/xs:choice&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:element name="high" minOccurs="1" maxOccurs="1"
                     type="IVXB_PQ"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation/&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="width" minOccurs="1" maxOccurs="1"
                        type="PQ"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width
                           need to be stated and the third can be derived.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;xs:element name="high" minOccurs="0" maxOccurs="1"
                        type="IVXB_PQ"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The high limit of the interval.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="center" minOccurs="1" maxOccurs="1"
                        type="PQ"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The arithmetic mean of the interval (low plus high
                           divided by 2). The purpose of distinguishing the
                           center as a semantic property is for conversions
                           of intervals from and to point values.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;xs:element name="width" minOccurs="0" maxOccurs="1"
                        type="PQ"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width
                           need to be stated and the third can be derived.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
               &lt;/xs:sequence&gt;
            &lt;/xs:choice&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="SXCM_PQ"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="PQ"&gt;
            &lt;xs:attribute name="operator" type="SetOperator" use="optional"
                  default="I"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A code specifying whether the set component is included
                     (union) or excluded (set-difference) from the set, or
                     other set operations with the current set component and
                     the set as constructed from the representation stream
                     up to the current point.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="IVXB_PQ"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="PQ"&gt;
            &lt;xs:attribute name="inclusive" type="bl" use="optional"
                  default="true"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Specifies whether the limit is included in the
                     interval (interval is closed) or excluded from the
                     interval (interval is open).
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="PPD_TS"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:appinfo&gt;
            &lt;diff&gt;PPD_PQ&lt;/diff&gt;
         &lt;/xs:appinfo&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="TS"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="standardDeviation" minOccurs="0"
                     maxOccurs="1" type="PQ"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        The primary measure of variance/uncertainty of the
                        value (the square root of the sum of the squares of
                        the differences between all data points and the mean).
                        The standard deviation is used to normalize the data
                        for computing the distribution function. Applications
                        that cannot deal with probability distributions can
                        still get an idea about the confidence level by looking
                        at the standard deviation.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
            &lt;xs:attribute name="distributionType"
                  type="ProbabilityDistributionType" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A code specifying the type of probability distribution.
                     Possible values are as shown in the attached table.
                     The NULL value (unknown) for the type code indicates
                     that the probability distribution type is unknown. In
                     that case, the standard deviation has the meaning of an
                     informal guess.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="PPD_PQ"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:appinfo&gt;
            &lt;diff&gt;PPD_PQ&lt;/diff&gt;
         &lt;/xs:appinfo&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="PQ"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="standardDeviation" minOccurs="0"
                     maxOccurs="1" type="PQ"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        The primary measure of variance/uncertainty of the
                        value (the square root of the sum of the squares of
                        the differences between all data points and the mean).
                        The standard deviation is used to normalize the data
                        for computing the distribution function. Applications
                        that cannot deal with probability distributions can
                        still get an idea about the confidence level by looking
                        at the standard deviation.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
            &lt;xs:attribute name="distributionType"
                  type="ProbabilityDistributionType" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A code specifying the type of probability distribution.
                     Possible values are as shown in the attached table.
                     The NULL value (unknown) for the type code indicates
                     that the probability distribution type is unknown. In
                     that case, the standard deviation has the meaning of an
                     informal guess.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="PIVL_PPD_TS"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            Note: because this type is defined as an extension of SXCM_T,
            all of the attributes and elements accepted for T are also
            accepted by this definition.  However, they are NOT allowed
            by the normative description of this type.  Unfortunately,
            we cannot write a general purpose schematron contraints to
            provide that extra validation, thus applications must be
            aware that instance (fragments) that pass validation with
            this might might still not be legal.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="SXCM_PPD_TS"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="phase" minOccurs="0" maxOccurs="1"
                     type="IVL_PPD_TS"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        A prototype of the repeating interval specifying the
                        duration of each occurrence and anchors the periodic
                        interval sequence at a certain point in time.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:element name="period" minOccurs="0" maxOccurs="1"
                     type="PPD_PQ"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        A time duration specifying a reciprocal measure of
                        the frequency at which the periodic interval repeats.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
            &lt;xs:attribute name="alignment" type="CalendarCycle" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Specifies if and how the repetitions are aligned to
                     the cycles of the underlying calendar (e.g., to
                     distinguish every 30 days from "the 5th of every
                     month".) A non-aligned periodic interval recurs
                     independently from the calendar. An aligned periodic
                     interval is synchronized with the calendar.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="institutionSpecified" type="bl"
                  use="optional" default="false"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Indicates whether the exact timing is up to the party
                     executing the schedule (e.g., to distinguish "every 8
                     hours" from "3 times a day".)
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="SXCM_PPD_TS"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="PPD_TS"&gt;
            &lt;xs:attribute name="operator" type="SetOperator" use="optional"
                  default="I"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A code specifying whether the set component is included
                     (union) or excluded (set-difference) from the set, or
                     other set operations with the current set component and
                     the set as constructed from the representation stream
                     up to the current point.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="IVL_PPD_TS"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="SXCM_PPD_TS"&gt;
            &lt;xs:choice minOccurs="0"&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="low" minOccurs="1" maxOccurs="1"
                        type="IVXB_PPD_TS"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The low limit of the interval.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;xs:choice minOccurs="0"&gt;
                     &lt;xs:element name="width" minOccurs="0" maxOccurs="1"
                           type="PPD_PQ"&gt;
                        &lt;xs:annotation&gt;
                           &lt;xs:documentation&gt;
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width
                           need to be stated and the third can be derived.
                        &lt;/xs:documentation&gt;
                        &lt;/xs:annotation&gt;
                     &lt;/xs:element&gt;
                     &lt;xs:element name="high" minOccurs="0" maxOccurs="1"
                           type="IVXB_PPD_TS"&gt;
                        &lt;xs:annotation&gt;
                           &lt;xs:documentation&gt;
                           The high limit of the interval.
                        &lt;/xs:documentation&gt;
                        &lt;/xs:annotation&gt;
                     &lt;/xs:element&gt;
                  &lt;/xs:choice&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:element name="high" minOccurs="1" maxOccurs="1"
                     type="IVXB_PPD_TS"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation/&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="width" minOccurs="1" maxOccurs="1"
                        type="PPD_PQ"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width
                           need to be stated and the third can be derived.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;xs:element name="high" minOccurs="0" maxOccurs="1"
                        type="IVXB_PPD_TS"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The high limit of the interval.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="center" minOccurs="1" maxOccurs="1"
                        type="PPD_TS"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The arithmetic mean of the interval (low plus high
                           divided by 2). The purpose of distinguishing the
                           center as a semantic property is for conversions
                           of intervals from and to point values.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;xs:element name="width" minOccurs="0" maxOccurs="1"
                        type="PPD_PQ"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width
                           need to be stated and the third can be derived.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
               &lt;/xs:sequence&gt;
            &lt;/xs:choice&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="IVXB_PPD_TS"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="PPD_TS"&gt;
            &lt;xs:attribute name="inclusive" type="bl" use="optional"
                  default="true"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Specifies whether the limit is included in the
                     interval (interval is closed) or excluded from the
                     interval (interval is open).
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="EIVL_PPD_TS"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
            Note: because this type is defined as an extension of SXCM_T,
            all of the attributes and elements accepted for T are also
            accepted by this definition.  However, they are NOT allowed
            by the normative description of this type.  Unfortunately,
            we cannot write a general purpose schematron contraints to
            provide that extra validation, thus applications must be
            aware that instance (fragments) that pass validation with
            this might might still not be legal.
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="SXCM_PPD_TS"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="event" type="EIVL.event" minOccurs="0"
                     maxOccurs="1"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        A code for a common (periodical) activity of daily
                        living based on which the event related periodic
                        interval is specified.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:element name="offset" minOccurs="0" maxOccurs="1"
                     type="IVL_PPD_PQ"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        An interval of elapsed time (duration, not absolute
                        point in time) that marks the offsets for the
                        beginning, width and end of the event-related periodic
                        interval measured from the time each such event
                        actually occurred.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="IVL_PPD_PQ"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="SXCM_PPD_PQ"&gt;
            &lt;xs:choice minOccurs="0"&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="low" minOccurs="1" maxOccurs="1"
                        type="IVXB_PPD_PQ"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The low limit of the interval.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;xs:choice minOccurs="0"&gt;
                     &lt;xs:element name="width" minOccurs="0" maxOccurs="1"
                           type="PPD_PQ"&gt;
                        &lt;xs:annotation&gt;
                           &lt;xs:documentation&gt;
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width
                           need to be stated and the third can be derived.
                        &lt;/xs:documentation&gt;
                        &lt;/xs:annotation&gt;
                     &lt;/xs:element&gt;
                     &lt;xs:element name="high" minOccurs="0" maxOccurs="1"
                           type="IVXB_PPD_PQ"&gt;
                        &lt;xs:annotation&gt;
                           &lt;xs:documentation&gt;
                           The high limit of the interval.
                        &lt;/xs:documentation&gt;
                        &lt;/xs:annotation&gt;
                     &lt;/xs:element&gt;
                  &lt;/xs:choice&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:element name="high" minOccurs="1" maxOccurs="1"
                     type="IVXB_PPD_PQ"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation/&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="width" minOccurs="1" maxOccurs="1"
                        type="PPD_PQ"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width
                           need to be stated and the third can be derived.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;xs:element name="high" minOccurs="0" maxOccurs="1"
                        type="IVXB_PPD_PQ"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The high limit of the interval.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="center" minOccurs="1" maxOccurs="1"
                        type="PPD_PQ"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The arithmetic mean of the interval (low plus high
                           divided by 2). The purpose of distinguishing the
                           center as a semantic property is for conversions
                           of intervals from and to point values.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;xs:element name="width" minOccurs="0" maxOccurs="1"
                        type="PPD_PQ"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width
                           need to be stated and the third can be derived.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
               &lt;/xs:sequence&gt;
            &lt;/xs:choice&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="SXCM_PPD_PQ"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="PPD_PQ"&gt;
            &lt;xs:attribute name="operator" type="SetOperator" use="optional"
                  default="I"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A code specifying whether the set component is included
                     (union) or excluded (set-difference) from the set, or
                     other set operations with the current set component and
                     the set as constructed from the representation stream
                     up to the current point.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="IVXB_PPD_PQ"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="PPD_PQ"&gt;
            &lt;xs:attribute name="inclusive" type="bl" use="optional"
                  default="true"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Specifies whether the limit is included in the
                     interval (interval is closed) or excluded from the
                     interval (interval is open).
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="SXPR_TS"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="SXCM_TS"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="comp" minOccurs="2" maxOccurs="unbounded"
                     type="SXCM_TS"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation/&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="SXCM_CD"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="CD"&gt;
            &lt;xs:attribute name="operator" type="SetOperator" use="optional"
                  default="I"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A code specifying whether the set component is included
                     (union) or excluded (set-difference) from the set, or
                     other set operations with the current set component and
                     the set as constructed from the representation stream
                     up to the current point.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="SXCM_MO"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="MO"&gt;
            &lt;xs:attribute name="operator" type="SetOperator" use="optional"
                  default="I"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A code specifying whether the set component is included
                     (union) or excluded (set-difference) from the set, or
                     other set operations with the current set component and
                     the set as constructed from the representation stream
                     up to the current point.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="SXCM_INT"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="INT"&gt;
            &lt;xs:attribute name="operator" type="SetOperator" use="optional"
                  default="I"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A code specifying whether the set component is included
                     (union) or excluded (set-difference) from the set, or
                     other set operations with the current set component and
                     the set as constructed from the representation stream
                     up to the current point.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="SXCM_REAL"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="REAL"&gt;
            &lt;xs:attribute name="operator" type="SetOperator" use="optional"
                  default="I"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     A code specifying whether the set component is included
                     (union) or excluded (set-difference) from the set, or
                     other set operations with the current set component and
                     the set as constructed from the representation stream
                     up to the current point.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="IVL_INT"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="SXCM_INT"&gt;
            &lt;xs:choice minOccurs="0"&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="low" minOccurs="1" maxOccurs="1"
                        type="IVXB_INT"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The low limit of the interval.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;xs:choice minOccurs="0"&gt;
                     &lt;xs:element name="width" minOccurs="0" maxOccurs="1"
                           type="INT"&gt;
                        &lt;xs:annotation&gt;
                           &lt;xs:documentation&gt;
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width
                           need to be stated and the third can be derived.
                        &lt;/xs:documentation&gt;
                        &lt;/xs:annotation&gt;
                     &lt;/xs:element&gt;
                     &lt;xs:element name="high" minOccurs="0" maxOccurs="1"
                           type="IVXB_INT"&gt;
                        &lt;xs:annotation&gt;
                           &lt;xs:documentation&gt;
                           The high limit of the interval.
                        &lt;/xs:documentation&gt;
                        &lt;/xs:annotation&gt;
                     &lt;/xs:element&gt;
                  &lt;/xs:choice&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:element name="high" minOccurs="1" maxOccurs="1"
                     type="IVXB_INT"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation/&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="width" minOccurs="1" maxOccurs="1"
                        type="INT"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width
                           need to be stated and the third can be derived.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;xs:element name="high" minOccurs="0" maxOccurs="1"
                        type="IVXB_INT"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The high limit of the interval.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="center" minOccurs="1" maxOccurs="1"
                        type="INT"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The arithmetic mean of the interval (low plus high
                           divided by 2). The purpose of distinguishing the
                           center as a semantic property is for conversions
                           of intervals from and to point values.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;xs:element name="width" minOccurs="0" maxOccurs="1"
                        type="INT"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width
                           need to be stated and the third can be derived.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
               &lt;/xs:sequence&gt;
            &lt;/xs:choice&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="IVXB_INT"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="INT"&gt;
            &lt;xs:attribute name="inclusive" type="bl" use="optional"
                  default="true"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Specifies whether the limit is included in the
                     interval (interval is closed) or excluded from the
                     interval (interval is open).
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="IVL_REAL"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="SXCM_REAL"&gt;
            &lt;xs:choice minOccurs="0"&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="low" minOccurs="1" maxOccurs="1"
                        type="IVXB_REAL"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The low limit of the interval.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;xs:choice minOccurs="0"&gt;
                     &lt;xs:element name="width" minOccurs="0" maxOccurs="1"
                           type="REAL"&gt;
                        &lt;xs:annotation&gt;
                           &lt;xs:documentation&gt;
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width
                           need to be stated and the third can be derived.
                        &lt;/xs:documentation&gt;
                        &lt;/xs:annotation&gt;
                     &lt;/xs:element&gt;
                     &lt;xs:element name="high" minOccurs="0" maxOccurs="1"
                           type="IVXB_REAL"&gt;
                        &lt;xs:annotation&gt;
                           &lt;xs:documentation&gt;
                           The high limit of the interval.
                        &lt;/xs:documentation&gt;
                        &lt;/xs:annotation&gt;
                     &lt;/xs:element&gt;
                  &lt;/xs:choice&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:element name="high" minOccurs="1" maxOccurs="1"
                     type="IVXB_REAL"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation/&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="width" minOccurs="1" maxOccurs="1"
                        type="REAL"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width
                           need to be stated and the third can be derived.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;xs:element name="high" minOccurs="0" maxOccurs="1"
                        type="IVXB_REAL"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The high limit of the interval.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="center" minOccurs="1" maxOccurs="1"
                        type="REAL"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The arithmetic mean of the interval (low plus high
                           divided by 2). The purpose of distinguishing the
                           center as a semantic property is for conversions
                           of intervals from and to point values.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;xs:element name="width" minOccurs="0" maxOccurs="1"
                        type="REAL"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width
                           need to be stated and the third can be derived.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
               &lt;/xs:sequence&gt;
            &lt;/xs:choice&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="IVXB_REAL"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="REAL"&gt;
            &lt;xs:attribute name="inclusive" type="bl" use="optional"
                  default="true"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Specifies whether the limit is included in the
                     interval (interval is closed) or excluded from the
                     interval (interval is open).
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="IVL_MO"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="SXCM_MO"&gt;
            &lt;xs:choice minOccurs="0"&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="low" minOccurs="1" maxOccurs="1"
                        type="IVXB_MO"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The low limit of the interval.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;xs:choice minOccurs="0"&gt;
                     &lt;xs:element name="width" minOccurs="0" maxOccurs="1"
                           type="MO"&gt;
                        &lt;xs:annotation&gt;
                           &lt;xs:documentation&gt;
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation
                           only two of the three properties high, low, and
                           width need to be stated and the third can be
                           derived.
                        &lt;/xs:documentation&gt;
                        &lt;/xs:annotation&gt;
                     &lt;/xs:element&gt;
                     &lt;xs:element name="high" minOccurs="0" maxOccurs="1"
                           type="IVXB_MO"&gt;
                        &lt;xs:annotation&gt;
                           &lt;xs:documentation&gt;
                           The high limit of the interval.
                        &lt;/xs:documentation&gt;
                        &lt;/xs:annotation&gt;
                     &lt;/xs:element&gt;
                  &lt;/xs:choice&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:element name="high" minOccurs="1" maxOccurs="1"
                      type="IVXB_MO"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation/&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="width" minOccurs="1" maxOccurs="1"
                        type="MO"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width
                           need to be stated and the third can be derived.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;xs:element name="high" minOccurs="0" maxOccurs="1"
                        type="IVXB_MO"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The high limit of the interval.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="center" minOccurs="1" maxOccurs="1"
                        type="MO"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The arithmetic mean of the interval (low plus high
                           divided by 2). The purpose of distinguishing the
                           center as a semantic property is for conversions
                           of intervals from and to point values.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;xs:element name="width" minOccurs="0" maxOccurs="1"
                        type="MO"&gt;
                     &lt;xs:annotation&gt;
                        &lt;xs:documentation&gt;
                           The difference between high and low boundary. The
                           purpose of distinguishing a width property is to
                           handle all cases of incomplete information
                           symmetrically. In any interval representation only
                           two of the three properties high, low, and width
                           need to be stated and the third can be derived.
                        &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
               &lt;/xs:sequence&gt;
            &lt;/xs:choice&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="IVXB_MO"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="MO"&gt;
            &lt;xs:attribute name="inclusive" type="bl" use="optional"
                  default="true"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     Specifies whether the limit is included in the
                     interval (interval is closed) or excluded from the
                     interval (interval is open).
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="HXIT_PQ"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="PQ"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="validTime" minOccurs="0" maxOccurs="1"
                     type="IVL_TS"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        The time interval during which the given information
                        was, is, or is expected to be valid. The interval can
                        be open or closed, as well as infinite or undefined on
                        either side.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="HXIT_CE"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="CE"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="validTime" minOccurs="0" maxOccurs="1"
                     type="IVL_TS"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        The time interval during which the given information
                        was, is, or is expected to be valid. The interval can
                        be open or closed, as well as infinite or undefined on
                        either side.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="BXIT_CD"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="CD"&gt;
            &lt;xs:attribute name="qty" type="int" use="optional" default="1"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     The quantity in which the bag item occurs in its
                     containing bag.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="BXIT_IVL_PQ"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="IVL_PQ"&gt;
            &lt;xs:attribute name="qty" type="int" use="optional" default="1"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     The quantity in which the bag item occurs in its
                     containing bag.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="SLIST_PQ"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="ANY"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="origin" minOccurs="1" maxOccurs="1"
                     type="PQ"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                     The origin of the list item value scale, i.e., the
                     physical quantity that a zero-digit in the sequence
                     would represent.
                  &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:element name="scale" minOccurs="1" maxOccurs="1"
                     type="PQ"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                     A ratio-scale quantity that is factored out of the
                     digit sequence.
                  &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:element name="digits" minOccurs="1" maxOccurs="1"
                     type="list_int"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                     A sequence of raw digits for the sample values. This is
                     typically the raw output of an A/D converter.
                  &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:simpleType name="list_int"&gt;
      &lt;xs:list itemType="int"/&gt;
   &lt;/xs:simpleType&gt;
   &lt;xs:complexType name="SLIST_TS"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="ANY"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="origin" minOccurs="1" maxOccurs="1" type="TS"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                     The origin of the list item value scale, i.e., the
                     physical quantity that a zero-digit in the sequence
                     would represent.
                  &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:element name="scale" minOccurs="1" maxOccurs="1" type="PQ"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                     A ratio-scale quantity that is factored out of the
                     digit sequence.
                  &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:element name="digits" minOccurs="1" maxOccurs="1"
                     type="list_int"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                     A sequence of raw digits for the sample values. This is
                     typically the raw output of an A/D converter.
                  &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="GLIST_TS"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="ANY"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="head" minOccurs="1" maxOccurs="1" type="TS"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                     This is the start-value of the generated list. 
                  &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:element name="increment" minOccurs="1" maxOccurs="1"
                     type="PQ"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                     The difference between one value and its previous
                     different value. For example, to generate the sequence
                     (1; 4; 7; 10; 13; ...) the increment is 3; likewise to
                     generate the sequence (1; 1; 4; 4; 7; 7; 10; 10; 13;
                     13; ...) the increment is also 3.
                  &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
            &lt;xs:attribute name="period" type="int" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     If non-NULL, specifies that the sequence alternates,
                     i.e., after this many increments, the sequence item
                     values roll over to start from the initial sequence
                     item value. For example, the sequence (1; 2; 3; 1; 2;
                     3; 1; 2; 3; ...) has period 3; also the sequence
                     (1; 1; 2; 2; 3; 3; 1; 1; 2; 2; 3; 3; ...) has period
                     3 too.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="denominator" type="int" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     The integer by which the index for the sequence is
                     divided, effectively the number of times the sequence
                     generates the same sequence item value before
                     incrementing to the next sequence item value. For
                     example, to generate the sequence (1; 1; 1; 2; 2; 2; 3; 3;
                     3; ...)  the denominator is 3.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="GLIST_PQ"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="ANY"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="head" minOccurs="1" maxOccurs="1" type="PQ"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                     This is the start-value of the generated list. 
                  &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:element name="increment" minOccurs="1" maxOccurs="1"
                     type="PQ"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                     The difference between one value and its previous
                     different value. For example, to generate the sequence
                     (1; 4; 7; 10; 13; ...) the increment is 3; likewise to
                     generate the sequence (1; 1; 4; 4; 7; 7; 10; 10; 13;
                     13; ...) the increment is also 3.
                  &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
            &lt;xs:attribute name="period" type="int" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     If non-NULL, specifies that the sequence alternates,
                     i.e., after this many increments, the sequence item
                     values roll over to start from the initial sequence
                     item value. For example, the sequence (1; 2; 3; 1; 2;
                     3; 1; 2; 3; ...) has period 3; also the sequence
                     (1; 1; 2; 2; 3; 3; 1; 1; 2; 2; 3; 3; ...) has period
                     3 too.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
            &lt;xs:attribute name="denominator" type="int" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
                     The integer by which the index for the sequence is
                     divided, effectively the number of times the sequence
                     generates the same sequence item value before
                     incrementing to the next sequence item value. For
                     example, to generate the sequence (1; 1; 1; 2; 2; 2; 3; 3;
                     3; ...)  the denominator is 3.
                  &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="RTO_PQ_PQ"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:appinfo&gt;
            &lt;diff&gt;RTO_PQ_PQ&lt;/diff&gt;
         &lt;/xs:appinfo&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="QTY"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="numerator" type="PQ"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        The quantity that is being divided in the ratio.  The
                        default is the integer number 1 (one).
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:element name="denominator" type="PQ"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        The quantity that devides the numerator in the ratio.
                        The default is the integer number 1 (one).
                        The denominator must not be zero.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="RTO_MO_PQ"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:appinfo&gt;
            &lt;diff&gt;RTO_MO_PQ&lt;/diff&gt;
         &lt;/xs:appinfo&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="QTY"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="numerator" type="MO"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        The quantity that is being divided in the ratio.  The
                        default is the integer number 1 (one).
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
               &lt;xs:element name="denominator" type="PQ"&gt;
                  &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                        The quantity that devides the numerator in the ratio.
                        The default is the integer number 1 (one).
                        The denominator must not be zero.
                     &lt;/xs:documentation&gt;
                  &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="UVP_TS"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="TS"&gt;
            &lt;xs:attribute name="probability" type="probability" use="optional"&gt;
               &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;
               The probability assigned to the value, a decimal number
               between 0 (very uncertain) and 1 (certain).
            &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
            &lt;/xs:attribute&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
   &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;

            </exhibit></div2></div1><!-- to be moved the the schema design specification:
<div1>
<head>Generic Schema Definition Language</head>
<p>
Because XML schema has no mechanism for defining generic types, this
specification uses an extension of the XML Schema Definition (XSD),
the "Generic Schema Definition" (GSD). The GSD contains all of XSD
plus extension elements for defining and using generic schema types.
A XSL transform is included as Appendix <specref ref='gsd2xsd'/> that
transforms GSD into XSD, expanding all references to generic types
into normal schema types.
</p>

<p>
We describe the generic schema definition language in an example.
The following schema fragment shows a possible definition of the
bag item (<dtimplref ref='dtimpl-BXIT'/>) generic data type
extension using the Generic Schema Definition (GSD) language.
</p>

<schema include='false'>
  <gsd:template name='BXIT'
	   xmlns:gsd="http://aurora.regenstrief.org/GenericXMLSchema">
	<gsd:param name='T' type='ANY'/>

	<xs:complexType>
	  <xs:complexContent>
		<xs:extension>
		  <gsd:attribute name='base' type='T'/>
	  <xs:attribute name='qty' type='int' use='optional' default='1'/>
		</xs:extension>
	  </xs:complexContent>
	</xs:complexType>
  </gsd:template>
</schema>

<p>
The <element>gsd:template</element> with only an <attr>name</attr>
indicates a generic data type being defined. The GSD template is,
not unlike an XSLT template, a template for an XML output generating
the real XML Schema data type as an instantiation of the GSD
template.
</p>

<p>
A generic type has at least one parameter defined by the
<element>gsd:param</element>. A parameter has a name and may
be constrained to any specialization of the type indicated
by the <attr>type</attr>.
</p>

<p>
After the parameter sequence follows an XSD type definition,
however the <element>xs:complexType</element> (or the
<element>xs:simpleType</element>) has no <attr>name</attr>.
The name of generic type instantiations is generated using
the name of the generic type and all the supplied actual
parameter types in the order defined in the gsd:template's
parameter sequence, all separated by underscores. Thus,
BXIT&lt;CD> becomes BXIT_CD in the XML schema.
</p>

<p>
An <element>gsd:attribute</element> inserts an XML attribute into its
containing element (similar to an XSLT <element>
xsl:attribute</element>). The purpose is to insert actual parameters of
the template instantiation as an attribute named by the
<attr>name</attr>. In this case the <attr>base</attr> is added to the
<element>xs:extension</element> as this is a generic type
<emph>extension</emph>, that extends its parameter type.
</p>

<p>
When this generic type is instantiated with, for example, the
<dtimplref ref='dtimpl-CD'/> type, the generic type instantiation
BXIT&lt;CD> generates the following schema fragment.
</p>

<schema include='false'>
   <xs:complexType name='BXIT_CD'>
	  <xs:complexContent>
		 <xs:extension base='CD'>
			<xs:attribute name='qty' type='int' use='optional' default='1'/>
		 </xs:extension>
	  </xs:complexContent>
   </xs:complexType>
</schema>

<p>
A generic type is instantiated using the
<element>gsd:template</element> with an <attr>as</attr> (e.g., within
an <element>xs:element</element>.) The local effect is that an
attribute of the name given in the <attr>as</attr> will be
generated in the element enclosing the <element>gsd:template</element>
whose value is the name of the instantiated generic type. So,
for example:
</p>

<schema include='false'>
  <xs:element name='findings' minOccurs='0' maxOccurs='unbounded'>
	<gsd:template as='type' name='BXIT'>
	  <gsd:withParam name='T' type='CD'/>
	</gsd:template>
  </xs:element>
</schema>

<p>
will generate the following XML Schema element definition
</p>

<schema include='false'>
  <xs:element name='findings' minOccurs='0' maxOccurs='unbounded'
		 type='BXIT_CD'/>
</schema>

</div1>
--></back></spec>