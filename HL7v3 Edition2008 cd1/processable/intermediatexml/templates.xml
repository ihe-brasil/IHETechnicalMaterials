<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<spec xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="..\..\support\dtd\v3spec.xsd">
   <header>
      <title>Specification and Use of Reusable Constraint Templates</title>
      <version>2</version>
      <ballot number="3" type="DSTU" />
      <date>20080220</date>
      <authlist>
         <author>
            <role>Primary Contributor</role>
            <name key="Grieve, Grahame">Grahame Grieve</name>
            <affiliation>Jiva Medical</affiliation>
            <email href="grahame@jivamedical.com" xlink-form="simple" show="embed" actuate="auto"/>
         </author>
         
         <author>
            <role>Templates, Co-Chair</role>
            <name key="Townend, Ian">Ian Townend</name>
            <affiliation>NHS Connecting for Health</affiliation>
            <email href="ian.townend@nhs.net" xlink-form="simple" show="embed" actuate="auto"/>
         </author>
         <author>
            <role>Templates, Co-Chair</role>
            <name key="Mulrooney, Galen">Galen Mulrooney</name>
            <affiliation>U.S. Department of Veterans Affairs</affiliation>
            <email href="galen.mulrooney@med.va.gov" xlink-form="simple" show="embed" actuate="auto"/>
         </author>
         <author>
            <role>Templates, Co-Chair</role>
            <name key="Shafarman, Mark">Mark Shafarman</name>
            <affiliation>Shafarman Consulting</affiliation>
            <email href="mark.shafarman@earthlink.net" xlink-form="simple" show="embed" actuate="auto"/>
         </author>
         
         <author>
            <role>Modeling &amp; Methodology Co-Chair</role>
            <name key="Beeler, Woody">Woody Beeler</name>
            <affiliation>Beeler Consulting LLC</affiliation>
            <email href="woody@beelers.com" xlink-form="simple" show="embed" actuate="auto"/>
         </author>
         <author>
            <role>Modeling &amp; Methodology Co-Chair</role>
            <name key="Singureanu, Ioana">Ioana Singureanu</name>
            <affiliation>Eversolve / Patriot Tech</affiliation>
            <email href="ioana.singureanu@med.va.gov" xlink-form="simple" show="embed" actuate="auto"/>
         </author>
         <author>
            <role>Modeling &amp; Methodology Co-Chair</role>
            <name key="McKenzie, Lloyd">Lloyd McKenzie</name>
            <affiliation>Lloyd McKenzie &amp; Associates Consulting Ltd.</affiliation>
            <email href="lloyd@lmckenzie.com" xlink-form="simple" show="embed" actuate="auto"/>
         </author>
         <author>
            <role>Modeling &amp; Methodology Co-Chair</role>
            <name key="Nelson, Dale">Dale Nelson</name>
            <affiliation>Zed-Logic Informatics, Inc.</affiliation>
            <email href="dale@zed-logic.com" xlink-form="simple" show="embed" actuate="auto"/>
         </author>
         <author>
            <role>Modeling &amp; Methodology Co-Chair</role>
            <name key="Parker, Craig">Craig Parker</name>
            <affiliation>RemedyMD, Inc.</affiliation>
            <email href="craigparkermd@gmail.com" xlink-form="simple" show="embed" actuate="auto"/>
         </author>
         
      </authlist>
   </header>

   <front>
      <div1 id="introduction">
         <head>Introduction</head>
         <div2 id="scope">
            <head>Statement of scope &amp; intent</head>
            <p>
				HL7 V3 provides a global framework for exchange of healthcare information
				as documents or messages by providing a framework for constructing instances
				of data according to agreed definitions in a standard fashion. The globally
				agreed definitions are often fairly general in nature due to the intention of
				their scope or the requirements to be globally suitable, and a framework for
				making additional rules for more specific knowledge models is required.
			</p>
            <p>
				Templates are used to provide this framework within the context of HL7 V3 and
				the Clinical Document Architecture. This document describes how templates are
				specified, registered and used.
			</p>
         </div2>
         <div2 id="contributors">
            <head>Contributors</head>
            <p>Over the course of the life of this document, many people have contributed in one way or another: 
				<list role="unordered">
					<item>Alexander Ruggieri, Mayo Clinic</item>
					<item>Amnon Shabo, IBM Research</item>
					<item>Andrew Goodchild, NeHTA Australia</item>
					<item>Angelo Rossi-Morri, CNR</item>
					<item>Bas van Poppel, Hiscom BV</item>
					<item>Brett Esler, Pen Computer Systems</item>
					<item>Calvin Beebe, Mayo Clinic</item>
					<item>Charlie McCay, Ramsey Systems Ltd.</item>
					<item>Charlie Mead, Oracle</item>
					<item>Craig Parker, Intermountain Health</item>
					<item>Dale Nelson, Zed-Logic Informatics, Inc.</item>
					<item>David Markwell, Clinical Information Consultancy</item>
					<item>Dipak Kalra, UCL</item>
					<item>Fred Behlen, LAI Technology</item>
					<item>Galen Mulrooney, J P Systems, Inc</item>
					<item>George W. Beeler, Jr., Beeler Consulting LLC</item>
					<item>Grahame Grieve, Kestral Computing</item>
					<item>Gunther Schadow, Regenstrief Institute for Health Care</item>
					<item>Harold Solbrig, Mayo Clinic</item>
					<item>Harry Solomon, GE Medical Systems</item>
					<item>Ian Townend, NHS</item>
					<item>Ioana Singureanu, Eversolve / Patriot Tech</item>
					<item>Jane Curry, HL7 Canada</item>
					<item>Jennifer Puyenbroek, McKesson Information Solutions</item>
					<item>John Koisch, OCTL Consulting</item>
					<item>John Silva, Philips Medical Systems</item>
					<item>Ken Rubin, EDS</item>
					<item>Liora Alschuler, alschuler.spinosa</item>
					<item>Lloyd McKenzie, Lloyd McKenzie &amp; Associates Consulting Ltd.</item>
					<item>Mark Shafarman, Shafarman Consulting</item>
					<item>Martin Kernberg, MD, UCSF</item>
					<item>Mary Ann Juurlink, Killdara Corporation</item>
					<item>Mike Henderson, Eastern Informatics</item>
					<item>Mike Mair</item>
					<item>Paul Biron, Kaiser Permanente</item>
					<item>Peter L. Elkin, Mayo Clinic</item>
					<item>Richard Harding, Queensland Health</item>
					<item>Rik Smithies, NProgram Ltd</item>
					<item>Robert H. Dolin, Kaiser Permanente</item>
					<item>Russ Hamm, Mayo Clinic</item>
					<item>Sam Heard, MD, Ocean Informatics</item>
					<item>Sandy Boyer, BSP, Consultant</item>
					<item>Ted Klein, Klein Consulting, Inc</item>
					<item>Thomas Beale, Deep Thought Informatics</item>
					<item>Tim Benson, Abies Ltd</item>
					<item>William T.F. Goossen, Acquest Research and Development</item>
				</list>
			</p>
         </div2>
      </div1>
   </front>

   <body>
      <div1 id="Definition" ballotStatus="DSTU">
         <head>Definition</head>
         <div2 id="formalDefinition">
            <head>Formal Template Definition</head>
            <p>
				A template is an expression of a set of constraints on the RIM or a RIM derived model that is used
				to apply additional constraints to a portion of an instance of data which is
				expressed in terms of some other Static Model. Templates are used to further
				define and refine these existing models to specify a narrower and more focused
				scope.
			</p>
			<p>
				A template is represented by:
			</p>
			<list role="unordered">
				<item>a formal definition in one or more human readable languages or notations</item>
				<item>[optionally] a formal definition as a static model</item>
				<item>[optionally] one or more implementation specific representations that can be used to validate instances in a particular context</item>
			</list>
			<p>
				While the constraints that the template expresses must be based upon
				a RIM derived static model, and must be expressible as a static model,
				templates need not actually express the constraints as a static model,
				though this is encouraged where possible. If a static model is 
				present, it is considered to be a human readable notation.
			</p>
			<p>
				In addition, there is a set of metadata associated with every template to
				describe the purpose and use of the template. 
			</p>
         </div2>

         <div2 id="Discussion">
            <head>Discussion</head>
			<p>
				In HL7 V3, conformant instances of data will generally conform to many different
				models at once. Of the full set of models that an instance conforms to, only a
				subset will be of interest, or even known. Of those that are of interest, the
				first and most important model is the RIM itself. All conformant instances are
				proper expressions of the base object model, which is the RIM.
			</p>
            <p>
				Models may exist at many levels of abstraction. This includes Static Models,
				which describe a set of constraints on the RIM that clarifies how some real
				world concept is properly described in the RIM. However these static models
				are generally rather broad and generic. Other more detailed models may
				conform to these static models refining the generic concepts to more specific
				ones such as particular laboratory tests.
			</p>
            <p>
				Templates are used to constrain and define the structures of these more atomic
				concepts, and are able to be reused in multiple different contexts wherever the real
				world concept they describe occurs, such as a laboratory report in a CDA document
				or quoted within a pharmacy message as supporting evidence.
			</p>
            <p>
				Instances of data, either documents or messages, will conform to some other model,
				such as the CDA itself, or a message as specified by an interaction definition.
			</p>
            <p>
				Portions of the data will also conform to the additional model as specified by one
				or more templates. At times it will be useful to reference the template in the
				instance itself, to make use of templates more practical. Whether a template is
				referenced explicitly or some definitional construct establishes its use in the
				instance, when it is known that a portion of the instance conforms to a template,
				a template is said to “be applied” to the instance.
			</p>
            <p>
				All exchange of data using HL7 V3 is covered by an Interoperability Paradigm (defined
				in section <loc href="#InteroperabilityParadigm" xlink-form="simple" actuate="auto" show="embed">Interoperability
				Paradigm</loc>) that defines what forms the instances take and how templates are used.
			</p>
            <p>
				Template concepts and issues are discussed in depth with examples in the section 
				<loc href="#ConceptsAndIssues" xlink-form="simple" actuate="auto" show="embed">Template Concepts &amp; Issues</loc>.
            </p>
         </div2>
         <div2 id="Identification">
            <head>Template Identification</head>
            <p>
				Templates must be uniquely and unambiguously identified. Each template is assigned an
				identifier. The identifier is used within an instance when applying a template to a
				portion of the instance, in the templateId attribute that is available on every class,
				from the base class InfrastructureRoot.
			</p>
            <p>
				The InfrastructureRoot.templateId has a type of LIST&lt;II&gt;, allowing for more than
				one template to be applied.
			</p>
            <p>
				The order of the template identifiers supplied in an instance may be significant. In general,
				the first stated template should be the most constrained, and subsequent ones increasingly
				relaxed. However it may be unclear which template is most constrained, and there is no
				computational algorithm for determining this, so this is not a normative requirement.
			</p>
            <p>
				It is not required that all templates to which the instance conforms to are actually
				identified in the instance; this is up to the sender of the instance. It may be possible
				for a receiver to determine that there are other models to which the instance is also conformant
				even though they are not identified in the instance.
			</p>
            <p>
				Each template identified in the list is represented by an II, which has two important
				attributes, root and extension. The template identifier must clearly specify the root
				and optionally an extension that unambiguously identify the template. In this document,
				template identifiers are represented using the format root:extension.
			</p>
            <p>
				There is no identified normative method to locate a template from its identifier. Templates may be
				registered in one or more template registries, but the template identifier does not determine
				where a template may be found.
			</p>
         </div2>
         <div2 id="InteroperabilityParadigm">
            <head>Interoperability Paradigm</head>
            <p>
				Any exchange of data in the form of V3 instances requires some common understanding that
				establishes the ground rules for V3 based information exchange. The common understanding
				must establish when information is exchanged, in what form it is exchanged, how application
				implementation details are specified, and, of interest to this specification, how templates
				are to be used. This common understanding is known as the interoperability paradigm.
			</p>
            <p>
				HL7 has implicitly defined two interoperability paradigms, Messaging and Documents. Other
				interoperability paradigms may be defined by HL7 or other bodies, for example, to support
				services, context integration (i.e. CCOW) or to enable specific large projects. Interoperability
				paradigms are not specified for specific implementations, though they may themselves specify
				some or many rules for how specific implementations may specify particular details; these 
				specifications are often known as implementation contracts. For this reason it will generally
				only be HL7 itself that defines interoperability paradigms.
			</p>
			<p>
				<i>Note: The concept of Interoperability Paradigm is presently defined here in the templates
				specification, but it is expected to be introduced to the HL7 Development Framework (HDF).
				Once it is defined there, this section will be rewritten accordingly.</i>
			</p>
			<p>
				With regards to templates, the form of expression of the interoperability paradigm is not fixed,
				but it must specify how implementations can be described, when and what information is exchanged
				and how templates are used within this context.
			</p>			
            <p>
				Interoperability paradigms are important to the understanding of templates because they specify
				how templates function.  Interoperability paradigms
				firstly establish which models are used as expressed models and which models are used as
				applied models, or templates (see Section 
				<loc href="#ExpressedImpliedAndAppliedModels" xlink-form="simple" actuate="auto" show="embed">Expressed,
				Implied And Applied Models</loc> for definitions of these terms). The rules of the
				Interoperability Paradigm must also specify a number of rules about how templates are to be
				used, including how templates may be defined, whether an application may reject an instance
				because of the presence or absence of appropriate template definitions in the instance, and
				the relationships between templates, profiles and application conformance. Interoperability
				paradigms may make recommendations concerning implementation specific representations that 
				should be included within the template.				
			</p>
			<div3 id="InteroperabilityParadigmMessaging">
				<head>Messaging Interoperability Paradigm</head>
				<p>
				The implicit messaging interoperability paradigm establishes that content is exchanged in
				association with the V3 dynamic model – interactions, trigger events etc. Each interaction
				is associated with fixed static model and wrapper models that specify the content to be
				exchanged. Other models are applied as templates on the static model specified
				in the interaction. Profiles constrain both the dynamic and static model, and are bound to the
				root class of the outer wrapper of the interaction. Templates can be applied by the profiles.
				Applications cannot reject messages because of the presence or absence of any particular
				templateId unless the message does not conform to the applied templates.
				</p>
			</div3>
			<div3 id="InteroperabilityParadigmDocument">
				<head>Document Interoperability Paradigm</head>
				<p>
					The CDA and SPL specifications establish an implicit document interoperability paradigm
					where there is a single fixed static model. Documents conforming to this model may be exchanged
					whenever and however applications wish – there is no fixed dynamic model. All other models,
					including potentially CMETs from messaging models, may be used as templates. Under certain
					circumstances, when explicitly described in the interface contract, applications are entitled
					to reject documents if a template is not applied where it is expected.
				</p>
				<p>
					A number of profiles have been defined that constrain the use of CDA, such as CCD, CRS and
					the ASIG implementation guides. Though the profiles are not explicitly referenced in the 
					document, the profiles are all associated with specified patterns of use of templates.
				</p>					
			</div3>
			<div3 id="InteroperabilityParadigmService">
				<head>Services Interoperability Paradigm</head>
				<p>
				Services represent another interoperability paradigm which may be associated with additional
				or different uses of templates. An example might be where a functional
				model is associated with specific static models for specific function parameters, and an open
				or controlled set of templates are available. Profiles could be associated with the entry points
				of the selected models, and the service specification may make its own determination for how
				applications process templates, depending on their relevance to the functionality provided by
				the service.
				</p>
			</div3>
         </div2>
      </div1>
      <div1 id="TemplateExample" ballotStatus="DSTU">
        <head>Template Example</head>
		<div2 id="TemplateExampleApplied">
			<head>Templates as Applied Models</head>
			<p>
				This Constrained Information Model (CIM) is based on the clinical statement pattern. It is a very
				generic statement that an instance may include an observation, which may have multiple components
				that are also observations.
			</p>
			<p>
				<graphic source="graphics/example-cim.png" alt="Example CIM" />
			</p>
			<p>
				In this example, we assume that this model is a normative CIM published by HL7, used as the basis for
				a message design, and that the Messaging Interoperability Paradigm applies. As a CIM, this model
				would generally be used as the basis for a message type in some interaction definition. If this model
				was used a template, the template identifier would be 2.16.840.1.113883.1.3: COCT_CM999999, derived
				from the HL7 oid for normative CIMS and the model identifier.
			</p>
			<p>
				In order to be specific about how this very generic model is used, more specific models are developed.
				This is a model of part of the Barthel index, used as part of a diabetes annual review:
			</p>
			<p>
				<graphic source="graphics/example-barthel.png" alt="Barthel Index" />
			</p>
			<p>
				For the purposes of this example, we shall assume that HL7 published this model as a template, so the
				template Identifier would be 2.16.840.1.113883.10: REPC_RM000103, derived from the HL7 OID for normative
				models, and the model identifier. If the template was not published by HL7, some other identifier would
				be assigned.
			</p>
			<p>
				This instance is an XML ITS rendering of a sample set of data based on the Barthel_Index model:
			</p>
<pre>
    &lt;barthelIndex&gt;
      &lt;code codeSystem="2.16.840.1.113883.2.6.15.1" code="Barthel-index"/&gt;
      &lt;derivationExpr&gt;Sumscore&lt;/derivationExpr&gt;
      &lt;effectiveTime value="200601191211"/&gt;
      &lt;value value="3" /&gt;
      &lt;component1&gt;
        &lt;continenceOfBowels&gt;
          &lt;code codeSystem="2.16.840.1.113883.2.6.15.1.0" code="BrtlB525"/&gt;
          &lt;value code="1" codeSystem="2.16.840.1.113883.2.6.15.1.1"/&gt;
        &lt;/continenceOfBowels&gt;
      &lt;/component1&gt;
      &lt;component2&gt;
        &lt;controllingBladder&gt;
          &lt;code codeSystem="2.16.840.1.113883.2.6.15.1.0" code="BrtlB6202"/&gt;
          &lt;value code="1" codeSystem="2.16.840.1.113883.2.6.15.1.2"/&gt;
        &lt;/controllingBladder&gt;
      &lt;/component2&gt;
      &lt;component3&gt;
        &lt;personalToilet&gt;
          &lt;code codeSystem="2.16.840.1.113883.2.6.15.1.0" code="BrtlD520"/&gt;
          &lt;value code="1" codeSystem="2.16.840.1.113883.2.6.15.1.3"/&gt;
        &lt;/personalToilet&gt;
      &lt;/component3&gt;
    &lt;/barthelIndex&gt;
</pre>
			<p>
				The Barthel index can be applied as a template to an instance of data based
				on the Example CIM. This instance is an XML ITS rendering of a sample set
				of data based on the Example CIM, with an explicit declaration of the
				template:
			</p>

<pre>
    &lt;observation&gt;
      &lt;templateId root="2.16.840.1.113883.10" extension=" REPC_RM000103"/&gt;
      &lt;code codeSystem="2.16.840.1.113883.2.6.15.1" code="Barthel-index"/&gt;
      &lt;derivationExpr&gt;Sumscore&lt;/derivationExpr&gt;
      &lt;effectiveTime value="200601191211"/&gt;
      &lt;value value="3" /&gt;
      &lt;component&gt;
        &lt;observation&gt;
          &lt;code codeSystem="2.16.840.1.113883.2.6.15.1.0" code="BrtlB525"/&gt;
          &lt;value xsi:type="CO" code="1" codeSystem="2.16.840.1.113883.2.6.15.1.1"/&gt;
        &lt;/observation&gt;
      &lt;/component&gt;
      &lt;component&gt;
        &lt;observation&gt;
          &lt;code codeSystem="2.16.840.1.113883.2.6.15.1.0" code="BrtlB6202"/&gt;
          &lt;value xsi:type="CO" code="1" codeSystem="2.16.840.1.113883.2.6.15.1.2"/&gt;
        &lt;/observation&gt;
      &lt;/component&gt;
      &lt;component&gt;
        &lt;observation&gt;
          &lt;code codeSystem="2.16.840.1.113883.2.6.15.1.0" code="BrtlD520"/&gt;
          &lt;value xsi:type="CO" code="1" codeSystem="2.16.840.1.113883.2.6.15.1.3"/&gt;
        &lt;/observation&gt;
      &lt;/componen&gt;
    &lt;/observation&gt;
            
</pre>

			<p>
				This example shows how the template is applied using the templateId attribute,
				which identifies and asserts that the data contained in the root observation
				conforms to the constraints described in the template.
			</p>
		</div2>
		<div2>
			<head>Representation of the Template</head>
			<p>
				Each template is represented as a single XML document. The document contains the 
				XML metadata, the human language description of the template, and optionally
				a representation of the model that the template expresses in 
				a form ready for computational processing, along with a number of attachments
				that provide implementation specific representations of the template or contain
				additional supporting information.
			</p>
			<p>
				Note: Template models are usually designed using composition so that the
				templates can be reused.
			</p>
			<p>
				This is an example:
			</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!-- 
This example was originally defined by William Goosen, and generously
offered for use in the template specification. The example has been liberally
adapted; it should not be inferred that the details in here, particularly the
metadata, have any relationship to William's original work.
 --&gt;
&lt;Template 
  name="Barthel Index" 
  intention="Expresses the commonly accepted definition of the Barthel Index"  
  description="This template expresses the concept of the Barthel Index using the commonly accepted definition. The Barthel Index is used for assessing a patients ability to deal with daily living"  
  version="2.01" 
  repositoryURL="http://hcxw2k1.nist.gov:8080/hlxregdoc/HCXW2K1Main.html" 
  format="HL7.Template.V1" 
  descriptionLanguage="English"  
  evidenceSource="htt//www.dundee.ac.uk/medther/Stroke/Scales/barthel.htm"  
  cautionPoints="Example Template defined for the purposes of providung an example in the template specification"  
  publicationStatus="PRODUCTION"  
  publicationStatusChangeDate="2007-07-14T10:23:00+10:00" 
  xmlns="uri:hl7.org::template" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="uri:hl7.org::template template.xsd "&gt;
  &lt;!-- 
    Comments on attributes:
    * version is assigned in a form suitable to the author. 
    * repositoryURL on the hypothetical basis that this template is published in the HL7 registry
    * a hypothetical evidence source is provided. 
    * publicationStatusChangeDate should be updated to be when the template specification itself is published
  --&gt;
  &lt;id root="2.16.840.1.113883.10" extension="REPC_RM000103"/&gt;
  &lt;derivationModel root="2.16.840.1.113883.10" extension="COCS_DM000000UV"/&gt; &lt;!--  Derived from the clinical statement pattern --&gt;
  &lt;referenceModelId root="2.16.840.1.113883.1.8"/&gt; &lt;!-- May 2007 release of the ballot. no OID is yet assigned to the RIM itself, this fictional oid used instead --&gt;
  &lt;publisher name="HL7, Inc" email="hq@hl7.org"&gt;
    &lt;address&gt;
       3300 Washtenaw Avenue,
       Suite 227 Ann Arbor,
       MI 48104 USA
    &lt;/address&gt;
    &lt;id root="2.16.840.1.113883"/&gt; &lt;!-- Is it valid to use this oid to identify HL7 in a corporate sense? --&gt;
  &lt;/publisher&gt;

  &lt;revision comment="First Defined" date="2005-07-25T00:00:00"&gt;
    &lt;author name="William Goosen" email="Williamtfgoossen@cs.com"/&gt; 
  &lt;/revision&gt;
  &lt;revision comment="Revised for Template Specification" date="2007-07-14T10:23:00+10:00"&gt;
    &lt;author name="Grahame Grieve" email="grahame@jivamedical.com"/&gt; 
  &lt;/revision&gt;


  &lt;!-- 
    model: The actual template model
  --&gt;
  
  &lt;model abstract="false" name="BarthelIndex" sourceModel="REPC_RM000103" &gt;
    &lt;!-- 
       features can be either attributes or associations. 
       They must appear in the correct sort order.
    --&gt; 
    &lt;feature xsi:type="Attribute" conformance="R" mandatory="true" max="1" min="1" name="classCode" datatype="CS"&gt;
    	&lt;vocabulary extensions="false" domain="ActClass" code="OBS"/&gt;
    &lt;/feature&gt;
    &lt;feature xsi:type="Attribute" conformance="R" mandatory="true" max="1" min="1" name="moodCode" datatype="CS"&gt;
    	&lt;vocabulary extensions="false" domain="ActMood" code="EVN"/&gt;
    &lt;/feature&gt;
    &lt;feature xsi:type="Attribute" conformance="A" mandatory="false" max="1" min="0" name="code" datatype="CD"&gt;
    	&lt;vocabulary extensions="true" domain="ActCode" code="Barthel-index"/&gt;
    &lt;/feature&gt;
    &lt;feature xsi:type="Attribute" conformance="A" mandatory="false" max="1" min="0" name="derivationExpr" datatype="ST"&gt;
       &lt;possibleValue&gt;Sumscore&lt;/possibleValue&gt;
    &lt;/feature&gt;
    &lt;feature xsi:type="Attribute" conformance="A" mandatory="false" max="1" min="0" name="effectiveTime" datatype="TS"/&gt;
    &lt;feature xsi:type="Attribute" conformance="A" mandatory="false" max="1" min="0" name="value" datatype="CO"/&gt;
    &lt;feature xsi:type="Attribute" conformance="A" mandatory="false" max="1" min="1" name="interpretationCode" datatype="CO"&gt;
    	&lt;vocabulary extensions="true" domain="ObservationInterpretation"/&gt;
    &lt;/feature&gt;
    &lt;feature xsi:type="Association" conformance="A" mandatory="false" max="1" min="1" name="component1" rimName="outboundRelationship"&gt;
    	&lt;target abstract="false" sourceModel="REPC_RM000103" name="Component1"&gt;
		    &lt;feature xsi:type="Attribute" conformance="R" mandatory="true" max="1" min="1" name="typeCode" datatype="CS"&gt;
		    	&lt;vocabulary extensions="false" domain="ActRelationshipType" code="COMP"/&gt;
		    &lt;/feature&gt;
		    &lt;feature xsi:type="Association" conformance="A" mandatory="false" max="1" min="1" name="continenceOfBowels" rimName="target"&gt;
		    	&lt;target abstract="false" sourceModel="REPC_RM000103" name="ContinenceOfBowels"&gt;
				    &lt;feature xsi:type="Attribute" conformance="R" mandatory="true" max="1" min="1" name="classCode" datatype="CS"&gt;
				    	&lt;vocabulary extensions="false" domain="ActClass" code="OBS"/&gt;
				    &lt;/feature&gt;
				    &lt;feature xsi:type="Attribute" conformance="R" mandatory="true" max="1" min="1" name="moodCode" datatype="CS"&gt;
				    	&lt;vocabulary extensions="false" domain="ActMood" code="EVN"/&gt;
				    &lt;/feature&gt;
				    &lt;feature xsi:type="Attribute" conformance="A" mandatory="false" max="1" min="0" name="code" datatype="CD"&gt;
		    			&lt;vocabulary extensions="true" domain="ActCode" code="BrtIB525"/&gt;
				    &lt;/feature&gt;
				    &lt;feature xsi:type="Attribute" conformance="A" mandatory="false" max="1" min="0" name="effectiveTime" datatype="TS"/&gt;
				    &lt;feature xsi:type="Attribute" conformance="A" mandatory="false" max="1" min="0" name="value" datatype="CO"/&gt;
 		    		&lt;derives xref="observation"/&gt; 
		    	&lt;/target&gt;
		    &lt;/feature&gt;
		    &lt;derives xref="actrelationship"/&gt; 
    	&lt;/target&gt;
    &lt;/feature&gt;
    &lt;feature xsi:type="Association" conformance="A" mandatory="false" max="1" min="1" name="component2" rimName="outboundRelationship"&gt;
    	&lt;target sourceModel="REPC_RM000103" name="Component2" abstract="false"&gt;
		    &lt;feature xsi:type="Attribute" conformance="R" mandatory="true" max="1" min="1" name="typeCode" datatype="CS"&gt;
		    	&lt;vocabulary extensions="false" domain="ActRelationshipType" code="COMP"/&gt;
		    &lt;/feature&gt;
		    &lt;feature xsi:type="Association" conformance="A" mandatory="false" max="1" min="1" name="controllingBladder" rimName="target"&gt;
		    	&lt;target sourceModel="REPC_RM000103" name="ControllingBladder" abstract="false"&gt;
				    &lt;feature xsi:type="Attribute" conformance="R" mandatory="true" max="1" min="1" name="classCode" datatype="CS"&gt;
				    	&lt;vocabulary extensions="false" domain="ActClass" code="OBS"/&gt;
				    &lt;/feature&gt;
				    &lt;feature xsi:type="Attribute" conformance="R" mandatory="true" max="1" min="1" name="moodCode" datatype="CS"&gt;
				    	&lt;vocabulary extensions="false" domain="ActMood" code="EVN"/&gt;
				    &lt;/feature&gt;
				    &lt;feature xsi:type="Attribute" conformance="A" mandatory="false" max="1" min="0" name="code" datatype="CD"&gt;
		    			&lt;vocabulary extensions="true" domain="ActCode" code="BrtIB6202"/&gt;
				    &lt;/feature&gt;
				    &lt;feature xsi:type="Attribute" conformance="A" mandatory="false" max="1" min="0" name="effectiveTime" datatype="TS"/&gt;
				    &lt;feature xsi:type="Attribute" conformance="A" mandatory="false" max="1" min="0" name="value" datatype="CO"/&gt;
 		    		&lt;derives xref="observation"/&gt; 
		    	&lt;/target&gt;
		    &lt;/feature&gt;
		    &lt;derives xref="actrelationship"/&gt; 
    	&lt;/target&gt;
    &lt;/feature&gt;
    &lt;feature xsi:type="Association" conformance="A" mandatory="false" max="1" min="1" name="component3" rimName="outboundRelationship"&gt;
    	&lt;target sourceModel="REPC_RM000103" name="Component3" abstract="false"&gt;
		    &lt;feature xsi:type="Attribute" conformance="R" mandatory="true" max="1" min="1" name="typeCode" datatype="CS"&gt;
		    	&lt;vocabulary extensions="false" domain="ActRelationshipType" code="COMP"/&gt;
		    &lt;/feature&gt;
		    &lt;feature xsi:type="Association" conformance="A" mandatory="false" max="1" min="1" name="personalToilet" rimName="target"&gt;
		    	&lt;target sourceModel="REPC_RM000103" name="PersonalToilet" abstract="false"&gt;
				    &lt;feature xsi:type="Attribute" conformance="R" mandatory="true" max="1" min="1" name="classCode" datatype="CS"&gt;
				    	&lt;vocabulary extensions="false" domain="ActClass" code="OBS"/&gt;
				    &lt;/feature&gt;
				    &lt;feature xsi:type="Attribute" conformance="R" mandatory="true" max="1" min="1" name="moodCode" datatype="CS"&gt;
				    	&lt;vocabulary extensions="false" domain="ActMood" code="EVN"/&gt;
				    &lt;/feature&gt;
				    &lt;feature xsi:type="Attribute" conformance="A" mandatory="false" max="1" min="0" name="code" datatype="CD"&gt;
		    			&lt;vocabulary extensions="true" domain="ActCode" code="BrtIB520"/&gt;
				    &lt;/feature&gt;
				    &lt;feature xsi:type="Attribute" conformance="A" mandatory="false" max="1" min="0" name="effectiveTime" datatype="TS"/&gt;
				    &lt;feature xsi:type="Attribute" conformance="A" mandatory="false" max="1" min="0" name="value" datatype="CO"/&gt;
 		    		&lt;derives xref="observation"/&gt; 
		    	&lt;/target&gt;
		    &lt;/feature&gt;
		    &lt;derives xref="actrelationship"/&gt; 
    	&lt;/target&gt;
    &lt;/feature&gt;
    &lt;derives xref="observation"/&gt;
  &lt;/model&gt;
  
  &lt;!-- 
    Rim classes. The RIM class definitions used in this model.
    Of course, these must be identical to the RIM against which
    the template is based, but storing them in the template 
    saves implementers work.  
   --&gt;

  &lt;rim version="1.22"&gt; 
    &lt;!-- 
      all the classes that the template depends on.
      For the purposes of this example, the classes
      are not enumerated, but would include directly:
        * Observation
        * ActRelationship
      and therefore the following classes would be 
      dragged in: 
        * Act
      By convention, it is not necessary to define the 
      all the attributes and associations in the RIM
      in this abbreviated rendition, only those which
      the model depends on. But it is not wrong to 
      include all the classes, attributes and associations
      defined in the RIM.
      
      stubs of 3 example classes are provided
    --&gt;
    &lt;class id="act" sourceModel="RIM" name="Act" category="ACT"&gt;
	    &lt;feature xsi:type="Attribute" conformance="R" mandatory="true" max="1" min="1" name="classCode" datatype="CS"&gt;
    		&lt;vocabulary extensions="false" domain="ActClass"/&gt;
	    &lt;/feature&gt;
    &lt;/class&gt;
    &lt;class id="observation" sourceModel="RIM" name="Observation" category="ACT"&gt;
      &lt;super xref="act"/&gt;
    &lt;/class&gt;
    &lt;class id="actrelationship" sourceModel="RIM" name="ActRelationship" category="ACT_RELATIONSHIP"&gt;
    &lt;/class&gt;
  &lt;/rim&gt;

  &lt;!-- 
    Attachments.
    
    Typically a template will have some or all of the following attachments:
     - MIF Static Model - a full MIF of the original template
     - Image - a .gif or .png (or similar, a graphical representation of the static model)
     - ADL - a ADL rendition of the template
     - schematron - an rendition of the template as schematron rules    
  --&gt;
  &lt;attachment type="STATIC_MODEL" mediatype="application/mif+xml"&gt;
    &lt;content&gt;&lt;!-- MIF Content --&gt;&lt;/content&gt;
  &lt;/attachment&gt;
  &lt;attachment type="STATIC_MODEL_IMAGE" mediatype="image/png"&gt;
    &lt;content&gt;&lt;!-- PNG of image --&gt;&lt;/content&gt;
  &lt;/attachment&gt;
  &lt;attachment type="COMPUTABLE" mediatype="application/adl"&gt;
    &lt;content&gt;&lt;!-- ADL equivalent of the template (fully stitched, like the model above) --&gt;&lt;/content&gt;
  &lt;/attachment&gt;
  &lt;attachment type="DOCUMENTATION" mediatype="application/pdf"&gt;
    &lt;content&gt;&lt;!-- PDF Document with Author's Design comments --&gt;&lt;/content&gt;
  &lt;/attachment&gt;  
&lt;/Template&gt;
</pre>
		</div2>
		<div2>
			<head>Template Lifecycle</head>
			<p>
				Typically, a template such as this example will be authored by a small group of 
				experts in the domain of the template, along with assistance from one or more 
				modelers familiar with the HL7 Development Framework. The authoring group will
				prototype the template, sharing it amongst themselves while they are preparing it 
				for production use. 
			</p>
			<p>
				When the template is ready for production use, a recognised authority will approve
				and/or endorse the template. The details of this process are subject to the policies
                and governance models of the authoring organization, or in the case of publishing
                extant models, the registering organization. The recognised authority may be a legally
				constituted standards organisation, or it may be a professional association, or a
                project management team, or even the authoring group itself. In each case, the
				implications of the endorsement will depend on the nature of the authority. 
			</p>
			<p>
				Once the template is approved for production use, it must be published. If the 
				anticipated use is only within the authoring group, or with a particular project,
				the publication process may be rather informal. When a template is expected to be 
				used in a more widespread manner, the template will be published into some registry
				that provides a set of common services allowing users and applications to find and use
				the templates. There are additional requirements for templates when they are published
				using public template registries.
			</p>
			<p>
				When a template is ready for use, it will be used in three different ways by applications.
				Applications that write instances (either as a message sender, a document author, or a 
				client or server in a service context) will use the template to constrain the contents
				of the instance that they are writing. They may choose to note in the instance that 
				the appropriate portion conforms to the template, either to meet a implementation requirement
				as allowed by the paradigm, or to allow a validation application to validate the instance 
				with regard to the template
			</p>
			<p>
				Appplications that wish to validate an instance with regard to the template must know that 
				a particular template applies at a particular point within the instance. Sometimes this 
				can be done implicitly in profiles and contracts, but there are times when the only way
				this can be known is if conformance to the template is explicitly noted in the instance.
				Validation applications must compare the instance against the constraints noted in the
				applicable templates.
			</p>
			<p>
				Applications that consume the instances may use the template definitions to assist
				the processing of the instance. Applications should avoid making processing dependent
				on the instance explicitly noting conformance to a template in the instance, as the 
				instance may conform to the template without this explicit note.
			</p>
			<p>
				While the template is being used, design issues with the template may arise, and the
				authority that endorsed the template may ask for the design to be reexamined, either 
				by the original authoring group, or some other group. If the issues can be resolved 
				by making backwards compatible changes to the design, a new version of the template 
				is published, ideally through all the channels that it was first published to avoid
				confusion. If the changes are not backwards compatible (defined in <loc href="ConformanceTemplate"
                xlink-form="simple" actuate="auto" show="embed">Conformance Statement Conf-003</loc>),
                a new template must be issued. The original template may be withdrawn in this case if appropriate.
			</p>
		</div2>
    </div1>

    <div1 id="Content" ballotStatus="DSTU">
		<head>Template Content</head>
		<p>
			A template is stored as a single document that describes the template, and may contain an
 			HL7 static model representation of the template, some metadata describing the template to assist
			with finding, sharing and reusing the template, and optionally, a series of attachments that
			provide implementation specific representations of the template or contain additional supporting
			information.
		</p>
		<div2 id="metadata">
			<head>Metadata Summary</head>
			<p>
				The list of metadata in a template has been prepared in collaboration with CEN to enable 
				CEN archetypes and HL7 templates to share common registries.
			</p>
			<p>
				The name column defines the name of the property. The type column is mostly defined using V3 datatypes.
				This does not mean that the actual V3 datatype or its XML representation must be used, but may
				be taken as a guide to the kind of information that may be expected for the property
			</p>
			<p>
				The conformance column specifies whether the metadata items are mandatory or optional. A few properties
				are conditional; in these cases, the conditionality is specified in the documentation column. The properties
				marked mandatory are required for a template to be a conformant template at any point in the life cycle.
				Registries may impose additional requirements on the metadata in order to support some of the interoperability
				uses of templates.
			</p>
			<p>
				The final column documents where this metadata item is persisted in the template format documented below. 
			</p>
         <table>
            <tr>
               <td>Property Name</td>

               <td>Type</td>

               <td>Conf</td>

               <td>Documentation</td>

               <td></td>
            </tr>

            <tr>
               <td>Identification</td>

               <td></td>

               <td></td>

               <td></td>

               <td></td>
            </tr>

            <tr>
               <td>TemplateId</td>

               <td>II</td>

               <td>M</td>

               <td>A globally unique, non-semantic, identifier for the Template. This is the primary identifier for all Templates</td>

               <td>.id</td>
            </tr>

            <tr>
               <td>templateName</td>

               <td>String</td>

               <td>M</td>

               <td>A free text natural language name identifying the Template. It is anticipated that there will be far too many templates to be able to assign a unique mnemonic or meaningful name to all of them. This is the secondary identifier for all Templates</td>

               <td>.name</td>
            </tr>

            <tr>
               <td>originatingAuthorEntityID</td>

               <td>II</td>

               <td>O</td>

               <td>A globally unique non-semantic identifier for the original author of the Template. Registries may require templates to populate this element.</td>

               <td>.revision[0].id</td>
            </tr>

            <tr>
               <td>intention</td>

               <td>Text</td>

               <td>M</td>

               <td>
					A free text natural language description of the intent and scope of the Template. The purpose
					is to provide the author’s initial intent for the Template in the language specified below.
					Example: The intention may include the Realm or sub-realm within which the Template was
					designed to be used for. 
					<br />
					NOTE: A change to the semantic meaning or intent of a Template will constitute a new Template, not
					a new version of the Template.</td>

               <td>.intention</td>
            </tr>

            <tr>
               <td>version</td>

               <td>ST</td>

               <td>M</td>

               <td>
					The version identifier for the Template. The ability to determine the correct version of a
					Template is essential to its identification. 
					<br/>
					NOTE: Backward compatible changes will cause a new version of the template. If the changes 
					are not backward compatible, a new template must be created. Backwards compatibility is 
					defined in <loc href="ConformanceTemplate"
                    xlink-form="simple" actuate="auto" show="embed">Conformance Statement Conf-003</loc>. 
				</td>

               <td>.version</td>
            </tr>

            <tr>
               <td>templateDerivedModelID</td>

               <td>II</td>

               <td>M</td>

               <td>The globally unique identifier of the CIM from which the Template is derived</td>

               <td>.derivationModel</td>
            </tr>

            <tr>
               <td>templateReferenceModelID</td>

               <td>II</td>

               <td>M</td>

               <td>The globally unique identifier of the reference model from which the Template is derived. 
               <br />

               NOTE: For HL7 use only, we could assume that this was the RIM, and only provide a version number. But providing a full reference to the RIM enables HL7 templates to be shared with templates on other reference models in a single registry</td>

               <td>.referenceModelId</td>
            </tr>

            <tr>
               <td>templateRepositoryIdentifier</td>

               <td>URL</td>

               <td>C</td>

               <td>
				Identifier of the primary registry where the Template is located. If the template
				has not been submitted to a registry, this element is optional, but once a template
				has been submitted, this field must be populated.
			   </td>

               <td>.repositoryURL</td>
            </tr>

            <tr>
               <td>Description</td>

               <td></td>

               <td></td>

               <td></td>

               <td></td>
            </tr>

            <tr>
               <td>descriptionLanguage</td>

               <td>CS</td>

               <td>M</td>

               <td>The natural language in which the Template is represented. (Note that
				CEN allows for multiple language descriptions in the template metadata but HL does not.)
				The language should be based on the languages defined in ISO 3166.
			   </td>

               <td>.descriptionLanguage</td>
            </tr>

            <tr>
               <td>templateDescription</td>

               <td>Text</td>

               <td>M</td>

               <td>A free text natural language description of the Template. Generally, this field should be used for things such as goals, variable lists, instructions for clinical use and interpretation, literature, examples from paper world, mapping from natural language to HL7 and the model itself, etc</td>

               <td>.description</td>
            </tr>

            <tr>
               <td>templateFormat</td>

               <td>CS</td>

               <td>M</td>

               <td>The format of the template definition itself. 
               <br />

               HL7 Templates are always defined in the form defined in this specification, so this value is fixed to “HL7.Template.v1”. Other
			   standards organisations may define other formats with associated values for this data element.
               <br />

               This field is documented to allow for registry interoperability with templates in other specifications, such as CEN 13606 templates</td>

               <td>.format</td>
            </tr>

            <tr>
               <td>evidenceSource</td>

               <td>URL</td>

               <td>O</td>

               <td>A description, reference or link to the published medical knowledge that was used in the definition of this Template</td>

               <td>.evidenceSource and CITATION attachments</td>
            </tr>

            <tr>
               <td>detailedDescription</td>

               <td>Text</td>

               <td>O</td>

               <td>A detailed explanation of the purpose of this Template, including features of interest. This may include an indication of the intended user group for which this definition is intended</td>

               <td>.detailedDescription</td>
            </tr>

            <tr>
               <td>cautionPoints</td>

               <td>Text</td>

               <td>O</td>

               <td>A formal statement regarding when this Template should not be used, or may be used erroneously. To define roles where the Template should not be used, or should be used with care. This field is used to expand in detail on the templateIntention</td>

               <td>.cautionPoints</td>
            </tr>

            <tr>
               <td>classification</td>

               <td>Term</td>

               <td>O</td>

               <td>A set of terms from a controlled reference terminology that may be used to assist with indexing and searching of templates</td>

               <td>.cautionPoints</td>
            </tr>

            <tr>
               <td>Publication</td>

               <td></td>

               <td></td>

               <td></td>

               <td></td>
            </tr>

            <tr>
               <td>publicationStatus</td>

               <td>CS</td>

               <td>M</td>

               <td>
               <list role="unordered">
                  <item>Draft</item>

                  <item>Not For Use (i.e. teaching)</item>

                  <item>For Production Use</item>

                  <item>Withdrawn</item>
                  
                  <item>Superseded</item>
               </list></td>

               <td>.publicationStatus</td>
            </tr>

            <tr>
               <td>publicationStatusChangeDate</td>

               <td>TS</td>

               <td>M</td>

               <td>The date that the current value for publicationStatus was applied of the Template</td>

               <td>.publicationStatusChangeDate</td>
            </tr>

            <tr>
               <td>publisher</td>

               <td>ST</td>

               <td>M</td>

               <td>The name of the author(s) institutional affiliations and contact infomation for the creators of the Template</td>

               <td>.publisher.name</td>
            </tr>

            <tr>
               <td>publishingAuthority</td>

               <td>II</td>

               <td>O</td>

               <td>The authoritative body who has reviewed the Template for clinical accuracy and relevance, and authorized it for publication. Registries may require templates to populate this element</td>

               <td>.publisher.id</td>
            </tr>

            <tr>
               <td>endorsingAuthority</td>

               <td>II</td>

               <td>O</td>

               <td>A list of bodies who have reviewed the Template for clinical accuracy and relevance, and endorsed it for use.</td>

               <td>.endorser.id</td>
            </tr>

            <tr>
               <td>revisionHistory</td>

               <td>Text</td>

               <td>C</td>

               <td>The free text description describing the changes in this version of the Template as compared to the previous
			   version. Since Template versions are built off of previous versions, the net effect of this field is to function as
			   a comprehensive historical reference of the Template. This field must be populated if the template is not the first
			   version.</td>

               <td>.revision</td>
            </tr>

            <tr>
               <td>effectiveDate</td>

               <td>TS</td>

               <td>O</td>

               <td>The date upon which the Template can be considered for use. Use of the Template prior to this date would be considered an invalid use of the Template</td>

               <td>.effectiveDate</td>
            </tr>

            <tr>
               <td>supersedingTemplate</td>

               <td>II</td>

               <td>O</td>

               <td>A template that has superseded this template and should be used instead. This field can only be populated if the publicationStatus is withdrawn</td>

               <td>.supersededBy</td>
            </tr>
            <tr>
               <td>supersededDate</td>

               <td>TS</td>

               <td>O</td>

               <td>The date that the Template was considered superseded</td>

               <td>.supersededDate</td>
            </tr>

         </table>
      </div2>
	  <div2 id="model">
		<head>Template Document Format</head>
		<p>
			A template is a single XML document. The XML format is based on the following UML diagram:
		</p>
		<p>
			<graphic source="graphics/Template-schema-uml.png" alt="Template Format in UML" />
		</p>
		<p>
			One important feature of this model for templates is that this working model for a template
			does not preserve CMET boundaries. While the HL7 static model for the template may create
			an assocation to a CMET, when the template package is prepared, the model that the CMET
			represents is "stitched" into place. This process is recursive, so that a template as defined
			by this model has no dependencies on other models. 
		</p>		
		<p>
			In the interests of consistency, this is also true of the RIM classes. A template includes the
			definitions of the RIM Classes as well. 
		</p>
		<p>
			The XML format that represents this model is described in a schema found in <loc href="#schema" xlink-form="simple" actuate="auto" show="embed">appendix C</loc>			
		</p>
		<p>
			Note that this specification does not use the HL7 V3 types; where possible, simple types are used that 
			map directly to UML kernel and W3C Schema types are used rather than the more complex V3 types, since 
			this format is intended to support V3 implementations. 
		</p>

		<div3 id="ttTemplate">
			<head>Template</head>
			<p>
				Specializes <loc href="#ttTemplateMetadata" xlink-form="simple" actuate="auto" show="embed">TemplateMetadata</loc>
			</p>
			<p>
			  The entry point of a template file. All templates have a single element of this type as their document element.
			</p>
			<table>	
				<tr>
					<th>Name</th>
					<th>Type</th>
					<th>Conf</th>
					<th>Documentation</th>
				</tr>					
				<tr>
					<td>model</td>
					<td><loc href="#ttConstrainedClass" xlink-form="simple" actuate="auto" show="embed">ConstrainedClass</loc></td>
					<td>O</td>
					<td>
						The HL7 static model that represents the constraints the template expresses.
						This is not the model from which the template is derived, but the template itself.
						The static model is represented using a simple object model that fully pre-coordinates
						all the dependent models such as templates for implementation convenience. The static model
						is optional; a template may not have a formal representation using a static model
					</td>
				</tr>					
				<tr>
					<td>rim</td>
					<td><loc href="#ttRIM" xlink-form="simple" actuate="auto" show="embed">RIM</loc></td>
					<td>M</td>
					<td>
					    The RIM definition underlying the definition of this template. This is the definitions of the
                        core RIM classes, that represent the classes that are being constrained by the template. Though
                        template may be applied to instances based on other versions of the RIM than the RIM defined 
                        here, the RIM definition is provided for semantic completeness when the template is considered
                        in the absence of an instance. The RIM definitions are only required if a static model
						representation is provided.
                    </td>
				</tr>					
				<tr>
					<td>attachments</td>
					<td><loc href="#ttAttachment" xlink-form="simple" actuate="auto" show="embed">Attachment</loc></td>
					<td>M</td>
					<td>One or more attachments providing supporting information for this template. If no model is present, there must always be at 
					least one attachment, which is the formal definition in a human readable language</td>
				</tr>					
			</table>
		</div3>
		<div3 id="ttTemplateMetadata">
			<head>TemplateMetadata</head>
			<p>
			  The metadata that defines the meaning and use of the template.
			</p>
			<table>	
				<tr>
					<th>Name</th>
					<th>Type</th>
					<th>Conf</th>
					<th>Documentation</th>
				</tr>					
				<tr>
					<td>name</td>
					<td>String</td>
					<td>M</td>
					<td>The formal name of the template</td>
				</tr>					
				<tr>
					<td>id</td>
					<td><loc href="#ttIdentifier" xlink-form="simple" actuate="auto" show="embed">Identifier</loc></td>
					<td>M</td>
					<td>A globally unique identifier for the template. This is the identifier that goes in the templateId in the instance when the template is used</td>
				</tr>					
				<tr>
					<td>derivationModelId</td>
					<td><loc href="#ttIdentifier" xlink-form="simple" actuate="auto" show="embed">Identifier</loc></td>
					<td>M</td>
					<td>The identifier of the model from which this template is derived</td>
				</tr>					
				<tr>
					<td>referenceModelId</td>
					<td><loc href="#ttIdentifier" xlink-form="simple" actuate="auto" show="embed">Identifier</loc></td>
					<td>M</td>
					<td>The identifier of the reference model on which this template is defined. In the case of HL7 templates, the reference model is always the RIM, and the identifier is always 2.16.840.1.113883.1.8</td>
				</tr>					
				<tr>
					<td>intention</td>
					<td>String</td>
					<td>M</td>
					<td>The intended purpose of the template</td>
				</tr>					
				<tr>
					<td>version</td>
					<td>String</td>
					<td>M</td>
					<td>The version of the template. There is not strict control over the value of this attribute, other than that it is must change each time the template or one of its CMETs changes</td>
				</tr>					
				<tr>
					<td>repositoryURL</td>
					<td>URL</td>
					<td>O</td>
					<td>The URL of the primary registry where this template is published, if the template is published. This property is mandatory if the template is published</td>
				</tr>					
				<tr>
					<td>format</td>
					<td>String</td>
					<td>M</td>
					<td>The format in which the template is stored. The format defined in this specificaiton is identified by the value "HL7.Template.v1", and this is the mandatory value if the template is an HL7 template</td>
				</tr>					
				<tr>
					<td>descriptionLanguage</td>
					<td>Set(String)</td>
					<td>M</td>
					<td>The language(s) used to define the metadata for this template, using the language system defined in
					the Internet standard RFC 3066 <loc href="http://www.ietf.org/rfc/rfc3066.txt" xlink-form="simple" actuate="auto" show="embed">http://www.ietf.org/rfc/rfc3066.txt</loc>. 
					</td>
				</tr>					
				<tr>
					<td>description</td>
					<td>String</td>
					<td>M</td>
					<td>A description of this template</td>
				</tr>					
				<tr>
					<td>detailedDescription</td>
					<td>String</td>
					<td>O</td>
					<td>A detailed description of this template</td>
				</tr>					
				<tr>
					<td>evidenceSource</td>
					<td>SET&gt;URL&lt;</td>
					<td>O</td>
					<td>URL(s) to web pages summarizing the evidence used when designing this template. When evidence comes from sources other than web pages, it can be referenced using an attachment of type CITATION</td>
				</tr>					
				<tr>
					<td>cautionPoints</td>
					<td>String</td>
					<td>O</td>
					<td>Any warnings about the scope of use of the template etc.</td>
				</tr>					
				<tr>
					<td>classification</td>
					<td><loc href="#ttTerm" xlink-form="simple" actuate="auto" show="embed">Term</loc></td>
					<td>O</td>
					<td>A set of terms from a controlled reference terminology that may be used to assist with indexing and searching of templates</td>
				</tr>					
				<tr>
					<td>publicationStatus</td>
					<td>PublicationStatus</td>
					<td>M</td>
					<td>
						The publication status of the template. The value SHALL be one of:
						<list role="unordered">
							<item>DRAFT - this template is still being authored</item>
							<item>NOT_FOR_USE - this template was abandoned without ever being labelled as for production use</item>
							<item>PRODUCTION - this template is ready for in production use</item>
							<item>WITHDRAWN - this template is withdrawn from use</item>
							<item>SUPERCEDED - this template has been superseded by some other template</item>
						</list>
					</td>
				</tr>					
				<tr>
					<td>publicationStatusChangeDate</td>
					<td>DateTime</td>
					<td>M</td>
					<td>The date that the publication status last changed</td>
				</tr>					
				<tr>
					<td>effectiveDate</td>
					<td>DateTime</td>
					<td>O</td>
					<td>If present, specifies the date that the template is ready for use.</td>
				</tr>					
				<tr>
					<td>supersededBy</td>
					<td><loc href="#ttIdentifier" xlink-form="simple" actuate="auto" show="embed">Identifier</loc></td>
					<td>O</td>
					<td>Id present, specifies the template that superseded this template. If this is valued, the publication status must be WITHDRAWN</td>
				</tr>					
				<tr>
					<td>publisher</td>
					<td><loc href="#ttNameAndContact" xlink-form="simple" actuate="auto" show="embed">NameAndContact</loc></td>
					<td>O</td>
					<td>The name and contact details of the authority that endorsed this template as being fit for publication</td>
				</tr>					
				<tr>
					<td>revision</td>
					<td><loc href="#ttRevision" xlink-form="simple" actuate="auto" show="embed">Revision</loc></td>
					<td>M</td>
					<td>A record of the revisions to this template that have occured, in date order</td>
				</tr>					
			</table>
		</div3>
		<div3 id="ttIdentifier">
			<head>Identifier</head>
			<p>
			  An identifier that uniquely identifies a thing or object
			</p>
			<table>	
				<tr>
					<th>Name</th>
					<th>Type</th>
					<th>Conf</th>
					<th>Documentation</th>
				</tr>					
				<tr>
					<td>root</td>
					<td>String</td>
					<td>M</td>
					<td>A unique identifier that guarantees the global uniqueness of the instance identifier. The root alone may be the entire instance identifier.</td>
				</tr>					
				<tr>
					<td>extension</td>
					<td>String</td>
					<td>O</td>
					<td>A character string as a unique identifier within the scope of the identifier root.</td>
				</tr>					
			</table>
		</div3>
		<div3 id="ttNameAndContact">
			<head>NameAndContact</head>
			<p>
			  Provides a set of name and contact details for an organisation or an individual. 
			</p>
			<table>	
				<tr>
					<th>Name</th>
					<th>Type</th>
					<th>Conf</th>
					<th>Documentation</th>
				</tr>					
				<tr>
					<td>name</td>
					<td>String</td>
					<td>M</td>
					<td>A plain text rendering of a the name of the organisation or individual</td>
				</tr>					
				<tr>
					<td>id</td>
					<td><loc href="#ttIdentifier" xlink-form="simple" actuate="auto" show="embed">Identifier</loc></td>
					<td>O</td>
					<td>A globally unique identifier for the organisation or individual</td>
				</tr>					
				<tr>
					<td>address</td>
					<td>String</td>
					<td>O</td>
					<td>The full postal address of the organisation or individual. May include line breaks</td>
				</tr>					
				<tr>
					<td>email</td>
					<td>String</td>
					<td>O</td>
					<td>The email address contact for the organisation or individual</td>
				</tr>					
			</table>
		</div3>
		<div3 id="ttRevision">
			<head>Revision</head>
			<p>
			  A record of a revision to the template. There must be at least a record for each time the
			  template is published. There will always be at least one record. The first record is the 
			  name of the individual that first created the template.
			</p>
			<table>	
				<tr>
					<th>Name</th>
					<th>Type</th>
					<th>Conf</th>
					<th>Documentation</th>
				</tr>					
				<tr>
					<td>author</td>
					<td><loc href="#ttNameAndContact" xlink-form="simple" actuate="auto" show="embed">NameAndContact</loc></td>
					<td>M</td>
					<td>The name and contact details of one or more authors who made the change</td>
				</tr>					
				<tr>
					<td>date</td>
					<td>DateTime</td>
					<td>M</td>
					<td>The date when the change occurred</td>
				</tr>					
				<tr>
					<td>comment</td>
					<td>String</td>
					<td>O</td>
					<td>optional comment from the user explaining their changes</td>
				</tr>					
			</table>
		</div3>
		<div3 id="ttTerm">
			<head>Term</head>
			<p>
			  A term in a controlled reference terminology.
			</p>
			<table>	
				<tr>
					<th>Name</th>
					<th>Type</th>
					<th>Conf</th>
					<th>Documentation</th>
				</tr>					
				<tr>
					<td>code</td>
					<td>String</td>
					<td>M</td>
					<td>An expression in a syntax defined by the code system which describes the concept.
                        Usually this would be a simple code, but post-coordinated expressions may also be used</td>
				</tr>					
				<tr>
					<td>codeSystem</td>
					<td>String</td>
					<td>M</td>
					<td>The identity of the codeSystem that defines the syntax and concepts used in the code. This must be a UID, as defined
					in the rules for the CD.codeSystem property in the V3 abstract datatypes</td>
				</tr>					
				<tr>
					<td>codeSystemVersion</td>
					<td>String</td>
					<td>O</td>
					<td>If applicable, a version descriptor defined specifically for the given code system. For further information, consult
					the rules for the CD.codeSystemVersion property in the V3 abstract datatypes</td>
				</tr>					
			</table>
		</div3>
		<div3 id="ttAttachment">
			<head>Attachment</head>
			<p>
			   An attachment that contains additional information pertinent to this template.
			   A reference to the content may be provided. Additionally, the content may also
			   be provided. If no content is provided, then the content must be retrieved from
			   the reference when used. At least one of reference and content must be provided.
			</p>
			<table>	
				<tr>
					<th>Name</th>
					<th>Type</th>
					<th>Conf</th>
					<th>Documentation</th>
				</tr>					
				<tr>
					<td>type</td>
					<td>AttachmentType</td>
					<td>M</td>
					<td>
						The type of attachment. Possible values are
						<list role="unordered">
							<item></item>
							<item>STATEMENT: a formal definition in a human readable language</item>
							<item>STATIC_MODEL: The static model in MIF format</item>
							<item>STATIC_MODEL_IMAGE: An image of the static model (usually a .gif or a .png)</item>
							<item>COMPUTABLE: a set of enforceable rules for the template stated in some computable language. The mediatype will define the language. Note that the mediatype for schematron is application/schematron+xml</item>
							<item>DOCUMENTATION: Documentation that assists users understand why the template is designed the way it is</item>
							<item>ENDORSEMENT: A document that represents and endorsement of the template by some authority</item>
							<item>EXAMPLE: An example of data use that conforms to the template (This is expected to be a document of some kind rather than an XML instance)</item>
							<item>CITATION: Evidence sourced from a standard citation. The type of the citation is described by the mediatype. Of the many citation formats that exist, BibTex is recommended, but others may be used</item>						
						</list>
					</td>
				</tr>					
				<tr>
					<td>mediatype</td>
					<td>String</td>
					<td>O</td>
					<td>The mediatype of the attachment. This must be populated if the content is provided rather than using a reference</td>
				</tr>					
				<tr>
					<td>reference</td>
					<td>URL</td>
					<td>O</td>
					<td>A reference to a location where the content of this attachment may be found</td>
				</tr>					
				<tr>
					<td>content</td>
					<td>Binary</td>
					<td>O</td>
					<td>The actual content of the attachment</td>
				</tr>					
			</table>
		</div3>
		<div3 id="ttRIM">
			<head>RIM</head>
			<p>
			   A representation of the RIM classes that underly this template definition. 
			</p>
			<table>	
				<tr>
					<th>Name</th>
					<th>Type</th>
					<th>Conf</th>
					<th>Documentation</th>
				</tr>					
				<tr>
					<td>version</td>
					<td>String</td>
					<td>M</td>
					<td>The version of the RIM upon which this template is based</td>
				</tr>					
				<tr>
					<td>classes</td>
					<td><loc href="#ttRimClass" xlink-form="simple" actuate="auto" show="embed">RimClass</loc></td>
					<td>O</td>
					<td>a list of RIM classes that are referred to directly or
					indirectly by the template. This does not need to include all the RIM classes; see the comments above.</td>
				</tr>					
			</table>
		</div3>
		<div3 id="ttArtefact">
			<head>Artefact</head>
			<p>
			  An artefact that is part of a static model.
			</p>
			<table>	
				<tr>
					<th>Name</th>
					<th>Type</th>
					<th>Conf</th>
					<th>Documentation</th>
				</tr>					
				<tr>
					<td>constraints</td>
					<td><loc href="#ttConstraint" xlink-form="simple" actuate="auto" show="embed">Constraint</loc></td>
					<td>O</td>
					<td>0 or more constraints that apply to the artefact</td>
				</tr>					
			</table>
		</div3>
		<div3 id="ttConstraint">
			<head>Constraint</head>
			<p>
			  A constraint that applies to an artefact in a static model.
			</p>
			<table>	
				<tr>
					<th>Name</th>
					<th>Type</th>
					<th>Conf</th>
					<th>Documentation</th>
				</tr>					
				<tr>
					<td>name</td>
					<td>String</td>
					<td>O</td>
					<td>The name of the constraint. This can be used when a constraint fails to provide a human readable error message.</td>
				</tr>					
				<tr>
					<td>source</td>
					<td>String</td>
					<td>M</td>
					<td>The source of the constraint in the specified language</td>
				</tr>					
				<tr>
					<td>Property</td>
					<td>ConstraintLanguage</td>
					<td>M</td>
					<td>
						The language that the constraint is expressed in. The following languages are supported:
						<list role="unordered">
							<item>OCL: OCL 2 as described in the OCL 2 specification, and further described in the specification
							<loc href="http://www.hl7.org/v3ballot2007sep/html/infrastructure/constraints/constraints.htm#ConstraintExpression" 
							xlink-form="simple" actuate="auto" show="embed">"Use of OCL as a constraint language in RIM Derived Models"</loc>
							</item>
						</list>
					</td>
				</tr>					
			</table>
		</div3>
		<div3 id="ttFeature">
			<head>Feature</head>
			<p>
				Specializes <loc href="#ttArtefact" xlink-form="simple" actuate="auto" show="embed">Artefact</loc>
			</p>
			<p>
			  A feature of a class, either an attribute or an association.
			</p>
			<table>	
				<tr>
					<th>Name</th>
					<th>Type</th>
					<th>Conf</th>
					<th>Documentation</th>
				</tr>					
				<tr>
					<td>conformance</td>
					<td><loc href="#ttConformance" xlink-form="simple" actuate="auto" show="embed">Conformance</loc></td>
					<td>M</td>
					<td>Whether the feature is (A)llowed, (R)equired or (NP) Not Permitted</td>
				</tr>					
				<tr>
					<td>mandatory</td>
					<td>Boolean</td>
					<td>M</td>
					<td>Whether the feature is mandatory</td>
				</tr>					
				<tr>
					<td>max</td>
					<td>Integer</td>
					<td>M</td>
					<td>The maximum number of times the feature can occur</td>
				</tr>					
				<tr>
					<td>min</td>
					<td>Integer</td>
					<td>M</td>
					<td>The minimum number of times the feature can occur</td>
				</tr>					
				<tr>
					<td>updateModes</td>
					<td>Set(String)</td>
					<td>O</td>
					<td>The allowed update modes for this feature. Note that using update modes in templates is not recommended.</td>
				</tr>					
				<tr>
					<td>extensibilityNamespace</td>
					<td>String</td>
					<td>O</td>
					<td>If this feature is an extensibility feature (not found in the RIM, and added according the rules defined in the <loc href="http://www.hl7.org/v3ballot/html/infrastructure/conformance/conformance.htm" xlink-form="simple" actuate="auto" show="embed">Refinement, Constraint and Localization Specification</loc>), this is the namespace it must have in the instance.</td>
				</tr>					
			</table>
		</div3>
		<div3 id="ttAttribute">
			<head>Attribute</head>
			<p>
				Specializes <loc href="#ttFeature" xlink-form="simple" actuate="auto" show="embed">Feature</loc>
			</p>
			<p>
			  An attribute of a class. 
			</p>
			<p>
				Note that no default value can be specified in a template. This rule exists because it is 
				agreed that applications must be able to correctly understand instances that apply the
				templates without knowing the template. If the template asserted default values that were not
				represented in the instance, this would no longer be true. Hence the template cannot specify
				a default value, but may specify a fixed value.				
			</p>
			<table>	
				<tr>
					<th>Name</th>
					<th>Type</th>
					<th>Conf</th>
					<th>Documentation</th>
				</tr>					
				<tr>
					<td>datatype</td>
					<td>String</td>
					<td>O</td>
					<td>The datatype which the attribute must conform to. This must be a datatype declared in the abstract datatypes</td>
				</tr>					
				<tr>
					<td>flavor</td>
					<td>String</td>
					<td>O</td>
					<td>
					  A datatype flavor which the attribute must conform to in addition to the base dataype.
					  <br/>
					  Note that both datatype and datatype flavor are provided for implementation tooling convenience,
					  so that implementation tools do not need to concern themselves with datatype flavors they do not
					  know. An HL7 design tool that supported datatype flavors need only prompt the model designer
					  for a datatype flavor, for example, and then store both the flavor and its normative base when
					  generating the template format. 
					</td>
				</tr>					
				<tr>
					<td>possibleValues</td>
					<td>Set(String)</td>
					<td>O</td>
					<td>A set of allowable values for the attribute. May only be used with the datatypes BL, INT, ST, REAL. For coded values, use the vocabulary constraints</td>
				</tr>					
				<tr>
					<td>vocabulary</td>
					<td><loc href="#ttVocabularyConstraints" xlink-form="simple" actuate="auto" show="embed">VocabularyConstraints</loc></td>
					<td>C</td>
					<td>The vocabulary constraints that apply to this attribute. Must be present if the type is derived from CD (CE, CV, CO, CS, and flavors), and must not be present if the type is not derived from CD</td>
				</tr>					
			</table>
		</div3>
		<div3 id="ttVocabularyConstraints">
			<head>VocabularyConstraints</head>
			<p>
			  The vocabulary constraints that apply to an attribute. Only one of domain, valueSet and code may be populated. <i>This is under development,
			  and may change when the MIF vocabulary data elements are resolved. </i>
			</p>
			<table>	
				<tr>
					<th>Name</th>
					<th>Type</th>
					<th>Conf</th>
					<th>Documentation</th>
				</tr>					
				<tr>
					<td>extensions</td>
					<td>Boolean</td>
					<td>M</td>
					<td>Whether the list of allowed codes can be extended (CWE or CNE)</td>
				</tr>					
				<tr>
					<td>domain</td>
					<td>String</td>
					<td>O</td>
					<td>The domain from which the code must be taken</td>
				</tr>					
				<tr>
					<td>valueSet</td>
					<td>String</td>
					<td>O</td>
					<td>The valueSet from which the code must be taken</td>
				</tr>					
				<tr>
					<td>code</td>
					<td>String</td>
					<td>O</td>
					<td>The fixed code that must be used</td>
				</tr>					
			</table>
		</div3>
		<div3 id="ttClassArtefact">
			<head>ClassArtefact</head>
			<p>
				Specializes <loc href="#ttArtefact" xlink-form="simple" actuate="auto" show="embed">Artefact</loc>
			</p>
			<p>
			  A definition of a class that may have generalisations, choices, attributes and associations. 
			</p>
			<table>	
				<tr>
					<th>Name</th>
					<th>Type</th>
					<th>Conf</th>
					<th>Documentation</th>
				</tr>					
				<tr>
					<td>category</td>
					<td>RimClassCategory</td>
					<td>O</td>
					<td>The category that the class is in. This corresponds to the colour of the class in a static model diagram. Possible Values:
						<list role="unordered">
							<item>ENTITY</item>
							<item>ROLE</item>
							<item>ROLE_LINK</item>
							<item>PARTICIPATION</item>
							<item>ACT_RELATIONSHIP</item>
							<item>ACT</item>
							<item>DOCUMENT</item>
							<item>INFRASTRUCTURE</item>
						</list>
					</td>
				</tr>					
				<tr>
					<td>sourceModel</td>
					<td>String</td>
					<td>O</td>
					<td>The V3 package name in which this class is defined.</td>
				</tr>					
				<tr>
					<td>features</td>
					<td><loc href="#ttFeature" xlink-form="simple" actuate="auto" show="embed">Feature</loc></td>
					<td>O</td>
					<td>0 or more features (attributes and associations) that belong to the class, in the order they would be found in the instance.</td>
				</tr>					
			</table>
		</div3>
		<div3 id="ttAssociation">
			<head>Association</head>
			<p>
				Specializes <loc href="#ttFeature" xlink-form="simple" actuate="auto" show="embed">Feature</loc>
			</p>
			<p>
			  An association between this class and another class. 
			</p>
			<table>	
				<tr>
					<th>Name</th>
					<th>Type</th>
					<th>Conf</th>
					<th>Documentation</th>
				</tr>					
				<tr>
					<td>rimName</td>
					<td>String</td>
					<td>M</td>
					<td>The name of this association in the RIM (i.e. "target" or "player", etc)</td>
				</tr>					
				<tr>
					<td>target</td>
					<td><loc href="#ttClassArtefact" xlink-form="simple" actuate="auto" show="embed">ClassArtefact</loc></td>
					<td>M</td>
					<td>The target class of this association. Unlike every other property in the template format definition, the
					    target can be referred to by value or by reference. This is because a class may occur
						as the target for more than one association. For non-RIM classes, the first occurence
						of the target in the template instance must be contained by value, and the other occurences
						must be done by reference. RIM classes are always contained by the <loc href="#ttRIM" xlink-form="simple" actuate="auto" show="embed">RIM</loc>
						class and association targets are always by reference.</td>
				</tr>					
			</table>
		</div3>
		<div3 id="ttConstrainedClass">
			<head>ConstrainedClass</head>
			<p>
				Specializes <loc href="#ttClassArtefact" xlink-form="simple" actuate="auto" show="embed">ClassArtefact</loc>
			</p>
			<p>
			  A ConstrainedClass defined in a static model - a constraint on a class defined in the RIM. 
			  ConstrainedClasses may have choices, attributes and associations. Choices are only allowed when the class is
              abstract. Abstract classes cannot have any attributes. The term CloneClass is used for the same this 
              construct in HL7 Static Models.
			</p>
			<table>	
				<tr>
					<th>Name</th>
					<th>Type</th>
					<th>Conf</th>
					<th>Documentation</th>
				</tr>					
				<tr>
					<td>abstract_</td>
					<td>Boolean</td>
					<td>O</td>
					<td>Whether this class is abstract (has choices and associations) or not (has attributes and associations)</td>
				</tr>					
				<tr>
					<td>derives</td>
					<td>RimClass</td>
					<td>M</td>
					<td>The RIM class that this clone class is a constraint on.</td>
				</tr>					
				<tr>
					<td>choices</td>
					<td>ConstrainedClass</td>
					<td>O</td>
					<td>0 or more choices that are contained within this ConstrainedClass.
					There can only be choices if the class is abstract.
					Nested choices are represented as choices on the choices, so
					the only choices on a class are the classes it immediately contains.</td>
				</tr>					
			</table>
		</div3>
		<div3 id="ttRimClass">
			<head>RimClass</head>
			<p>
			   A Class defined in the RIM itself (corresponds to the UML class definition of the RIM class). 
 			   RimClasses may have generalisations, attributes and associations. 
			</p>
			<table>	
				<tr>
					<th>Name</th>
					<th>Type</th>
					<th>Conf</th>
					<th>Documentation</th>
				</tr>					
				<tr>
					<td>super</td>
					<td><loc href="#ttRimClass" xlink-form="simple" actuate="auto" show="embed">RimClass</loc></td>
					<td>O</td>
					<td>The generalization (superclass) of this class. Only InfrastructureRoot does not have a generalization.</td>
				</tr>					
			</table>
		</div3>
	  </div2>
	</div1>
    <div1 id="Conformance" ballotStatus="DSTU">
        <head>Conformance</head>
        <div2 id="ConformanceTemplate">
			<head>Templates Conformance</head>
			<p>
				<emph role="strong">Conf-001:</emph> Templates must be valid according to this specification.
			</p>
			<p>
				<emph role="strong">Conf-002:</emph> Templates must conform to the schema published as part of this specification.
				Note that not all templates that conform to the schema are actually valid templates.
			</p>
			<p>
				<emph role="strong">Conf-003:</emph> All versions of a template must be backwards compatible with prior versions. 
				Any change to the semantic meaning of the template that is not backwards compatible will require a new template 
				with a different identifier to be created. A change is not backwards compatible if it may result in an instance
				processor that is not aware of the more recent definition of the template interpreting conformant data incorrectly.
				Generally, removing or changing the meaning of existing data elements or their associated vocabularies is not backwards
				compatible. Further discussion concerning backwards compatibility may be found in the ARB document
				<loc href="http://www.hl7.org/v3ballot2007sep/html/help/subs/subs.htm#backcomp_subs" xlink-form="simple" actuate="auto" show="embed">
				Substantive Change</loc>. 
			</p>
        </div2>
        <div2 id="ConformanceInstance">
			<head>Instance Conformance</head>
            <p>
				<emph role="strong">Conf-021:</emph> Instances must must be valid according to any templates
				that are applied, either by reference in the instance or by definition from a profile or the
				applicable interoperability paradigm.
            </p>
            <p>
				<emph role="strong">Conf-022:</emph> The use of templateIds in the instance must be consistent
				with any rules made by the applicable interoperability paradigm and any other interoperability 
				contracts that apply to the context of use of the instance.
            </p>
            <p>
				<emph role="strong">Conf-023:</emph> When an HL7 published normative CIM is used as a template,
				it shall be identified using the model Id as described in the HDF in templateId.extension and
				the OID value 2.16.840.1.113883.1.3 in templateId.root
			</p>
            <p>
				<emph role="strong">Conf-024:</emph> When an HL7 authored static model that is not a CIM is
				used as a template, it shall be identified using the model Id as described in the HDF in
				templateId.extension and the OID value 2.16.840.1.113883.10 in templateId.root
			</p>
            <p>
				<emph role="strong">Conf-025:</emph> The OID values 2.16.840.1.113883.1.3 and 2.16.840.1.113883.10
				shall not be used to refer to Static Models that are not published by HL7 or created by affiliates
				or organizational members following HL7 naming conventions. Instead, an OID based on the
				organizational OID of the organization authoring the template should be used.
			</p>
        </div2>
        <div2 id="ConformanceApplication">
			<head>Application Conformance</head>
			<p>
				<emph role="strong">Conf-031:</emph> Instance processing applications may reject an instance if it
				is not valid with respect of any of the applied templates, but are not required to do so unless
				specified by the interoperability paradigm.
			</p>
			<p>
				<emph role="strong">Conf-032:</emph> An instance processing application SHALL NOT reject an instance
				because of the presence of any applied template for which the instance meets the constraints
				specified in the template.
			</p>
			<p>
				<emph role="strong">Conf-033:</emph> An instance processing application may reject an instance
				because of the absence of a particular template, only as specified by the interoperability paradigm.
			</p>
        </div2>
		<div2 id="ConformanceMethod">
			<head>Templates, Datatypes and Conformance</head>
			<p>
				The abstract datatypes defines the nullFlavor attribute, and links this to conformance. If an attribute
				is labeled mandatory, it must not have a nullFlavor in the instance. The datatypes define this 
				behavior in terms of a "constraining model". In the context of this specification, the constraining
				model is the expressed model. 
			</p>
			<p>
				Templates - applied models - do not work in quite the same fashion, because templates exist to
				apply additional conformance constaints on the data elements. This means that there may be multiple
				constraints in a data element, and it may meet some of them and not others. However there is only
				one nullFlavor. 
			</p>
			<p>
				As an example, take a coded element such as Act.code. The expressed model marks this as optional
				and assigns it a valueset representing SNOMED. The act has a template applied which requires a mandatory
				Act.code from LOINC. The sending system does not have a SNOMED code, but does have a LOINC code. 
			</p>
			<p>
				In this case, the attribute itself must have a nullFlavor of OTH, with a codeSystem of 2.16.840.1.113883.19.6.96,
				since there is no SNOMED code. This is conformant to the expressed model, since the act.code element is
				optional. In order to meet the template requirements, the attribute has a translation which has no null flavor,
				a code, and the LOINC codeSystem of 2.16.840.1.113883.6.1.
			</p>
			<p>
			    In order to check template constraints conformance, a nullFlavor is still required, but it need not be
				the nullFlavor of the data element itself. 
			</p>
			<p>
			    <emph role="strong">Conf-041:</emph> Where the type has translations (CD/CE, PQ, ED, ST, and SC) the 
				template constraints may be satisfied by the data element itself, or by one of the translations.
			</p>
			<p>
				Where the datatype does not have translations, there is only one nullFlavor, and the data element may only
				be non-Null when all the constraints upon it are satisfied. 
			</p>
			<p>
				In addition, the template may describe a constrained datatype where a collection (BAG, LIST, DSET, HIST) has
				been constrained to a single item, and rules made upon the item. In this case, the instance may not need
				to contain just a single item. 
			</p>
			<p>
			    <emph role="strong">Conf-042:</emph> Where a template specifies a single data item, and the instance 
				contains a collection of items of type BAG, LIST, DSET or HIST, the instance conforms to the template
				if any one of the of items in the collection conforms to the template.
			</p>
			<p>
				Both these conformance statements have implications for how a template is designed. In particular, if a 
				template wishes to constrain a RIM item that is a SET&lt;II> so that there can only be one item, then it
				should leave the type as SET&lt;II> and set the cardinality to 1..1, whereas if the template wishes to
				assert that the identifiers must include a particular identifier, it should set the type to II, and make
				the appropriate constraints. In regard to these aspects, templates work differently to other models, and
				designers should keep these in mind.
			</p>
		</div2>
      </div1>

      <div1 id="RequirementsAndUseCases">
         <head>Requirements &amp; Use Cases</head>
         <div2 id="DefinitionOfClinicalConcepts">
            <head>Definition of Clinical Concepts</head>
            <p>
				HL7 Static Models serve as a structured formalism through which human beings can unambiguously
				exchange agreed knowledge models that describe concepts they share. In this wider context,
				templates are often used to define knowledge models at a finer level of granularity
				than the HL7 interoperability definitions.
			</p>
			<p>
				Since all templates are also HL7 Static Models, all templates are a formal definition of a 
				particular concept. Templates may be used to further refine any models in any domain of interest 
				to HL7, including messaging infrastucture, healthcare administration and clinical concepts. Since, for various historical 
				and industry reasons, HL7 models are generally more specific and proscriptive in messaging 
				and administrative domains, templates are most often used to define clinical concepts.
			</p>
         </div2>

         <div2 id="ConstructionOfInstances">
            <head>Construction of Instances</head>
            <p>
				HL7 Static Models are used to guide and direct information input for a message or document. This 
				may take the form of a specification for a user input interface, or where the Static Model is 
				used to guide an application in constructing a proper instance. Templates can be used to provide 
				extra support for this by providing knowledge models that are applied on a context sensitive basis 
				to a consistently applied more general model, and provide a coherent framework for customizing 
				application behavior.
			</p>
            <p>
				A common example of this use is a consistent laboratory report model provided by HL7, where 
				specific templates are used to specify the form of particular laboratory reports such as 
				CBC. Applications using templates in this manner may also choose to reference the template 
				in the instance to support validation and processing.
			</p>
			<p>
				The focus of this template specification is on defining templates as information constraints 
				in the context of V3 RIM based instances. Applications may need to use other resources 
				to define how the information model described in the template is properly presented or 
				applied in other contexts, such as input screens; these things are out of scope of this 
				template specification.
			</p>
         </div2>
         <div2 id="InstanceValidation">
            <head>Instance Validation</head>
            <p>
				Templates are also used to support validation of instances. When a template is applied,
				either by definition or by reference, the instance can be validated against the constraints 
				expressed in the template in addition to the base static model identified in the interoperability 
				paradigm.
			</p>
            <p>
				Template definitions may overlap as they apply to an instance. More than one template may 
				be applied to a given class, or a template defined elsewhere in the instance may still 
				apply when a new template is applied. Where more than one model (templates and the underlying 
				model) apply to a feature, the possible valid set of instances for the feature is the 
				set intersection of the set of instances described by each applicable model. Note that 
				it may be that there is no instance which can satisfy all the applied templates if the 
				models contain incompatible constraints (the set of valid instances is the empty set).
			</p>
			<p>
				A practical example would be in the case where the Example CIM had this model:
			</p>
			<p>
               <graphic source="graphics/example-cim-validation.png" alt="Example CIM" />
            </p>
			<p>
				In this case, the component has a mandatory contextControlCode, but the Barthel model
				prohibits it:
			</p>
			<p>
               <graphic source="graphics/example-barthel-validation.png" alt="Barthel Index" />
            </p>
			<p>
				So in this case there are no valid instances that can be both an Observation valid to 
				the Example CIM model and the Barthel_Index at the same time.
			</p>
         </div2>
         <div2 id="ProcessingSupport">
            <head>Processing Support</head>
            <p>
				When an application is aware that a template has been applied to a portion of an instance,
				it can choose to process the instance in terms of the template definition.
			</p>
			<p>
				Processing in terms of the template definition may mean either using different code optimized 
				to the terms and valuesets defined in the templates, or it may mean processing linked 
				to the class names in the templates. Implementers choosing to process based on a template 
				in this second fashion are cautioned to be aware of the issues that are documented in 
				sections <loc href="#TemplateConceptsAndIssues" xlink-form="simple" actuate="auto" show="embed">Template
				Concepts &amp; Issues</loc> and <loc href="#Conformance" xlink-form="simple" actuate="auto" show="embed">
				Conformance</loc>.
			</p>
			<p>
				The application may choose to use the template definition as a basis for understanding the 
				instance, or it may choose to the use the template as the basis for applying rules in 
				support of it’s processing, such as “is this an instance of a normal CBC”?
			</p>
			<p>
				Finally, templates can be used as definitions to describe the structure and relationships
				of data. An exanple is the use of a template made accessible via automated query: "Where
				would I have to look to find all instances of a WBC?", where the template is used to
				define the rules used to decide whether an instance represents a WBC. In this case, the
				template is not used to determine whether an instance represents a WBC based on the presence
				of a matching templateId in the instance, but based on the presence of data in the instance that
				meets the criteria defined in the template.
			</p>
         </div2>

         <div2 id="CompositionOfTemplates">
            <head>Composition of Templates</head>
            <p>
				Templates are often composed to form a more complete definition of a concept, in order to 
				facilitate the reuse of templates in many contexts. A template may designate that some 
				other template or group of templates apply at some point in the template. This can even 
				be useful at the root of the template, where an otherwise empty template would provide 
				a grouping construct. CMET bindings are used to represent this composition, and templates
				may use new CMET binding constructs as they are developed in the base HL7 methodology
				to manage composition.
			</p>
         </div2>

         <div2 id="TemplateIdentification">
            <head>Identification</head>
			<p>
				It must be possible to register templates in a central registry in order to facilitate sharing 
				of knowledge. Although templates do not need to be registered in any particular registry 
				or even at all, registration of templates will facilitate common sharing. In order to 
				support template registration and sharing, all templates must be uniquely identified 
				and appropriate metadata (see section <loc href="#metadata" xlink-form="simple" actuate="auto" show="embed">Metadata</loc>) must be defined to support useful searching 
				of the registry.
			</p>
         </div2>

         <div2 id="DataTypeSpecializations">
            <head>Data Type Specializations</head>
			<p>
				Templates are able to make various forms of constraints on the datatypes of the attributes 
				within the scope of the template. However, it is also possible to constrain V3 data types 
				themselves in a re-usable fashion. These resusable datatype constraints bear many similarities 
				with templates, but since the use of these constrained datatypes needs a different pattern 
				for re-use due to the breadth of application of the constrained data types, and for various 
				technical reasons related to how HL7 Static Models are represented, they are described 
				as data type specializations, and the use of these is described in the refinement and 
				localization topic <loc href="http://www.hl7.org/v3ballot/html/infrastructure/conformance/conformance.htm" xlink-form="simple" actuate="auto" show="embed">
				refinement and localization topic</loc>.
            </p>
         </div2>

         <div2 id="ConstraintRequirements">
            <head>Constraint Requirements</head>
            <p>
				This section lists the requirements that have been identified for the kind of constraints that 
				a template may make on the instance to which it is applied.
			</p>
            <p>
				<i>Note: This list is defined here to define the desired features for templates. Where
				templates are represented using HL7 static models, it is not yet clear how some of these
				features are correctly implemented. This is matter of active development between the MnM
				and template committees, and new static model methodology features may be adopted for use
				in templates as they are defined.</i>
			</p>

            <div3 id="StaticAssertions">
               <head>Static Assertions</head>
               <list role="unordered">
                  <item>A template can choose not to constrain all, some, or none of the attributes for a class</item>
                  <item>A template can choose not to constrain all, some, or none of the associations for a class</item>
                  <item>A template can constrain the cardinality of an association.</item>
                  <item>A template can constrain the cardinality of an attribute.</item>
                  <item>A template can constrain any attribute value to be a subset of the values allowed in the reference model. 
					<list role="unordered">
						<item>A template can constrain the set of allowable date/time values for attributes with date/time data types.</item>
						<item>A template can constrain the set of allowable code values for attributes that are terminology concepts.</item>
						<item>A template can constrain the set of allowable numbers for attributes that are numbers.</item>
					</list>
                  </item>
                  <item>A template can constrain the markup within an ED data type.
					<list role="unordered">
						<item>Example: If the Media Type of an ED data type is “text/html”, a template can preclude the use of the &lt;table&gt; element.</item>
						<item>Example: If the Media Type of an ED data type is “text/html”, a template can constrain the markup to only allow for a list or a table, depending on the context.</item>
					</list>
                  </item>
                  <item>A template can constrain any data type component, including recursively-nested components following the rules laid out in the data type abstract specification and the datatype refinement rules described in 
					<loc href="http://www.hl7.org/v3ballot/html/infrastructure/conformance/conformance.htm" xlink-form="simple" actuate="auto" show="embed">Refinement, Constraint and Localization Specification</loc>.
                  </item>
                  <item>All additional constraints that can be expressed in a normative specification can be further constrained in a template.</item>
                  <item>A template can constrain recursively nested classes, and can apply different constraints on each nested class. 
					<list role="unordered">
						<item>Example: A Observation with Observation.code = “CBC” has a required nested Observation with Observation.code = “HGB” and an optional nested Observation with Observation.code = “HCT”.</item>
					</list>
                  </item>
                  <item>A template can “unroll” a recursive relationship specified in some other static model.</item>
               </list>
            </div3>

            <div3>
				<head>Co-occurrence assertions</head>
				<p>
					These assertions range from fairly easy to complex. The final requirement stated here is 
					the most general and expressive and also the most complex to implement in a standard way.
				</p>

               <list role="unordered">
                  <item>The value of one attribute can be constrained based on the value of another attribute.
                  <list role="unordered">
                     <item>Example: If attributeOne is “X”, then attributeTwo’s value must be “A”.</item>

                     <item>Chronological assertions can constrain the date/time value of one attribute based on the date/time of another field. 
                     <list role="unordered">
                        <item>Example: The start time for attributeOne is (earlier | later | equal to) the start time of attributeTwo.</item>
                     </list>
                     </item>

                     <item>Numeric comparison assertions can constrain the numeric value of one attribute based on the value of another attribute. 
                     <list role="unordered">
                        <item>Example: The value of attributeOne is (equal to | less than | greater than) the value of attributeTwo.</item>
                     </list>
                     </item>

                     <item>Numeric operation assertions can constrain the numeric value of one attribute based on a numeric operator applied to the value of another attribute or constant. 
                     <list role="unordered">
                        <item>Example: The value of attributeOne is (equal to | less than | greater than) the value of attributeTwo (plus 7 | divided by 27).</item>
                     </list>
                     </item>

                     <item>String comparison assertions can constrain the string value of one attribute based on the value of another field. 
                     <list role="unordered">
                        <item>Example: The string value of attributeOne is contained in the value of attributeTwo.</item>
                     </list>
                     </item>
                  </list>
                  </item>

                  <item>A template can constrain the presence or absence of a attribute based on the presence or absence of another attribute. 
                     <list role="unordered">
                  <item>Example: If attributeOne is present (regardless of its value), attributeTwo must also be present.</item>
                     </list>
                  </item>

                  <item>Any constraint a template can make can be made dependent on the value expressed in one or more other attributes. For instance, in addition to constraining the cardinality of an association, a template can constrain the cardinality based on the value in a particular attribute. 
                     <list role="unordered">
                  <item>Example: If ((attributeOne is “X” or “Y”) OR (attributeTwo is “ABC”)) then ((a nested act relationship under Observation is required) AND (attributeThree in the nested act has a value of “A” or “B” or “C”) AND (attributeThree in the nested act cannot be NULL)).</item>
                     </list>
                  </item>
               </list>
            </div3>

            <div3>
               <head>Containment assertions</head>

               <list role="unordered">
                  <item>Data descendant assertions can constrain allowable depth at which one component is nested within another component.   
                  <list role="unordered">
                     <item>Example: The vital-signs section must be (a direct child of | some descendant of | less than a depth of X from) the physical-exam section.</item>
                  </list>
                  </item>

                  <item>Items in a template can be “ordered” or “unordered”. In an ordered template, the order of the stated assertions is important. In an unordered template, the order is not important. 
                  <list role="unordered">
                     <item>Example: Assertion One: There is a nested act under observationOne that has an observation.code for “hemoglobin”. Assertion Two: There is a nested act under observationOne that has an observation.code for “hematocrit. If the template is “ordered”, the “hemoglobin” must come before the “hematocrit”. If the template is “unordered” the “hemoglobin” can come before or after the “hematocrit”.</item>
                  </list>
                  </item>
               </list>
            </div3>

            <div3>
               <head>Logic assertions</head>

               <list role="unordered">
                  <item>Logical operators can be applied to a set of assertions to indicate which assertions in the set must be true or false.
                  <list role="unordered">
                     <item>Example: (All | at least X | at most X | exactly X) of the assertions contained in this set must be (true | false).</item>
                  </list>
                  </item>
               </list>
            </div3>

            <div3>
               <head>Composition assertions</head>

               <list role="unordered">
                  <item>A template can designate that the constraints for a class and its attributes and associations are specified by some other template. 
                  <list role="unordered">
                     <item>Example: The template for this observation is a particular CBC template.</item>
                  </list>
                  </item>

                  <item>A template can designate that the constraints for a class and its attributes and associations are specified by some group of templates.
                  <list role="unordered">
                     <item>Example: The template for this observation is any laboratory Template.</item>
                  </list>
                  </item>
               </list>
            </div3>
         </div2>
      </div1>

      <div1 id="TemplateConceptsAndIssues">
         <head>Template Concepts &amp; Issues</head>

         <p>This section discusses a number of important background concepts that are required to understand how to use templates.</p>

         <div2 id="TemplatesAreOptional">
            <head>Templates are Optional</head>

            <p>Templates are provided to support application design and functionality by documenting exactly how particular concepts 
            are to be represented in a V3 instance. Layers of templates can be used to tightly constrain messages, amongst all the
            possible ways those messages could have been populated. It is not necessary to invoke a template in an instance in order
            to conform to the representation described in the template. Templates may be invoked in an instance by specifying the
            template id as a reference, in order to support machine based validation, and to assist applications when processing the
            instance.</p>  
            
            <p>However individual templates may not be available to all applications, and HL7 V3 does not require that they are
            made available. For this reason, the invocation of a template in an instance can never be used to imply meaning that is
            not otherwise carried in the instance. A template may constrain the instance but the resulting instance must be able to be
			understood without access or consultation with any applied templates, and should not look any different if the templates
			were not referenced in the instance. It must always be possible to interpret the data correctly even when a template is
            unknown. Some implications of this are further discussed in the section <loc href="#ExternalMeaning" xlink-form="simple"
            actuate="auto" show="embed">External Meaning</loc>.</p>
			
			<p>For this reason, application designers should be wary of processing data based on the presence or absence of 
			template references. Generally, it is safe for applications to perform template reference dependent processing,
			but application designers should be careful to ensure that data is processed correctly when templates are not present.
			By agreement, applications may agree that some templates are mandatory under some set of clearly 
			defined circumstances. In these cases, applications may rely on the presence of particular templates 
			to assist with processing the instances, for instance to improve the overall speed of processing.
            Such agreements may be made by site or realm-specific agreement, or HL7 may publish specific profiles
            requiring the use of specific templates. In all cases, these profiles must be consistent
            with the rules established in the applicable interoperability paradigm. Where applications depend 
            on templates to be present, this requirement must be made clear in any conformance statements.
            </p>
         </div2>

         <div2 id="RelationshipBetweenProfilesAndTemplates">
            <head>Relationship between Profiles and Templates</head>

            <p>The definition of interoperability paradigms establishes the relationship between templates and profiles – both specify static models, and used as applied models, but profiles are controlled by the interoperability paradigm, and may make rules about the presence or absence of templates according to the rules specified in the interoperability paradigm. </p>

            <p>Profiles and Templates are closely related. Profiles are documented in the <loc href="http://www.hl7.org/v3ballot/html/infrastructure/conformance/conformance.htm" xlink-form="simple" actuate="auto" show="embed">Refinement, Constraint and Localization Specification</loc>. A profile may be considered as a template that documents implementation specific knowledge starting from the entry point of the instance.</p>

A profile is a set of information used to document system requirements or capabilities from an information exchange perspective. The documentation is expressed in terms of constraints, extensions, or other alterations to a referenced standard or another profile. 

Profiles of the HL7 Version 3 standard must be derived, directly or indirectly, from a Version 3 specification, as balloted either by HL7 or by one of its affiliates. 


			</div2>

         <div2 id="WhenToUseTemplateId">
            <head>When to Use templateId</head>

            <p>One or more templates may be applied using the templateId property on any RIM class. In many circumstances it is optional for the instance to reference a template when it has been used in the construction of the instance, or the application constructing the instance somehow otherwise knows that the template applies. When the application is allowed to choose, the following considerations are relevant to assist in this choice:</p>

            <list role="unordered">
               <item>The relevant definitions (profiles, interoperability paradigms etc) may not clearly establish that a particular template applies at a particular point.</item>

               <item>When it is not known that a template applies, validation and template specific processing cannot be performed.</item>

               <item>Referencing the templateId will make the instance larger</item>
            </list>
         </div2>

         <div2 id="ExpressedImpliedAndAppliedModels">
            <head>Expressed, Implied and Applied Models</head>

            <p>HL7 V3 instances generally conform to many models simultaneously. The models fall into one of three categories:</p>

            <p>
            <emph role="strong">Expressed Models</emph>

            are represented directly in the XML. The names of this model’s classes and associations are found in the instance, and it is explicitly obvious which model artifacts are being invoked. Typically the expressed model is a message type in the XML ITS, but it could also be the CDA RMIM. If the instance was serialized at the RIM level - the RIM class and association names are in the instance - the RIM would be the expressed model. At this time, in the XML ITS, an instance has one and only one expressed model.</p>

            <p>
            <emph role="strong">Implied Models</emph>

            are implied by the derivations contained in the definition of the expressed model. CIMs do not derive directly from the RIM, so there will be a series of implied models for any instance where the expressed model is a CIM. The final implied model in the sequence will be the RIM itself. Since all CIMS are ultimately derived from the RIM, the RIM is always an implied model. </p>

            <p>
				Implementation Note: 
            </p>
            <p>
				A processor can correlate the instance data against an implied model by reading the full static model for the expressed model
				and tracing the derivations from the expressed model to the implied model of choice. This can also be done by the developer
				by hard coding the derivations in the application. HL7 XML ITS schemas also provide a partial link to the RIM level definition.
				The implied RIM model is of such consequence that a separate pattern for identifying the RIM classes in the instance exists,
				using structural codes.
            </p>

            <p>
            <emph role="strong">Applied Models</emph>

            are LIMs to which the instance conforms but which are neither expressed or implied. There is a number of ways to apply a model: 
            <list role="unordered">
               <item>by invoking it explicitly in templateId</item>

               <item>by a profile, template or other external model</item>

               <item>by some conditional rule that associates the application of a model to some feature of the instance (usually a coded value)</item>
            </list>
            </p>

            <p>Templates are applied models. For example: 
<pre>
    &lt;observation&gt;
      &lt;templateId root="2.16.840.1.113883.10" extension=" REPC_RM000103"/&gt;
      &lt;code codeSystem="2.16.840.1.113883.2.6.15.1" code="Barthel-index"/&gt;
      &lt;derivationExpr&gt;Sumscore&lt;/derivationExpr&gt;
      &lt;effectiveTime value="200601191211"/&gt;
      &lt;value value="3" /&gt;
      &lt;component&gt;
        &lt;observation&gt;
          &lt;code codeSystem="2.16.840.1.113883.2.6.15.1.0" code="BrtlB525"/&gt;
          &lt;value value="1"/&gt;
        &lt;/observation&gt;
      &lt;/component&gt;
      &lt;component&gt;
        &lt;observation&gt;
          &lt;code codeSystem="2.16.840.1.113883.2.6.15.1.0" code="BrtlB6202"/&gt;
          &lt;value value="1"/&gt;
        &lt;/observation&gt;
      &lt;/component&gt;
      &lt;component&gt;
        &lt;observation&gt;
          &lt;code codeSystem="2.16.840.1.113883.2.6.15.1.0" code="BrtlD520"/&gt;
          &lt;value value="1"/&gt;
        &lt;/observation&gt;
      &lt;/componen&gt;
    &lt;/observation&gt;
                    
</pre>
            </p>

            <p>In this model, the Example CIM is the expressed model. The clone classes Observation and Component are found directly in the instance.</p>

            <p>
				The RIM is an implied model. In order to know that “component” is an Act-Relationship with typeCode=”COMP”, a processing application
				must consult the derivations in the static model definition. (This is a relatively trivial instance and human users are able to make
				this connection instantly. In bigger models, it becomes harder for humans. The Example CIM is presumably derived from the clinical
				statement pattern itself, so the clinical statement DIM is also an implied model, and the only way to link from the instance to the
				clinical statement pattern would be to consult the full static model definition for the Example CIM which includes these derivations).</p>

            <p>The Barthel Index is an applied model and hence a template. It is explicitly referenced in the instance using the templateId, and the instance conforms to its constraints. But the identification of the elements in the wire format is not carried directly, so it’s not made explicit which Observation matches to which component in the template (ContinenceOfBowels, ControllingBladder, or PersonalToilet). If this identification is important, it may be inferred by a variety of methods, and this is discussed further below.</p>
         </div2>

         <div2 id="Incompleteness">
            <head>Incompleteness</head>
            <p>
				Templates very often represent partial constraints – they express a set of rules about 
				content that only consider some aspects of the content, perhaps from a particular perspective.
				For instance, a template may require that a particular observation has at least several 
				parts, a set of particular details and a summary, while not making any other rules about 
				what other elements may or may not exist, such as authors, and other components of the 
				observation, since it is concerned with the inherent structure of the content only, and 
				not with the concepts of how the observation is reported. Another example is that a laboratory 
				may want to define templates that describe the structures it uses for the various clinical 
				reports it publishes. These templates will describe what observation components may be 
				found on the reports, and what structures they have. However the templates do not make 
				any comment on what forms of attestation are included with the reports.
			</p>
			<p>
				When these constraints are described in an HL7 Static Model, the static model is said to
				be incomplete. It must specifically identify that content that is not described in the
				static model may exist. By contrast, a complete static model is where 
				every element that may exist is described, and any elements that are not described must 
				not exist.
			</p>
            <p>
				In general, templates should be as incomplete as possible. The idea is to say as little as possible
				to convey the intent of the template. The more extra things that are constrained in the template,
				the less re-use for the template. 
		    </p>
         </div2>

         <div2 id="Indeterminism">
            <head>Indeterminism</head>
            <p>
				As applied models, templates are not represented explicitly in the instances. In some of the
				uses of templates, the tree of nodes in the instance must be matched to the features defined
				in the template. Since the names of the instance come from the expressed model, not the
				template, they cannot be used to assist in the determination of which nodes in the instance
				match the nodes in the templates, and some other strategy is needed to match the instance to
				the template definition.
			</p>
			<p>
				As the basis for an algorithm to perform the tree matching the constraints expressed in the template
				must be matched to the actual data values found in the instance. Constraints defined in a template
				such as fixed Act.code values or value sets of allowed codes can be used to match nodes of the tree
				in a given instance.
			</p>
            <p>
				The sequence of the associations may appear to be useful too but due to unrolling and other
				considerations, great care must be taken when using the sequence. At best it can only be used
				to increase the performance of the algorithm.
			</p>
			<p>As an example of this, consider the instance fragment from above: 
<pre>
    &lt;observation&gt;
      &lt;templateId root="2.16.840.1.113883.10" extension=" REPC_RM000103"/&gt;
      &lt;code codeSystem="2.16.840.1.113883.2.6.15.1" code="Barthel-index"/&gt;
      &lt;derivationExpr&gt;Sumscore&lt;/derivationExpr&gt;
      &lt;effectiveTime value="200601191211"/&gt;
      &lt;value value="3" /&gt;
      &lt;component&gt;
        &lt;observation&gt;
          &lt;code codeSystem="2.16.840.1.113883.2.6.15.1.0" code="BrtlB525"/&gt;
          &lt;value value="1"/&gt;
        &lt;/observation&gt;
      &lt;/component&gt;
      &lt;component&gt;
        &lt;observation&gt;
          &lt;code codeSystem="2.16.840.1.113883.2.6.15.1.0" code="BrtlB6202"/&gt;
          &lt;value value="1"/&gt;
        &lt;/observation&gt;
      &lt;/component&gt;
      &lt;component&gt;
        &lt;observation&gt;
          &lt;code codeSystem="2.16.840.1.113883.2.6.15.1.0" code="BrtlD520"/&gt;
          &lt;value value="1"/&gt;
        &lt;/observation&gt;
      &lt;/componen&gt;
    &lt;/observation&gt;
                    
</pre>
            </p>
<p>
				The problem of the tree match algorithm is to match the three component observations to
				the three definitions of the component observations in the template. In this case, its
				a reasonably straightforward process, since the different component observations have
				different fixed code values.
			</p>
			<p>
				However this not guaranteed to be the case. The extensive use of terminologies in HL7
				models may make this process a little more difficult. In this template, the fixed codes
				have been replaced by value sets:
			</p>
            <p>
               <graphic source="graphics/example-indeterminism-codeset.png" alt="Example Code Set Use" />
            </p>
            <p>
				In order to perform the tree matching, the processor must check whether the codes in the
				instance are part of the value sets, and the processing becomes more time consuming,
				though the process is still relatively simple, if the value sets do not overlap.
			</p>
			<p>
				If however, the value sets overlap, it is no longer possible to tell which observation is
				which in the template, and the template is indeterminate: it is not computationally
				definite which model data element a given instance data element conforms to.
			</p>
			<p>
				This could happen if the following codes were in the relevant value sets: 
				<table>
					<tr>
						<td>x_Barthel_1</td>
						<td>BrtlB525 BrtlB6202</td>
					</tr>
					<tr>
						<td>x_Barthel_2</td>
						<td>BrtlB6202 BrtlD520</td>
					</tr>
					<tr>
						<td>x_Barthel_3</td>
						<td>BrtlD520 BrtlB525</td>
					</tr>
				</table>
			</p>
			<p>
				HL7 templates are not guaranteed to be determinate. However, at the clinical level, it’s
				nonsensical to have overlapping code sets for the Barthel index, and so, while there is
				no rule meaning that the templates are not indeterminate, the presence of indeterminism
				would generally indicate a poor representation of content or poor modeling practice.
			</p>
            <p>
				Poor modeling practice can lead to indeterminate templates by injudicious use of optionality
				and choices to try and represent co-occurrence constraints. An example would be this model,
				which is a variation of the example template:
			</p>
			<p>
               <graphic source="graphics/example-indeterminism-choicebox.png" alt="Example Choice Box Constraints" />
            </p>
            <p>
				The intent of this model is to express the idea that the Controlling Bladder may include either a
				method code, or an effective time, but not both. Given the instance above, it’s not possible to
				determine whether the first component observation is a ControllingBladder or a ControlingBladder2
				in this template.
			</p>
            <p>
				For validation, it mostly doesn’t matter: if the first component is either a ControllingBladder or
				a ControllingBladder2, it is valid, and as long as the instance conforms to one of the choices,
				the instance is valid. However it is possible to construct more complicated models where the
				combinations of indeterminate features lead to indeterminate validation outcomes.
			</p>
			<p>
				For interpretation of the data, it should not matter whether the instance component observation is
				either a ControllingBladder or a ControlingBladder2. In this contrived example, it won’t. However
				in general with templates it can be very subtle whether the distinction matters or not, and it may
				depend on the nature of the assumptions made when the template is interpreted.
			</p>
            <p>
				Within the context of the existing HL7 Static Model design process, it’s not possible to prevent
				indeterminism in HL7 template design, but following the template design best practices below will
				ensure that templates will never have ambiguous meaning, and that validation will work.
			</p>
         </div2>

         <div2 id="ExternalMeaning">
            <head>External Meaning</head>

            <p>It’s possible to design a template where the names of the clone classes in the template have meaning themselves, and are not supported by appropriate codes and values in the instance. This template falls into this category:</p>

            <graphic source="graphics/external meaning.barthel index.png" alt="External Meaning" />

            <p>Making the codes optional in this fashion may make the template become indeterminate, but more importantly, it is dangerous. Given this instance:</p>

<pre>
    &lt;observation&gt;
      &lt;templateId root="2.16.840.1.113883.10" extension=" REPC_RM000103"/&gt;
      &lt;code codeSystem="2.16.840.1.113883.2.6.15.1" code="Barthel-index"/&gt;
      &lt;derivationExpr&gt;Sumscore&lt;/derivationExpr&gt;
      &lt;effectiveTime value="200601191211"/&gt;
      &lt;value value="3" /&gt;
      &lt;component&gt;
        &lt;observation&gt;
          &lt;value value="1"/&gt;
        &lt;/observation&gt;
      &lt;/component&gt;
      &lt;component&gt;
        &lt;observation&gt;
          &lt;value value="1"/&gt;
        &lt;/observation&gt;
      &lt;/component&gt;
      &lt;component&gt;
        &lt;observation&gt;
          &lt;value value="1"/&gt;
        &lt;/observation&gt;
      &lt;/componen&gt;
    &lt;/observation&gt;
    
</pre>

            <p>A template parser may use association sequence information to match the 3 component observations against the 3 components in the template definition without noting the implicit indeterminism, and consequently an application might wrongly infer meaning to the 3 different values. As discussed in section 
            <loc href="#TemplatesAreOptional" xlink-form="simple" actuate="auto" show="embed">Templates are optional</loc>, it must always be possible to interpret the instance correctly even when the template is unknown. In this case, there are no grounds for interpreting the data correctly without access to the template, and since the template is indeterminate, there is no real grounds for interpreting the data correctly.</p>

            <p>The exact definition of the meaning of “interpreting the data correctly” is rather difficult to pin down. In this case, it is possible to understand the data to some very minimal degree, and the template provides for further meaning. In the general case, whether a template provides enough extra information in the meaning of the names can be very difficult to determine, as it very much depends on the interpretation by the template by the user.</p>

            <p>For this reason, the simplest rules to prevent misinterpretation of the data are:
            <list role="unordered">
               <item>the template should not be indeterminate</item>

               <item>
				the names of the CloneClasses in the template should have no meaning that is not made explicit in the structural
				codes and other attribute constraints for the class and its contextual associations. (Test this by attempting
				to interpret your model pretending that all class names have been changed to "Foo" and see if the constraints
				are sufficient to have the correct interpretation.)
			   </item>

               <item>Template parsers should never use sequence to do tree matching</item>
            </list>

            This theme is taken up in 
            <loc href="#BestPracticeForTemplateDesign" xlink-form="simple" actuate="auto" show="embed">template best practices</loc>

            and 
            <loc href="#Conformance" xlink-form="simple" actuate="auto" show="embed">conformance</loc>

            .</p>

            <p>Templates can be used to provide “adornment” information. This information might be used to assist an application to choose how to display a particular observation, for instance. If the application does not identify a template, it may not display the information in the expected style, and a user might misinterpret the data. While no hard and fast rules can be made in this regard, implementers need to be very cautious that their applications do not violate the intent of the ruling that data should be interpreted correctly without knowledge of the template.</p>

            <p>A consequence of these rules is that templates can only be used for the backbone classes. In particular, it’s not possible to define templates for the query by parameter classes, as there is no structural codes to prevent indeterminism.</p>
         </div2>

         <div2 id="ContextConduction">
            <head>Context Conduction</head>

            <p>
			   Context Conduction is an important structural behavior of the RIM. Consult the RIM for further information.
			   Since Templates are applied models, and multiple different templates are applied at different points in
			   the hierarchical model, it can be very difficult to determine in advance what the rules for context
			   conduction will be.
			</p>
            <p>
				Template designers should design templates with the knowledge that the context conduction rules in the
				model from which they have been derived may have been overruled. The best practice for templates is to
				never make any rules about context conduction.
			</p>
			<p>
				Instance processors should be aware that context conduction can only be fully interpreted in the context
				of the instance where a template is applied, it is not a property of the template itself.
			</p>
         </div2>

		 <div2 id="Extension">
			<head>Localization and Extension</head>
			<p>
				There is a close relationship between some forms of localization and templates. Templates are generally the 
				most efficient way to implement localization where the localization is a matter of constraining the 
				universal V3 specifications.
			</p>
			<p>
				Not all requirements for localization can be met by constraining the universal V3 specifications. Circumstances
				arise where the only way to implement localization requirements is by extending the V3 specification. This is 
				allowed by the rules in <loc href="http://www.hl7.org/v3ballot/html/infrastructure/conformance/conformance.htm"
				xlink-form="simple" actuate="auto" show="embed">Refinement, Constraint and Localization Specification</loc>.
			</p>
			<p>
				Templates can be extended in the same way as static models, and can also constrain extended content. For example,
				an implementor can extend a class by adding the attribute myBusinessThing : ST. This must be in some other namespace
				than the HL7 namespace. A template can constrain this attribute by referring to it directly in the template. The
				template must declare than namespace using the extensibilityNamespace attribute of the <loc href="#ttFeature"
				xlink-form="simple" actuate="auto" show="embed">Feature</loc> class. Other than this, it is a standard template
				feature constraint.
			</p>
			<p>
				Note that if a template makes an localised feature like this mandatory, it will not be able to be used outside
				the localization context.
			</p>
		 </div2>
         <div2 id="RealmsAndTemplates">
            <head>Realms and Templates</head>
            <p>
				V3 instances are able to make reference to a binding realm. Binding realms are also able to define their
				own versions of templates, but these need separate identifiers for use in templateId, so the binding
				realm reference does not alter or qualify an applied template.
			</p>
            <p>
				It is possible that an international realm could apply incompatible constraints to those in the template,
				and then no instance could be valid. This might occur if a template restricted a particular attribute to
				a particular set of values (such as LOINC codes), and the realm had imposed a restriction to another
				disjoint subset of values (such as SNOMED codes). This situation is most likely to occur with
				coded values, but only where translations are not allowed because the attribute type has been 
				restricted to CV.
			</p>
         </div2>

         <div2 id="DerivationHierarchyConsiderations">
            <head>Derivation Hierarchy Considerations</head>

            <p>A template may be applied to an instance that is based upon a CIM from which the template is not derived. The most useful application of this is where templates are derived from some general DIM, such as the Clinical Statement Pattern, and then may be applied against any instance.</p>

            <p>Where a template is applied to an instance defined against a model from a different derivation path, the constraints in that template, which reflect all the constraints in its derivation path, are also applied. It may be difficult to understand the implications created by the application of templates in this fashion, and it is very easy to create constraint combinations that cannot be satisfied or to create unexpected constraints, so care is recommended in applying templates against instances where there are derivation paths not shared between the expressed model and the template.</p>
         </div2>

         <div2 id="ShallowAndDeepTemplates">
            <head>Shallow and Deep Templates</head>

            <p>Given that it is possible to compose templates by referencing one template from another, two generally different styles of template use arise. In one use, a single template is used to specify an entire model, and in the other use, a group of templates is used where each template is fairly simple and refers to the templates for the deeper content. These styles are referred to as “deep” and “shallow” templates respectively.</p>

            <p>These styles of usage are not incompatible or absolute, they may be mixed as desired. Each use has advantages.</p>

            <p>Advantages for deep templates:
            <list role="unordered">
               <item>Templates are internally complete, so easier to understand</item>

               <item>Processing is simpler and faster (though this may be implementation dependent)</item>
            </list>
            </p>

            <p>Advantages for shallow templates:
            <list role="unordered">
               <item>Allows for more re-use of modular concepts in the design and the instance.</item>
            </list>
            </p>

            <p>If every template was shallow – only 1 level, many templates would be required to express any useful concept. If every template is deep, reuse of templates becomes extremely difficult. Most templates will reflect a combination of deep and shallow design patterns.</p>

            <p>Example - The template in the common example can be considered to be a deep template: 
            <graphic source="graphics/example-barthel.png" alt="Example Deep Template" />
            </p>

            <p>A shallow variation would be to use CMET references to refer to other templates: 
            <graphic source="graphics/example-barthel-shallow.png" alt="Example Shallow Templates" />
            </p>

            <p>In this somewhat trivial example, the definitions of the component Acts have been moved to other templates, which are invoked using CMET style references, which is a shallow design style.</p>

            <p>The concept of shallow and deep templates is a design style; it is not a useful way to classify templates.</p>
         </div2>
      </div1>


      <div1 id="Registries">
        <head>Registries</head>
		 <p>
		   Registries are an important part of using templates. For most uses of templates, they will be 
		   published in a registry so that any user can find and retrieve the template. It is not mandatory
		   that a template be published in a registry. Registries are allowed to enforce additional conformance
		   requirements and are encouraged to publish their requirements in a human or computer readable form.
		 </p>
		 <p>
			The definition of the word registry in this specification is taken from the ebXML Registry 
			specification, where it includes not only registration of the information describing the entity,
			but the entity itself (though this is not a clear distinction). In other specifications these
			functions may be divided between registries and repositories. In this specification, the words
			"registry" and "repository" are used interchangeably.
		 </p>
		 <p>
			This specification does not provide normative implementable specifications for template registries.
			Instead this section may be taken as a general functional specification for the kind of operations
			that a template registry should provide. Such services may be offered on one or more different channels,
			such as the ebXML registry specification, web services, or a simple HTTP interface. Which ever channel
			and technology a registry is implemented on, the registry will generally need to provide these
			functions in some form or other.
		</p>
		<p>
			While template registries may opt to accept templates that are not production-ready, registries are
			not required to support such templates. Registries are expected to ensure that templates marked
			as production-ready are actually valid templates. Note that The HL7 SOA SIG is investigating the
			concept of developing a detailed template registry service specification.			
		</p>
         <p>
            <table>
               <tr>
                  <td>Operation</td>
                  <td>In Parameters</td>
                  <td>Out Parameters</td>
                  <td>Comments</td>
               </tr>

               <tr>
                  <td>Describe Metadata</td>
                  <td></td>
                  <td>List of Metadata items</td>
                  <td>A list of template metadata items indicating for each item its type, and whether it is supported, mandatory, and/or searchable.
				  Extended metadata (items not defined in this specification) might be included, but would need to be clearly identified</td>
               </tr>

               <tr>
                  <td>AllocateTemplateId</td>
                  <td>User Identification to allow audit</td>
                  <td>TemplateId</td>
                  <td>The registry assigns the templateId. Allocated Id’s are never reused.</td>
               </tr>

               <tr>
                  <td>CreateTemplate</td>
                  <td>Template Package</td>
                  <td>Error or Ok</td>
                  <td>Error if 
                  <list role="unordered">
                     <item>metadata is malformed or incomplete</item>
                     <item>template fails validation</item>
                     <item>template has already been created for this Id</item>
                     <item>etc</item>
                  </list>
                  </td>
               </tr>

               <tr>
                  <td>UpdateTemplate</td>
                  <td>Template Package</td>
                  <td>Error or Ok</td>
                  <td>Error if 
                  <list role="unordered">
                     <item>metadata is malformed or incomplete</item>
                     <item>or template fails validation</item>
                     <item>template does not exist</item>
                     <item>user doesn’t have permission</item>
                     <item>etc</item>
                  </list>
                  </td>
               </tr>

               <tr>
                  <td>RemoveTemplate</td>
                  <td>templateId</td>
                  <td>Error or Ok</td>
                  <td>Error if 
                  <list role="unordered">
                     <item>template does not exist</item>
                     <item>user doesn’t have permission</item>
                     <item>etc</item>
                  </list>
                  </td>
               </tr>

               <tr>
                  <td>SearchForTemplate</td>
                  <td>Template metadata filter</td>
                  <td>A list of template metadata for metadata that matches</td>
                  <td>-</td>
               </tr>

               <tr>
                  <td>RetrieveTemplate</td>
                  <td>templateId</td>
                  <td>Template Package</td>
                  <td>Error if 
                  <list role="unordered">
                     <item>template does not exist</item>
                     <item>user doesn’t have permission</item>
                     <item>etc</item>
                  </list>
                  </td>
               </tr>
            </table>
         </p>

        <p>
			A Template Package consists of a template as described by this specification, 
			with the additional metadata defined by the registry itself.
		</p>
        <p>
			Note that NIST is sponsoring an HL7 template registry. For further
			details please contact NIST (<loc href="http://www.nist.gov" xlink-form="simple" actuate="auto" show="embed">http://www.nist.gov</loc>).
		</p>

		 </div1>

      <div1 id="BestPracticeForTemplateDesign">
         <head>Best Practice for Template Design</head>

         <list role="unordered">
            <item>Templates should represent the constraints using an HL7 static model</item>
            
            <item>Templates should always specify appropriate coded values to indicate meaning rather than using the name of the clone class</item>

            <item>Templates should be deterministic – there should always be mandatory attributes with appropriately constrained values to properly differentiate between classes involved in associations and choices</item>

            <item>Templates should not constrain the conduction and separation attributes, nor set updateMode values. It can be done, but again, it’s about re-use. The less you say about this difficult and significant subject, the more re-use of the templates is possible – less likely to create problems with context conduction rules in the expressed models</item>

            <item>Templates should use expression languages for co-occurrence constraints rather than creating choice boxes</item>

            <item>Template Metadata should be carefully populated</item>

            <item>Templates should be registered in the global NIST artifacts registry</item>
         </list>
      </div1>

      <div1 id="ImplementationConsiderations">
         <head>Implementation Considerations</head>

         <div2 id="mif">
            <head>Static Model</head>
            <p>
				This specification defines a static model based representation of a template.
				HL7 templates need not include a representation in this form, though they are
				strongly encouraged to do so, as it provides the best support for reuse across
				all HL7 implementation contexts. 
			</p>
            <p>
				Validation applications may use the static model definition directly as a source when
				validating templates, if it is provided. Other formats such as XMI, OCL
				and schematron may be used to perform validation. The validation from any of 
				the formats may sometimes be incomplete, as not all contraints can be porperly
				represented in any particular representation.
			</p>
         </div2>
         <div2 id="Schematron">
            <head>Schematron</head>
            <p>
				Schematron is a very useful form for an implementation specific representation of 
				the template constraints, and there is support for template validation using off
				the shelf tools, though additional infrastructure may be required to support terminology
				validation.
			</p>
         </div2>
      </div1>

      <div1 id="OpenIssues">
         <head>Open Issues</head>
         <div2 id="MethodologyEnhancements">
            <head>Other Methodology Enhancements</head>
            <p>
				In order to fully represent templates as Static Models, various enhancements to the Static Model methodology are still
				required. In particular, the following features have been identified:</p>
				<list role="unordered">
					<item>Model typing functionality in order to fully support template composition (some categorization
					      mechanism for templates in order to specify that one of a group of templates must be used somewhere)</item>
					<item>What’s the relationship between a template CMET reference and constraint on templateId? (This will only be fully relevant once incomplete templates are allowed</item>
				</list>
            <p>These enhancements a current work items shared between MnM, Tooling, and the Templates SIG.</p>
            <p>In general, HL7 recognises the need for tooling that enables the full implementation of the
			features described in the HDF, as well as the features described in this specification, in the 
			Use of OCL as a constraint language in RIM Derived Models specification, and incomplete templates
			before HL7 templates will be truly useful.</p>
         </div2>
         <div2 id="FutureWork">
            <head>Future Work</head>
			<p>Issues deferred to a future version of this specification:</p>
            <list role="unordered">
               <item>A process for describing certification of templates is required</item>
            </list>
         </div2>
      </div1>

      <div1 id="TemplateDevelopmentFramework">
         <head>Appendix A: Template Development Framework</head>

         <p>This section presents a series of scenarios that walk through the entire process of template inception to template creation to template validation. The various scenarios are presented to help put the HL7 V3 Template standard into perspective.</p>

         <div2 id="TemplateAnalysis">
            <head>Template Analysis</head>

            <p>Any organization or individual can create a template to meet business needs, enhance evidence-based medical practice, encode a clinical practice guideline, support a defined administrative process etc.</p>

            <p>
            	The initial template analysis and statement of requirements generally results in a
				structured expression of the template using the vocabulary and nomenclature of the
				users who are expressing the need for the particular Template instance. This may be
				done independently of any standard, though a variety of standards, including HL7 V3 itself,
				may be used to assist this process by defining shared language and recognised requirements.
				This structured expression can exist in a variety of representations, though usually it will
				be some form of general document. Regardless of the specifics of the expression,
				however, one should note that there is an emphasis on gaining domain expert consensus as to
				structure and content. Such consensus is obtained through the generation of one or more
				analysis artifacts including process flow diagrams, data/concept static diagrams, and a
				carefully written and complete glossary that defines all the terms required by the
				Template (see the HDF discussion for further details, approaches, and examples). There
				will typically be several software tools to facilitate template analysis, with a variety
				of user-interface designs. These user-friendly artifacts enable review by domain experts.
				Figures 1 and 2 show sample results of the analysis phase used to create a CBC template
				and a template governing the components of a comprehensive review document. Figure 3
				shows a more extensive analysis, based upon the review of a national clinical practice
				guideline, resulting in an abstract data entry template.
			</p>

            <p>Figure 1. Abstract statement of a CBC template.</p>

            <p>When reporting the results of a CBC, the following observations shall be present: 
            <list role="unordered">
               <item>Hemoglobin (required, cannot repeat)</item>

               <item>Hematocrit (optional, cannot repeat)</item>

               <item>Platelet count (required, cannot repeat)</item>
            </list>
            </p>

            <p>Figure 2. Abstract statement of a document template that indicates the components in a “comprehensive review” document.</p>

            <p>A Comprehensive Review document contains the follow components: 
            <list role="unordered">
               <item>"objective" section (required, cannot repeat) 
               <list role="unordered">
                  <item>The "objective" section contains a "physical-exam" section (required, cannot repeat) 
                  <list role="unordered">
                     <item>The "physical-exam" section contains a "vital-signs" section (required, cannot repeat)</item>
                  </list>
                  </item>

                  <item>The "objective" section contains a "lab" section (optional, cannot repeat) 
                  <list role="unordered">
                     <item>The "lab" section contains a CBC observation, where the CBC is based on the template shown in Figure 1.</item>
                  </list>
                  </item>
               </list>
               </item>
            </list>
            </p>

            <p>Figure 3. Data entry template produced upon review of a national clinical practice guideline 
            <graphic source="graphics/template-analysis-entry.png" alt="Entry Template" />
            </p>
         </div2>

         <div2 id="TemplateDesign">
            <head>Template Design</head>

            <p>The artefacts of template analysis need to be transformed into Static Models. The specifics of the transformation process depend on the rigor by which the initial analysis process was performed. Often times, a technical expert is needed to map the clinical or domain analysis model into the normative form. During the mapping, it may be necessary to further clarify vocabulary, cardinality, and other requirements. There is also the potential that analysis-level templates address semantics not covered by an existing HL7 standard. For instance, it wouldn’t be possible to convert a CBC analysis-level template into a design-level template if there weren’t an HL7 standard for transmission of clinical observations with the required attributes. (See the HDF discussion on ‘Normalization/Harmonization’ for further details of this process).</p>

            <p>The end result of template design is a template as defined in <loc href="formalDefinition" xlink-form="simple" actuate="auto" show="embed">the Formal Definition</loc>.</p>
         </div2>

         <div2 id="TemplateValidation">
            <head>Template Validation</head>

            <p>A template is a constraint on some portion of a Static Model. Template metadata declares the scope of the constrained fragment. The template should be a valid and consistent constraint on top of the constraints expressed in the Static Model from which it is derived, but this is not strictly necessary (this is discussed in the section <loc href="#ConceptsAndIssues" xlink-form="simple" actuate="auto" show="embed">Template Concepts &amp; Issues</loc>).</p>

            <p>While there are some validations that template editing and checking tools can perform, full validation that the template is a valid constraint may not be possible.</p>

            <p>What checking can be performed may be performed as part of the template authoring or registration process, or may be performed be a receiver upon receipt of a template.</p>
         </div2>

         <div2 id="TemplateRegistration">
            <head>Template Registration</head>

            <p>Templates can be registered in a suitable template registry, such as the NIST HL7 template registry. The submission process will require authentication of the submitter. The registry will have rules governing which existing templates a submitter can revise. Typically, a submitter can add new templates, and can revise templates they (or their organization) have submitted, but cannot edit templates submitted by other entities. Registries maintain persistent copies of revised artifacts, and assign unique identifiers to all artifacts, including new revisions of existing templates.</p>
         </div2>

         <div2 id="FindingARegisteredTemplate">
            <head>Finding a Registered Template</head>

            <p>A template registry can potentially hold tens of thousands of templates and will typically index much of the template metadata.</p>

            <p>Users can search a template registry using any of the available metadata fields. Registries may differ in the search sophistication provided and in the metadata exposed to the search engine.</p>
         </div2>

         <div2 id="CreateInstance">
            <head>Create an Instance that Conforms to a Template</head>

            <p>There are a number of mechanisms by which users create valid HL7 instances (messages and/or documents). Mapped data can be pulled from an internal database, a local document can be transformed into a CDA-conformant document, etc. A constraining template can be used to guide data entry. For instance, Figure 2 shows those components that are required for a comprehensive review document. This template can be used to validate that a CDA document conforms to the additional constraints expressed in the template, and can also be used to guide data entry, ensuring that required document sections are included.</p>

            <p>An HL7 instance can carry information showing which templates it conforms to.</p>
         </div2>

         <div2 id="ValidateInstance">
            <head>Validate an Instance Against a Template</head>

            <p>Using an appropriate tool, an instance can be validated against any templates applied to the instance. (Refer for further discussion to the section <loc href="#ImplementationConsiderations" xlink-form="simple" actuate="auto" show="embed">Implementation Considerations</loc>.)</p>
         </div2>

         <div2 id="NormativeStatus">
            <head>Advance a Template to Normative Status</head>

            <p>In a registry of tens of thousands of templates, some of which may overlap, it can be challenging for a user to know which template to select. There may, for instance, be an echocardiography template submitted by LOINC, by the American College of Cardiology, and by DICOM. Ideally, these groups would converge over time and generate either a hierarchy of echocardiography templates that contain progressively more and more constraints and/or they would work together to produce a single echocardiography template.</p>

            <p>Templates in the registry may be approved by a number of professional societies. In addition, templates in the registry can themselves go through the HL7 ballot process, yielding templates that have an HL7 Informative or an HL7 Normative status.</p>
         </div2>
      </div1>
      <div1 id="TemplateMIFMapping">
         <head>Appendix B: Template Metadata MIF Mapping</head>
         <p>
			Based on MIF 2.0.
		 </p>
         <table>
            <tr>
               <td>Property Name</td>
               <td>MIF Mapping</td>
            </tr>

            <tr>
               <td>Identification</td>
               <td></td>
            </tr>

            <tr>
               <td>TemplateId</td>
               <td>OID as defined by HL7. extension is the model id as defined in the HDF</td>
            </tr>

            <tr>
               <td>templateName</td>
               <td>business name of the model</td>
            </tr>

            <tr>
               <td>originatingAuthorEntityID</td>
               <td>header.responsibleGroup.groupId</td>
            </tr>

            <tr>
               <td>templateIntention</td>
               <td>UsageNotes on the model</td>
            </tr>

            <tr>
               <td>templateVersion</td>
               <td>part of the model identifier</td>
            </tr>

            <tr>
               <td>templateDerivedModelID</td>
               <td>derivation reference</td>
            </tr>

            <tr>
               <td>templateReferenceModelID</td>
               <td>derivation reference</td>
            </tr>

            <tr>
               <td>templateRepositoryIdentifier</td>
               <td>header.primaryRepository</td>
            </tr>

            <tr>
               <td>Description</td>
               <td></td>
            </tr>

            <tr>
               <td>descriptionLanguage</td>
               <td>description.text.language</td>
            </tr>

            <tr>
               <td>templateDescription</td>
              <td>description annotation on the model</td>
            </tr>

            <tr>
               <td>templateFormat</td>
               <td>no equivalent</td>
            </tr>

            <tr>
               <td>evidenceSource</td>
               <td>requirements annotation on model</td>
            </tr>

            <tr>
               <td>detailedDescription</td>
               <td>use model annotations as appropriate</td>
            </tr>

            <tr>
               <td>cautionPoints</td>
               <td>usage Notes on model</td>
            </tr>

            <tr>
               <td>Publication</td>
               <td></td>
            </tr>

            <tr>
               <td>publicationStatus</td>
               <td>maps to approvalInfo.approvalStatus</td>
            </tr>

            <tr>
               <td>publicationStatusChangeDate</td>
               <td>approvalInfo.approvalDate</td>
            </tr>

            <tr>
               <td>publisher</td>
               <td>header.responsibleGroup</td>
            </tr>

            <tr>
               <td>publishingAuthority</td>
               <td>header.reviewingAuthority</td>
            </tr>

            <tr>
               <td>revisionHistory</td>
               <td>everything has a revision history; this would have to built on the fly</td>
            </tr>

            <tr>
               <td>effectiveDate</td>
               <td>approvalInfo.approvalDate</td>
            </tr>

            <tr>
               <td>supersedingTemplate</td>
               <td>TBD</td>
            </tr>
         </table>
      </div1>
      <div1 id="schema">
         <head>Appendix C: Template Schema</head>
         <p>
			This schema describes the XML representation of the UML model for templates
			described in <loc href="#model" xlink-form="simple" actuate="auto" show="embed">Template Format</loc>
		 </p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsd:schema xmlns="uri:hl7.org::template" targetNamespace="uri:hl7.org::template" elementFormDefault="qualified" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:sch="http://www.ascc.net/xml/schematron"&gt;
  &lt;xsd:complexType name="Artefact"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="constraint" type="Constraint" minOccurs="0" maxOccurs="unbounded" /&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="name" type="xsd:string" use="required" /&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="Constraint"&gt;
    &lt;xsd:attribute name="name" type="xsd:string" use="optional" /&gt;
    &lt;xsd:attribute name="source" type="xsd:string" use="required" /&gt;
    &lt;xsd:attribute name="language" type="ConstraintLanguage" use="required" /&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:simpleType name="ConstraintLanguage"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="OCL" /&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;
  &lt;xsd:complexType name="ClassArtefact"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="Artefact"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="feature" type="Feature" minOccurs="0" maxOccurs="unbounded" /&gt;
        &lt;/xsd:sequence&gt;
        &lt;xsd:attribute name="sourceModel" type="xsd:string" use="required" /&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="Feature"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="Artefact"&gt;
        &lt;xsd:attribute name="conformance" type="Conformance" use="required" /&gt;
        &lt;xsd:attribute name="mandatory" type="xsd:boolean" use="required" /&gt;
        &lt;xsd:attribute name="min" type="xsd:int" use="required" /&gt;
        &lt;xsd:attribute name="max" type="xsd:int" use="required" /&gt;
        &lt;xsd:attribute name="updateModes" type="set_UpdateMode" use="optional" /&gt;
        &lt;xsd:attribute name="extensibilityNamespace" type="xsd:string" use="optional" /&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:simpleType name="Conformance"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="A" /&gt;
      &lt;xsd:enumeration value="R" /&gt;
      &lt;xsd:enumeration value="NP" /&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;
  &lt;xsd:simpleType name="UpdateMode"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="A" /&gt;
      &lt;xsd:enumeration value="D" /&gt;
      &lt;xsd:enumeration value="R" /&gt;
      &lt;xsd:enumeration value="AR" /&gt;
      &lt;xsd:enumeration value="N" /&gt;
      &lt;xsd:enumeration value="U" /&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;
  &lt;xsd:simpleType name="set_UpdateMode"&gt;
    &lt;xsd:list itemType="UpdateMode" /&gt;
  &lt;/xsd:simpleType&gt;
  &lt;xsd:complexType name="Attribute"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="Feature"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="possibleValue" type="xsd:string" minOccurs="0" maxOccurs="unbounded" /&gt;
          &lt;xsd:element name="vocabulary" type="VocabularyConstraints" minOccurs="0" maxOccurs="1" /&gt;
        &lt;/xsd:sequence&gt;
        &lt;xsd:attribute name="datatype" type="xsd:string" use="required" /&gt;
        &lt;xsd:attribute name="flavor" type="xsd:string" use="optional" /&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="VocabularyConstraints"&gt;
    &lt;xsd:attribute name="extensions" type="xsd:boolean" use="required" /&gt;
    &lt;xsd:attribute name="domain" type="xsd:string" use="optional" /&gt;
    &lt;xsd:attribute name="valueSet" type="xsd:string" use="optional" /&gt;
    &lt;xsd:attribute name="code" type="xsd:string" use="optional" /&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="Association"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="Feature"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element name="targetReference" type="XReference" /&gt;
            &lt;xsd:element name="target" type="ConstrainedClass" /&gt;
          &lt;/xsd:choice&gt;
        &lt;/xsd:sequence&gt;
        &lt;xsd:attribute name="rimName" type="xsd:string" use="required" /&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="ConstrainedClass"&gt;
    &lt;xsd:annotation&gt;
      &lt;xsd:appinfo&gt;
        &lt;sch:pattern name="abstract"&gt;
          &lt;sch:rule abstract="true" id="ConstrainedClass-0"&gt;
            &lt;sch:assert test="(@abstract=&#34;true&#34;) or not choices" /&gt;
          &lt;/sch:rule&gt;
        &lt;/sch:pattern&gt;
      &lt;/xsd:appinfo&gt;
    &lt;/xsd:annotation&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="ClassArtefact"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="derives" type="XReference" /&gt;
          &lt;xsd:element name="choice" type="ConstrainedClass" minOccurs="0" maxOccurs="unbounded" /&gt;
        &lt;/xsd:sequence&gt;
        &lt;xsd:attribute name="abstract" type="xsd:boolean" use="required" /&gt;
        &lt;xsd:attribute name="id" type="xsd:ID" use="optional" /&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="RimClass"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="ClassArtefact"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="super" type="XReference" minOccurs="0" maxOccurs="1" /&gt;
        &lt;/xsd:sequence&gt;
        &lt;xsd:attribute name="category" type="RimClassCategory" use="required" /&gt;
        &lt;xsd:attribute name="id" type="xsd:ID" use="optional" /&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:simpleType name="RimClassCategory"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="ENTITY" /&gt;
      &lt;xsd:enumeration value="ROLE" /&gt;
      &lt;xsd:enumeration value="ROLE_LINK" /&gt;
      &lt;xsd:enumeration value="PARTICIPATION" /&gt;
      &lt;xsd:enumeration value="ACT_RELATIONSHIP" /&gt;
      &lt;xsd:enumeration value="ACT" /&gt;
      &lt;xsd:enumeration value="DOCUMENT" /&gt;
      &lt;xsd:enumeration value="INFRASTRUCTURE" /&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;
  &lt;xsd:complexType name="XReference"&gt;
    &lt;xsd:attribute name="xref" type="xsd:IDREF" use="required" /&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="RIM"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="class" type="RimClass" minOccurs="0" maxOccurs="unbounded" /&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="version" type="xsd:string" use="required" /&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="Template"&gt;
    &lt;xsd:annotation&gt;
      &lt;xsd:appinfo&gt;
        &lt;sch:pattern name="rim"&gt;
          &lt;sch:rule abstract="true" id="Template-0"&gt;
            &lt;sch:assert test="not(model) or rim" /&gt;
          &lt;/sch:rule&gt;
        &lt;/sch:pattern&gt;
        &lt;sch:pattern name="defn"&gt;
          &lt;sch:rule abstract="true" id="Template-1"&gt;
            &lt;sch:assert test="model or attachment[@type=&#34;STATEMENT&#34;]" /&gt;
          &lt;/sch:rule&gt;
        &lt;/sch:pattern&gt;
      &lt;/xsd:appinfo&gt;
    &lt;/xsd:annotation&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="TemplateMetadata"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="model" type="ConstrainedClass" minOccurs="0" maxOccurs="1" /&gt;
          &lt;xsd:element name="rim" type="RIM" minOccurs="0" maxOccurs="1" /&gt;
          &lt;xsd:element name="attachment" type="Attachment" minOccurs="0" maxOccurs="unbounded" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="TemplateMetadata"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="id" type="Identifier" minOccurs="1" maxOccurs="1" /&gt;
      &lt;xsd:element name="derivationModel" type="Identifier" minOccurs="1" maxOccurs="1" /&gt;
      &lt;xsd:element name="referenceModelId" type="Identifier" minOccurs="1" maxOccurs="1" /&gt;
      &lt;xsd:element name="classification" type="Term" minOccurs="0" maxOccurs="unbounded" /&gt;
      &lt;xsd:element name="publisher" type="NameAndContact" minOccurs="0" maxOccurs="1" /&gt;
      &lt;xsd:element name="endorser" type="NameAndContact" minOccurs="0" maxOccurs="unbounded" /&gt;
      &lt;xsd:element name="supersededBy" type="Identifier" minOccurs="0" maxOccurs="1" /&gt;
      &lt;xsd:element name="revision" type="Revision" minOccurs="1" maxOccurs="unbounded" /&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="name" type="xsd:string" use="required" /&gt;
    &lt;xsd:attribute name="intention" type="xsd:string" use="required" /&gt;
    &lt;xsd:attribute name="version" type="xsd:string" use="required" /&gt;
    &lt;xsd:attribute name="repositoryURL" type="xsd:anyURI" use="optional" /&gt;
    &lt;xsd:attribute name="format" type="xsd:string" fixed="HL7.Template.V1" use="required" /&gt;
    &lt;xsd:attribute name="descriptionLanguage" type="set_string" use="required" /&gt;
    &lt;xsd:attribute name="description" type="xsd:string" use="required" /&gt;
    &lt;xsd:attribute name="detailedDescription" type="xsd:string" use="optional" /&gt;
    &lt;xsd:attribute name="evidenceSource" type="xsd:anyURI" use="optional" /&gt;
    &lt;xsd:attribute name="cautionPoints" type="set_string" use="optional" /&gt;
    &lt;xsd:attribute name="publicationStatus" type="PublicationStatus" use="required" /&gt;
    &lt;xsd:attribute name="publicationStatusChangeDate" type="xsd:dateTime" use="required" /&gt;
    &lt;xsd:attribute name="effectiveDate" type="xsd:dateTime" use="optional" /&gt;
    &lt;xsd:attribute name="supersededDate" type="xsd:dateTime" use="optional" /&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="Identifier"&gt;
    &lt;xsd:attribute name="root" type="xsd:string" use="required" /&gt;
    &lt;xsd:attribute name="extension" type="xsd:string" use="optional" /&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:simpleType name="URL"&gt;
    &lt;xsd:restriction base="xsd:anyURI" /&gt;
  &lt;/xsd:simpleType&gt;
  &lt;xsd:simpleType name="set_string"&gt;
    &lt;xsd:list itemType="xsd:string" /&gt;
  &lt;/xsd:simpleType&gt;
  &lt;xsd:complexType name="Term"&gt;
    &lt;xsd:attribute name="code" type="xsd:string" use="required" /&gt;
    &lt;xsd:attribute name="codeSystem" type="xsd:string" use="required" /&gt;
    &lt;xsd:attribute name="codeSystemVersion" type="xsd:string" use="required" /&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:simpleType name="PublicationStatus"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="DRAFT" /&gt;
      &lt;xsd:enumeration value="NOT_FOR_USE" /&gt;
      &lt;xsd:enumeration value="PRODUCTION" /&gt;
      &lt;xsd:enumeration value="WITHDRAWN" /&gt;
      &lt;xsd:enumeration value="SUPERSEDED" /&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;
  &lt;xsd:complexType name="NameAndContact"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="address" type="xsd:string" minOccurs="0" maxOccurs="1" /&gt;
      &lt;xsd:element name="id" type="Identifier" minOccurs="0" maxOccurs="1" /&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="name" type="xsd:string" use="required" /&gt;
    &lt;xsd:attribute name="email" type="xsd:string" use="optional" /&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="Revision"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="author" type="NameAndContact" minOccurs="0" maxOccurs="unbounded" /&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="comment" type="xsd:string" use="required" /&gt;
    &lt;xsd:attribute name="date" type="xsd:dateTime" use="required" /&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="Attachment"&gt;
    &lt;xsd:annotation&gt;
      &lt;xsd:appinfo&gt;
        &lt;sch:pattern name="content"&gt;
          &lt;sch:rule abstract="true" id="Attachment-0"&gt;
            &lt;sch:assert test="content or @reference" /&gt;
          &lt;/sch:rule&gt;
        &lt;/sch:pattern&gt;
        &lt;sch:pattern name="mediatype"&gt;
          &lt;sch:rule abstract="true" id="Attachment-1"&gt;
            &lt;sch:assert test="not(content) or (content and @mediatype)" /&gt;
          &lt;/sch:rule&gt;
        &lt;/sch:pattern&gt;
      &lt;/xsd:appinfo&gt;
    &lt;/xsd:annotation&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="content" type="xsd:base64Binary" minOccurs="0" maxOccurs="1" /&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="type" type="AttachmentType" use="required" /&gt;
    &lt;xsd:attribute name="mediatype" type="xsd:string" use="optional" /&gt;
    &lt;xsd:attribute name="reference" type="xsd:anyURI" use="optional" /&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:simpleType name="AttachmentType"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="STATEMENT" /&gt;
      &lt;xsd:enumeration value="STATIC_MODEL" /&gt;
      &lt;xsd:enumeration value="STATIC_MODEL_IMAGE" /&gt;
      &lt;xsd:enumeration value="COMPUTABLE" /&gt;
      &lt;xsd:enumeration value="DOCUMENTATION" /&gt;
      &lt;xsd:enumeration value="ENDORSEMENT" /&gt;
      &lt;xsd:enumeration value="EXAMPLE" /&gt;
      &lt;xsd:enumeration value="CITATION" /&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;
  &lt;xsd:element name="Template" type="Template" /&gt;
&lt;/xsd:schema&gt;
</pre>
      </div1>
   </body>

   <back>
   </back>
</spec>