<?xml version="1.0" encoding="ISO-8859-1"?><!-- $Id: datatypes.xml,v 1.5 2005/09/26 08:58:40 mcraig Exp $ -->
<!DOCTYPE v3pub-locations SYSTEM "../../support/ent/v3m.ent">

<!-- SUSPENDED look for this word in a comment to uncomment
     those items. I have excluded them now so I can do offline
     testing.
--><!--
  out standing promies:
   resolve status of UCUM
   
-->
<spec xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../support/dtd/v3spec.xsd">
<header>
<title>Data Types - Abstract Specification</title><version>1.0</version>
<date>December 2003</date>
<authlist><author><role>Chair/Editor</role><name>Gunther Schadow</name><affiliation>Regenstrief Institute for Health Care</affiliation><email href="gunther@aurora.rg.iupui.edu" xlink-form="simple" show="embed" actuate="auto"/></author><author><role>Editor</role><name>Paul Biron</name><affiliation>Kaiser Permanente, Southern California</affiliation><email href="paul.v.biron@kp.org" xlink-form="simple" show="embed" actuate="auto"/></author><author><role>Editor</role><name>Lloyd McKenzie</name><affiliation>IBM Global Services</affiliation><email href="lmckenzi@ca.ibm.com" xlink-form="simple" show="embed" actuate="auto"/></author><author><role>Editor</role><name>Grahame Grieve</name><affiliation>Kestral Computing Pty. Ltd.</affiliation><email href="grahame@kestral.com.au" xlink-form="simple" show="embed" actuate="auto"/></author><author><role>Editor</role><name>Doug Pratt</name><affiliation>Siemens</affiliation><email href="Douglas.Pratt@siemens.com" xlink-form="simple" show="embed" actuate="auto"/></author></authlist>
</header>
<front>
	<div1 id="datyp2preface"><head>Preface</head><p>
				This document specifies the HL7 Version 3 Data Types on an
				abstract layer, independent of representation. By "independent
				of representation" we mean independent of both abstract syntax
				as well as implementation in any particular implementation technology.
			</p><p>
				This document is accompanied by Implementation Technology
				Specifications (ITS). The ITS documents can serve as a quick
				compendium to the data types that is more practically oriented 
				toward the representation in that particular implementation
				technology.
			</p><p>
				Vocabulary tables within this specification list the current contents
				of vocabulary domains for ease of reference by the reader. However, at
				any given time the normative source for these domains is the
				vocabulary tables in the RIM database. For some large domains, only a
				sample of possible values is shown. The complete domains can be
				referenced in the vocabulary tables by looking up the domain name
				associated with the table in the RIM vocabulary tables.
			</p></div1>
			
		<div1 id="datyp2acks"><head>Acknowledgements</head><p>
				This specification is the result of many years of intense work through
				e-mail, telephone conferences and meeting discussions. And ballot
				reconciliation. 

				Thanks go to many individuals who participated at various times in
				design, discussions and ballot review.

				Gunther Schadow (Regenstrief Institute for Health Care) chaired this
				task force, and is the main author of this document. Paul V. Biron
				(Kaiser Permanente), Doug Pratt (Siemens), Lloyd McKenzie (IBM), and
				Grahame Grieve (Kestral Computing Pty. Ltd.) have served as co-editors
				at various times. 

				Major contributions of thoughts and support come from Mark Tucker
				(Regenstrief Institute), George Beeler, Stan Huff (Intermountain
				Health Care), as well as Mike Henderson (Kaiser Permanente), Anthony
				Julian (Mayo), Joann Larson (Kaiser Permanente), Mark Shafarman (Oacis
				Healthcare Systems), Wes Rishel (Gartner Group), and Robin Zimmerman
				(Kaiser Permanente).

				Acknowledgements for their critical review and infusion of ideas go to
				Bob Dolin (Kaiser Permanente), Clem McDonald (Regenstrief Institute),
				Kai Heitmann (HL7 Germany), Rob Seliger (Sentillion), and Harold
				Solbrig (Mayo Clinic).

				Vital support came from the members of the task force, Laticia
				Fitzpatrick (Kaiser Permanente), Matt Huges, Randy Marbach (Kaiser
				Permanente), Larry Reis (Wizdom Systems), Carlos Sanroman (Kaiser
				Permanente), Greg Thomas (Kaiser Permanente). Thanks James Case
				(University of California, Davis), Norman Daoust (Partners HealthCare
				Systems), Irma Jongeneel (HL7 The Netherlands), Michio Kimura (HL7
				Japan), John Molina (SMS), Richard Ohlmann (McKessonHBOC), David Rowed
				(HL7 Australia), and Klaus Veil (Macquarie Health Corp., HL7
				Australia), for sharing their expertise in critical questions.

				This work was made possible by the Regenstrief Institute for Health
				Care.
			</p></div1>
		<div1 id="datyp2ToDo">
		<head>Outstanding issues</head><list role="unordered"><item>
			<p>
						Conformance framework for constraining data types
					</p></item></list></div1></front><body>
			<div1 id="datyp2intro"  ballotStatus="NormativeStandard">
			<head>Introduction</head><div2 id="datyp2introwhat"><head>What is a Data Type?</head><p>
					Every data element has a data type. Data types define the meaning
					(semantics) of data values that can be assigned to a data
					element. Meaningful exchange of data requires that we know the
					definition of values so exchanged. This is true for complex "values"
					such as business messages as well as for simpler values such as
					character strings or integer numbers.
				</p><p>
					According to ISO 11404, a data type is "a set of distinct values,
					characterized by properties of those values and by operations on
					those values."  A data type has <emph>intension</emph> and
					<emph>extension</emph>. Intentionally, the data type defines the
					properties exposed by every data value of that type. Extensionally,
					data types have a set of data values that are of that type (the type's
					"value set").
				</p><p>
					Semantic properties of data types are what ISO 11404 calls "properties
					of those values and [...] operations on those values."  A semantic
					property of a data type is referred to by a name and has a value for
					each data value. The value of a data value's property must itself be a
					value defined by a data type - no data value exists that would not be
					defined by a data type.
				</p><p>
					Data types are thus the basic building blocks used to construct any
					higher order meaning: messages, computerized patient record documents,
					or business objects and their transactions. What, then, is the
					difference between a data type and a message, document, or business
					object? <emph role="strong">Data type values stand for themselves, the
					value is all that counts, neither identity nor state or changing of
					state is defined for a data value.</emph> Conversely in business
					objects, we track state and identity; the properties of an identical
					object might change between now and later. Not so with data values: a
					data value and its properties are constant. For example, number 5 is
					always number 5, there is no difference between this number 5 and that
					number 5 (no identity distinguished from value), number 5 never
					changes to number 6 (no change of state). One can think of data values
					as immutable objects where identity does not matter (identity and
					equality are the same.)<footnote><p>
							The HL7 Message Development Framework defines "update modes" for
							fields in a message. Note that because data values have neither
							identity nor state nor changing of state, these update modes do not
							apply for the properties of data values. Data values and their
							properties are never updated. A field of an object (e.g., a message)
							can be updated in which case the field's value is replaced by another
							value. But the value itself is never updated.
						</p></footnote></p></div2><div2 id="datyp2introrep"><head>Representation of Data Values</head><p>
					Data values can be represented through various symbols but the data
					value's meaning is not bound to any particular representation.
				</p><p>
					For example, cardinal numbers (non-negative integers) are defined -
					intentionally - as a data type where each value has a successor value,
					where zero is the successor of no other cardinal value. Based on this
					definition we can define addition, multiplication, and other
					mathematical operations. Whatever representation reflects the rules we
					stated in the intentional definition of the cardinal data type is a
					valid representation of cardinal numbers. Examples for valid cardinal
					number representations are decimal digit strings, bags of glass
					marbles, or scratches on a wall. The number five is represented by the
					word "five" by the Arabic number "5" or the Roman number "V". The
					representation does not matter as long as it conforms to the semantic
					definition of the data type.
				</p><p>
					Another example, the Boolean data type is defined by its extension,
					the two distinct values <emph>true</emph> and <emph>false</emph> and
					the rules of negation and combining these values in conjunction and
					disjunction. The representation of Boolean values can be the words
					"true" and "false," "yes" and "no," the numbers 0 and 1, any two signs
					that are distinct from each other. The representation of data types
					does not matter as long as it conforms to the semantic definition of
					the data type.
				</p><p>
					This specification defines the semantics, the meaning of the HL7 data
					types. <emph role="strong">This specification is about semantics only,
					independent from representational and operational concerns or specific
					implementation technologies.</emph> Additional standards for
					representing the data values defined here are being defined for
					various technological approaches. These standards are called
					"Implementable Technology Specification" (ITS.) Those ITS define how
					values are represented so that they conform to the semantic
					definitions of this specifications, this may include syntaxes for
					character or binary representations, and computer procedures to act on
					the representation of data values. The meaning of these ITS
					representations communicated, generated, and processed in computer
					programs, is defined based on this standard, the semantic data type
					specification.
				</p></div2><div2 id="datyp2introprop"><head>Properties of Data Values</head><p>
					Data values have properties defined by their data type. The "fields"
					of "composite data types" are the most common example of such
					properties. However, more generally one should think of a data value's
					property as logical predicates or as mathematical functions; in
					simpler but still correct terms, properties are questions one can ask
					about a data value to receive another data value as an answer.
				</p><p>
					A property is referred to by its name. For example, the data type
					<emph>integer</emph> may have a property named "sign."  A property has
					a domain, which is the set of possible "answer" values. The set of
					possible "answer" values is defined by the property's data type, but
					the domain of a property may be a subset of the data type's value set.
				</p><p>
					A property may also have arguments, additional information one must
					supply with a question to get an answer. For example, an important
					property of an integer number is that one integer <emph>plus</emph>
					another integer results in another integer, so the plus property of
					one integer needs an argument: the other integer.
				</p><p>
					Whether semantic properties have arguments is not a fundamentally
					relevant distinction. A data type's semantic property without
					arguments is not necessarily a "field" of a "composite" data type. For
					example, for integer values, we can define the property
					<emph>is-zero</emph> that has the Boolean value <emph>true</emph> when
					the number is zero and <emph>false</emph> when the number is not
					zero. This does not mean that <emph>is-zero</emph> must be an explicit
					component of any integer representation.
				</p><p>
					A data type's semantic property with arguments has no specific
					operational notions such as "procedure call," "passing arguments,"
					"return values," "throwing exceptions," etc. These are all concepts of
					computer systems implementation of data types - but these operational
					notions are irrelevant for the semantics of data types.
				</p><p><emph role="strong">This specification is about semantics of data
					types only. Neither is it about value representation syntax (not even
					an abstract syntax), nor is it about an operational interface to the
					data values.</emph></p></div2><div2 id="datyp2intronabs"><head>Need for Abstraction</head><p><emph role="strong">Why does this specification make such a big issue
					about its being abstract from representation syntax as well as
					operational implementation?</emph></p><p>
					HL7 needs this kind of abstract semantic data type specification for a
					very practical purpose. One important design feature of HL7 version 3
					is its openness towards representation and implementation
					technologies. All HL7 version 3 specifications are supposed to be done
					in a form independent from specific representation and implementation
					technologies. HL7 acknowledges that, while at times some
					representation and implementation technologies may be more popular
					than others, technology is going to change - and with changing
					technology, representations of data values will change. HL7 standards
					are primarily targeted to healthcare domain information, independent
					from the technology supporting this information. HL7 expects that
					specifications defined independent from today's technology will
					continue to be useful, even after the next technological "paradigm
					shift".
				</p><p>
					The issue of data types is closer to implementation technology than
					most other HL7 information standards - and therein lays a certain
					danger that we define data types too dependent on current
					implementation technologies.
				</p><p>
					The majority of HL7 standards are about complex business
					objects. Complex business objects with many informational attributes
					can be specified as abstract syntax, where components are eventually
					defined in terms of data types. Conversely, defining data types in
					terms of abstract syntax is of little use because the components of
					such abstract syntax constructs would still have to have data
					types.<footnote><p>
							This is the reason why the ISO Abstract Syntax Notation 1 (ASN.1) is
							not an appropriate formalism for semantic data type specifications.
						</p></footnote></p><p><emph role="strong">Why is this specification so circular?
					Why is the data type "ANY" defined in terms of specializations
					of itself?</emph></p><p>
					This specification needs to be independent of any particular implementation,
					and is therefore abstract, and not intended to be implementable. In this sense,
					the circularity is not a problem, since it does not introduce any uncertainty
					about what this specification says.
				</p><p><emph role="strong">Why doesn't this specification define a set of
					primitive data types based on which composite data types could be
					defined simply as abstract syntax?</emph></p><p>
					Any concrete implementation of the HL7 standards must ultimately use
					the built-in data types of their implementation technology. Therefore,
					we need a very flexible mapping between HL7 abstract data types and
					those data types built into any specific implementation
					technology. With a semantic specification, an Implementable Technology
					Specification (ITS) can conform simply by stating a mapping between
					the constructs of its technology and the HL7 version 3 data type
					semantics. Whether a data type is primitive of composite is irrelevant
					from a semantic perspective, and the answer may be different for
					different implementation technologies.
				</p><p>
					For example, this standard specifies a character string as a data type
					with many properties (e.g., charset, language, etc.)  However, in many
					Implementation Technologies, character strings are primitive first
					class data types. We encourage that these native data types be used
					rather than a structure that slavishly represents all the semantic
					properties as "components."  This specification only requires that the
					properties defined for data values can somehow be inferred from
					whatever representation is chosen, it does not matter how these values
					are represented. Whether "primitive" or "composite", with few or many
					"components", as "fields" or "methods" - this is all irrelevant.
				</p><p>
					For another example, a decimal representation, a floating-point
					register and a scaled integer are all possible native representations
					of real numbers for different implementation technologies. Some of
					these representations have properties that others do not have. Scaled
					integers, for instance, have a fixed precision and a relatively small
					range. Floating-point values have variable precision and a large
					range, but floating-point values lose any information about
					precision. Decimal representations are of variable precision and
					maintain the precision information (yet are slow to processing.)  The
					data type semantics must be independent from all these accidental
					properties of the various representations, and must define the
					essential properties that any technology should be able to represent.
				</p></div2><div2 id="datyp2introndts"><head>Need for an HL7 Data Type Standard</head><p><emph role="strong">Why does HL7 need its own data type standard? Why
					can't HL7 simply adopt a standard defined by some other body?</emph></p><p>
					As noted in the previous section, all HL7 implementation technologies
					have some data type system, but there are differences among the data
					type systems between implementation technologies. In addition, many
					implementation technologies' data type systems are not powerful enough
					to express the concepts that matter for the HL7 application layer.
				</p><p>
					For example, few implementation technologies provide the concepts of
					physical quantities, precision, ranges, missing information, and
					uncertainty that are so relevant in scientific and health care
					computing.
				</p><p>
					On the other hand, implementation technologies do make distinctions
					that are not relevant from the abstract semantics viewpoint, e.g.,
					fixed point vs. floating-point real numbers; 8, 16, 32, or 64-bit
					integers; date vs. timestamp.
				</p><p>
					A number of data type systems have been used as input to this
					specification. These include the type systems of many major
					programming languages, including BASIC, Pascal, MODULA-2, C, C++,
					JAVA, ADA, LISP and SCHEME. This also includes type systems of
					language-independent implementation technologies, such as Abstract
					Syntax Notation One (ASN.1), Object Management Group's (OMG) Interface
					Definition Language (IDL) and Object Constraint Language (OCL), SQL 92
					and SQL 99, the ISO 11404 language independent data types, and XML
					Schema Part 2 data types. Health care standards related data types
					have been considered as well, among these HL7 version 2.x, types used
					by CEN TC 251 messages and Electronic Health Record Architecture
					(EHCRA) and DICOM.
				</p></div2><div2 id="datyp2introreq"><head>Requirements</head><p>
					The data types described in this specification are designed
					to meet a number of requirements. These include
				</p><list role="unordered"><item>
						Modelling considerations
					</item><item>
						Implementation Considerations
					</item><item>
						Compatibility with other data type standards
					</item><item>
						Functional Requirements identified in other HL7 standards
						where the data types are used
					</item></list><p>
					Of these, the last is the most important consideration. These data types are designed
					to deliver the functionality required throughout the HL7 standards. These requirements
					are not always compatible, and throughout this specification there is a number of places
					where particular design features are less than optimal for one of the 4 considerations
					listed above. In a number of these places, the requirements that led to this design
					feature are described in a requirements section. These requirements sections are only
					informative, not normative.
				</p><exhibit role="requirement"><emph role="strong">Requirement</emph><p>
						The Reference Information Model defines a number of reference classes on which
						all domain information models are based. Each of these reference classes has
						a series of attributes which has an assigned type. Where the reference classes
						are used (cloned into) in domain models, the types in the reference classes may
						be replaced by other types to clarify and constrain the use of the attribute in
						the clone classes.
					</p><p>
						This data types specification must define the rules for which data
						types can be substituted in this fashion. This specification chooses
						to use the specialization metaphor as a basis for the substitution
						rules, since this is widely understood and used method in theory and
						practice, and because these rules are more easily understood and
						managed than the alternatives. This use of specialization may lead to
						designs that may appear unfamiliar to some.
					</p></exhibit></div2><div2 id="datyp2introform"><head>Forms of Data Type Definitions</head><p>
					This specification defines data types in several forms, using textual
					description, UML diagrams, tables, and a formal definition.
				</p><div3><head>Formal Data Type Definition Language</head><p>
						A formal definition of data types is used in order to clarify the
						semantics of the proposed types as unambiguously as possible. This
						data type definition language is described in detail in
						<specref ref="dtdl-introduction"/>. Formal languages make crisp essential statement and 
						are therefore accessible to some formal argument of proof or rebuttal. However, 
						the terseness of such formal statements may also be difficult to
						understand by humans. Therefore, all the important inferences from the
						formal statements are also included as plain English statements.
				  </p></div3><div3><head>Tables of Properties</head><p>
						For a quick overview at the beginning of many data types this
						specification contains tables listing "primary" properties. "Primary"
						properties are a somewhat fuzzy notion of those properties that are
						more likely to be thought of as "fields" when the data type where
						implemented as a record, or that are expected to be used more
						often. These tables are provided to facilitate an overview of the
						content and purpose of data types. There is no requirement that the
						properties listed in these tables be represented as fields, and these
						tables are <emph role="strong">not</emph> abstract syntax definitions.
					</p><p>
						Each row of the property tables describes one property with the
						following columns:
					</p><list role="ordered"><item><emph role="strong">Name</emph> - the name of the property as stated in
							the formal definition. For some data types, the name field of the first
							property may be empty. This may happen in those data types that are
							defined as extension of other data types and when it is not useful for
							the summary of the child to show any properties of the parent.
						</item><item><emph role="strong">Type</emph> - the data type of that property.
						</item><!-- LM: Commented this out instead of using 'hide' because otherwise
     we have to support the hide element everywhere.
						<item>
							<p>
								<emph role="strong">Status</emph> - indicates the "importance"
								of the property. Status values include:
							</p>
							<table>
								<caption>Status of "importance" of properties</caption>
									<col width="0.73"/>
									<col width="3.98"/>
									<thead>
										<tr>
											<th>Status</th>
											<th>Definition</th>
										</tr>
									</thead>
									<tbody>
										<tr>
											<td>mandatory</td>
											<td>
												A mandatory property of a non-NULL data
												value always has a proper value and cannot is
												not NULL. Mandatory properties can usually not 
												be inferred from other properties, so most ITS
												will usually require that mandatory properties
												be specified in value representations.
											</td>
										</tr>
										<tr>
											<td>optional</td>
											<td>
												Optional properties of non-NULL data values may be 
												undetermined (NULL).
											</td>
										</tr>
										<tr>
											<td>implied</td>
											<td>
												Properties whose values are implied by circumstances 
												of the data value, such as the context of
												representation.
											</td>
										</tr>
										<tr>
											<td>fixed</td>
											<td>
												Properties that are constrained to a specific 
												value.
											</td>
										</tr>
										<tr>
											<td>auxiliary</td>
											<td>
												Optional properties whose value is not considered 
												for automated processing of data values. Auxiliary 
												properties have been defined mostly for debugging or 
												audit trail purposes. Auxiliary properties are reviewed 
												by people and do not change the meaning of a data 
												value.
											</td>
										</tr>
									</tbody>
								</table>
							</item>
							<item>
								<p>
									<emph role="strong">Default</emph> - a default value is a 
									typical value of this property (when the status of .the property is "fixed," 
									the default specifies that predetermined value.) In an interface, a
									property takes on that default value if a value for that property is
									not otherwise determined in the representation received by that
									interface. Default values are what is implicitly understood. A default
									may be determined at various levels.
								</p>
								<table>
									<caption>Levels of Determination for Defaults</caption>
									<col width="0.83"/>
									<col width="3.88"/>
									<thead>
										<tr>
											<th>Status</th>
											<th>Definition</th>
										</tr>
									</thead>
									<tbody>
										<tr>
											<td>
												<emph>immediate</emph>
											</td>
											<td>
												The default is known and mentioned in this 
												specification. The default column then contains
												that a literal for that default value (not the
												word "immediate").
											</td>
										</tr>
										<tr>
											<td>NULL</td>
											<td>No default is defined.</td>
										</tr>
										<tr>
											<td>ITS</td>
											<td>
												The default is determined by the Implementable 
												Technology Specification (ITS) either immediately
												or through some ITS-specified rule.
											</td>
										</tr>
										<tr>
											<td>CONTEXT</td>
											<td>
												The default is determined depending on the context 
												of a data value. For example, it may be determined
												by some other data in the same message.
											</td>
										</tr>
									</tbody>
								</table>
							</item>
							<item>
								<p>
									<emph role="strong">Constraint</emph> - for coded
									properties, this column contains the named domain (as per the HL7 domain
									specifications.)  For other properties, this column contains other
									constraints - these constraints are fully specified in the formal data
									type definition.
								</p>
							</item>
  --><item><emph role="strong">Definition</emph> - a short text describing
							the meaning of the property.
						</item></list></div3><div3><head>Unified Modeling Language (UML) Diagrams</head><p>
						The Unified Modeling Language (UML) is used for a graphical
						presentation of how data types relate to each other . Data types are
						shown as UML classes using the shortname for the class. Properties of
						types are shown as UML operations. Generic types are shown as UML
						parameterized classes, with UML realization links relating their
						instantiations.
					</p><p>
						Much of the detail of the data type declarations cannot be represented
						in the UML representation. Therefore the formal definition of the data
						types in the Data Type Definition Language (DTDL) should be used for
						detailed specification of the data types.
					</p><p>
						Some of the constraints from the DTDL are represented as constraints on the
						operations. Where constrains are shown, they are statements that will be true
						and are taken from the DTDL specification
					</p><p>
						The UML Diagrams use a stereotype "mixin". The mixin stereotype applies to
						a parameterized class, and denotes that the class specializes the parameter
						type and expresses all the properties of the type T in addition to it's own
						properties   
					</p></div3></div2><div2 id="datyp2introovw"><head>Overview of Data Types</head><graphic source="graphics/dtUML-Main.gif" alt="UML Overview of Data Types"/><table id="dt-summary-table"><caption>
       Overview of HL7 version 3 data types
    </caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Symbol</th><th>Description</th></tr></thead><tbody><tr><td>DataValue</td><td><termref ref="dt-ANY">ANY</termref></td><td>
					Defines the basic properties of every data value. This is an abstract
					type, meaning that no value can be just a data value without belonging
					to any concrete type. Every concrete type is a specialization of this
					general abstract DataValue type.
				</td></tr><tr><td>Boolean</td><td><termref ref="dt-BL">BL</termref></td><td><emph>BL</emph> stands for the values of two-valued logic. A <emph>BL</emph>
					value can be either <emph>true</emph> or <emph>false</emph>, or, as
					any other value may be NULL.
				</td></tr><tr><td>BooleanNonNull</td><td><termref ref="dt-BN">BN</termref></td><td><emph>BN</emph> constrains the boolean type so that the value may not be NULL.
					This type is created for use within the data types specification where it is not
					appropriate for a null value to be used
				</td></tr><tr><td>Encapsulated Data</td><td><termref ref="dt-ED">ED</termref></td><td>
					Data that is primarily intended for human interpretation or for
					further machine processing outside the scope of HL7. This includes
					unformatted or formatted written language, multimedia data, or
					structured information in as defined by a different standard (e.g.,
					XML-signatures.)  Instead of the data itself, an <emph>ED</emph>
					may contain only a reference (see <termref ref="dt-TEL">TEL</termref>.) Note that
					<termref ref="dt-ST">ST</termref> is a specialization of the
					<emph>ED</emph> where the <termref ref="prop-ED.mediaType">mediaType</termref> is fixed to text/plain.
				</td></tr><tr><td>Character String</td><td><termref ref="dt-ST">ST</termref></td><td>
					The character string data type stands for text data, primarily
					intended for machine processing (e.g., sorting, querying, indexing,
					etc.) Used for names, symbols, and formal expressions.
				</td></tr><tr><td>Concept Descriptor</td><td><termref ref="dt-CD">CD</termref></td><td>
					A <emph>CD</emph> represents any kind of concept usually by
					giving a code defined in a code system.

					A <emph>CD</emph> can contain the original text or phrase that
					served as the basis of the coding and one or more translations into
					different coding systems.

					A <emph>CD</emph> can also contain qualifiers to describe, e.g., the
					concept of a "left foot" as a postcoordinated term built from the
					primary code "FOOT" and the qualifier "LEFT".

					In cases of an exceptional value, the <emph>CD</emph> need not contain a code
					but only the original text describing that concept.
				</td></tr><tr><td>Coded Simple Value</td><td><termref ref="dt-CS">CS</termref></td><td>
					Coded data in its simplest form, where only the code is not predetermined.
					The code system and code system version are fixed by the context in which
					the <emph>CS</emph> value occurs. <emph>CS</emph> is used for coded attributes that have a single
					HL7-defined value set.
				</td></tr><tr><td>Coded Ordinal</td><td><termref ref="dt-CO">CO</termref></td><td>
					Coded data, where the coding system from which the code comes is ordered.
					<emph>CO</emph> adds semantics related to ordering so that models
					that make use of such domains may introduce model elements that involve
					statements about the order of the terms in a domain.
				</td></tr><tr><td>Coded With Equivalents</td><td><termref ref="dt-CE">CE</termref></td><td>
					Coded data that consists of a coded value and, optionally, coded
					value(s) from other coding systems that identify the same
					concept. Used when alternative codes may exist.
				</td></tr><tr><td>Character String with Code</td><td><termref ref="dt-SC">SC</termref></td><td>
					A character string that optionally may have a code attached. The text
					must always be present if a code is present.  The code is often a
					local code.
				</td></tr><tr><td>Instance Identifier</td><td><termref ref="dt-II">II</termref></td><td>
					An identifier that uniquely identifies a thing or object. Examples
					are object identifier for HL7 RIM objects, medical record number,
					order id, service catalog item id, Vehicle Identification Number
					(VIN), etc. Instance identifiers are defined based on ISO object
					identifiers.
				</td></tr><tr><td>Telecommunication Address</td><td><termref ref="dt-TEL">TEL</termref></td><td>
					A telephone number (voice or fax), e-mail address, or other locator
					for a resource mediated by telecommunication equipment. The address is
					specified as a Universal Resource Locator (URL) qualified by time
					specification and use codes that help in deciding which address to use
					for a given time and purpose.
				</td></tr><tr><td>Postal Address</td><td><termref ref="dt-AD">AD</termref></td><td>
					Mailing and home or office addresses. A sequence of address parts,
					such as street or post office Box, city, postal code, country, etc.
				</td></tr><tr><td>Entity Name</td><td><termref ref="dt-EN">EN</termref></td><td>
					A name for a person, organization, place or thing. A sequence of name
					parts, such as given name or family name, prefix, suffix, etc.
					Examples for entity name values are "Jim Bob Walton, Jr.", "Health
					Level Seven, Inc.", "Lake Tahoe", etc. An entity name may be as simple
					as a character string or may consist of several entity name parts,
					such as, "Jim", "Bob", "Walton", and "Jr.", "Health Level Seven" and
					"Inc.", "Lake" and "Tahoe".
				</td></tr><tr><td>Trivial Name</td><td><termref ref="dt-TN">TN</termref></td><td>
					A restriction of entity name that is effectively a simple string used
					for a simple name for things and places.
				</td></tr><tr><td>Person Name</td><td><termref ref="dt-PN">PN</termref></td><td>
					An <termref ref="dt-EN">EN</termref> used when the named Entity
					is a Person. A sequence of name parts, such as given name or
					family name, prefix, suffix, etc. A name part is a restriction of
					entity name part that only allows those entity name parts qualifiers
					applicable to person names. Since the structure of entity name is
					mostly determined by the requirements of person name, the restriction
					is very minor.
				</td></tr><tr><td>Organization Name</td><td><termref ref="dt-ON">ON</termref></td><td>
					An <termref ref="dt-EN">EN</termref> used when the named Entity
					is an Organization. A sequence of name parts.
				</td></tr><tr><td>Integer Number</td><td><termref ref="dt-INT">INT</termref></td><td>
					Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise numbers
					that are results of counting and enumerating. Integer numbers are
					discrete, the set of integers is infinite but countable.  No arbitrary
					limit is imposed on the range of integer numbers. Two NULL flavors are
					defined for the positive and negative infinity.
				</td></tr><tr><td>Real Number</td><td><termref ref="dt-REAL">REAL</termref></td><td>
					Fractional numbers. Typically used whenever quantities are measured,
					estimated, or computed from other real numbers.  The typical
					representation is decimal, where the number of significant decimal
					digits is known as the precision.
				</td></tr><tr><td>Ratio</td><td><termref ref="dt-RTO">RTO</termref></td><td>
					A quantity constructed as the quotient of a numerator quantity divided
					by a denominator quantity. Common factors in the numerator and
					denominator are not automatically cancelled out.  The <emph>RTO</emph> data
					type supports titers (e.g., "1:128") and other quantities produced by
					laboratories that truly represent ratios. Ratios are not simply
					"structured numerics", particularly blood pressure measurements
					(e.g. "120/60") are not ratios. In many cases the <termref ref="dt-REAL">REAL</termref>
					should be used instead of the <emph>RTO</emph>.
				</td></tr><tr><td>Physical Quantity</td><td><termref ref="dt-PQ">PQ</termref></td><td>
					A dimensioned quantity expressing the result of measuring.
				</td></tr><tr><td>Monetary Amount</td><td><termref ref="dt-MO">MO</termref></td><td>
					An <emph>MO</emph> is a quantity expressing the amount of money in some
					currency. Currencies are the units in which monetary amounts are
					denominated in different economic regions. While the monetary amount
					is a single kind of quantity (money) the exchange rates between the
					different units are variable.  This is the principle difference
					between <termref ref="dt-PQ">PQ</termref> and <emph>MO</emph>, and the reason why
					currency units are not physical units.
				</td></tr><tr><td>Point in Time</td><td><termref ref="dt-TS">TS</termref></td><td>
					A quantity specifying a point on the axis of natural time. A point
					in time is most often represented as a calendar expression.
				</td></tr><tr><td>Set</td><td><termref ref="dt-SET">SET</termref></td><td>
					A value that contains other distinct values in no particular order.
				</td></tr><tr><td>Sequence</td><td><termref ref="dt-LIST">LIST</termref></td><td>
					A value that contains other discrete (but not necessarily distinct) values in a defined sequence. 
				</td></tr><tr><td>Bag</td><td><termref ref="dt-BAG">BAG</termref></td><td>
					An unordered collection of values, where each value can be contained
					more than once in the collection.
				</td></tr><tr><td>Interval</td><td><termref ref="dt-IVL">IVL</termref></td><td>
					A set of consecutive values of an ordered base data type.
				</td></tr><tr><td>History</td><td><termref ref="dt-HIST">HIST</termref></td><td>
					A set of data values that have a valid-time property and thus
					conform to the <termref ref="dt-HXIT">HXIT</termref> type. The history information is
					not limited to the past; expected future values can also appear.
				</td></tr><tr><td>Uncertain Value - Probabilistic</td><td><termref ref="dt-UVP">UVP</termref></td><td>
					A generic data type extension used to specify a probability expressing
					the information producer's belief that the given value holds.
				</td></tr><tr><td>Periodic Interval of Time</td><td><termref ref="dt-PIVL">PIVL</termref></td><td>
					An interval of time that recurs periodically. <emph>PIVL</emph> has
					two properties, <termref ref="prop-PIVL.phase">phase</termref> and <termref ref="prop-PIVL.period">period</termref>.
					<termref ref="prop-PIVL.phase">phase</termref> specifies the "interval
					prototype" that is repeated every <termref ref="prop-PIVL-period">.</termref>.
				</td></tr><tr><td>Event-Related Periodic Interval of Time</td><td><termref ref="dt-EIVL">EIVL</termref></td><td>
					Specifies a periodic interval of time where the recurrence is based on
					activities of daily living or other important events that are
					time-related but not fully determined by time.
				</td></tr><tr><td>General Timing Specification</td><td><termref ref="dt-GTS">GTS</termref></td><td>
					A <termref ref="dt-"/>&lt;<termref ref="dt-dt-TS">dt-TS</termref>&gt;, specifying the timing of events and actions
					and the cyclical validity-patterns that may exist for certain kinds of
					information, such as phone numbers (evening, daytime), addresses (so
					called "snowbirds," residing closer to the equator during winter and
					farther from the equator during summer) and office hours.
				</td></tr><tr><td>Parametric Probability Distribution</td><td><termref ref="dt-PPD">PPD</termref></td><td>
					A generic data type extension specifying uncertainty of quantitative
					data using a distribution function and its parameters. Aside from the 
					specific parameters of the distribution, a mean (expected value) and 
					standard deviation is always given to help maintain a minimum layer
					of interoperability if receiving applications cannot deal with a
					certain probability distribution.
				</td></tr></tbody></table></div2><div2 id="dtdl-introduction"><head>Introduction to the Formal Data Type Definition Language (DTDL)</head><note role="disclaimer"><p><emph role="strong">This is not an API specification.</emph> While
						this formal language might resemble some programming language or
						interface definition language, it is not intended to define the
						details of programs and other means of implementation. The formal
						definitions are a normative part of this specification, but this
						particular language needs not be implemented or used in conformant
						systems; nor need all the semantic properties be implemented or used
						by conformant systems. The internal working of systems, their way to
						implement data types, <emph role="strong">their functionality and
						services is entirely out of scope of this specification. The formal
						definition only specifies the meaning</emph> of the data values
						through making statements how one would theoretically expect these
						values to relate and behave.
					</p></note><p>
					This formal data type definition language<footnote><p>
							The data type definition language employed here is a conclusion of
							experiments and experience with various alternatives. These
							alternatives include data type definition tables and the use of the
							Object Management Group's (OMG) Interface Definition Language
							(IDL). The disadvantage of the data type definition tables was that
							they gave the wrong impression of this specification being a
							specification of abstract syntax rather than semantics. Conversely,
							the disadvantage with IDL was that IDL gave the wrong impression of
							this specification being an application programming interface (API)
							definition.
						</p><p>
							The resulting data type definition language borrows significantly from
							IDL, the Object Constraint Language (OCL), JAVA, C++, and the parser
							generation tools LEX and YACC. It is inspired by features and style of
							these languages but amalgamating and augmenting these languages into
							precisely what is needed for this data type specification. The goal
							was a language that is minimal, and self-consistent. Also, as the main
							purpose of this language is to define data types it tries to get by
							without any built-in data types.
						</p></footnote>
						specifies:
				</p><list role="unordered"><item>
						type name and short name;
					</item><item>
						named values of a fully enumerated extension;
					</item><item>
						semantic properties, unary, binary, and higher order properties;
					</item><item>
						invariants, i.e. constraints over the properties.
					</item><item>
						allowable type conversions;
					</item><item>
						syntax of character string value literals (if any);
					</item></list><p>
					Definition of a data type occurs in two steps. First, the data type is
					declared. The declaration claims a name for a new data type with a
					list of names, types, and signatures of the new type's semantic
					properties. This declares, not defines the type. The definition occurs
					in both logic statements about what is always true about this type's
					values and their properties (invariant statements.)
				</p><div3><head>Declaration</head><p>
						Every data type is declared in a form that begins with the keyword 
						<emph role="strong">type</emph>. For example, the following is the 
						header of a declaration for the data type Boolean that has the short 
						name alias <termref ref="dt-BL">BL</termref> and specializes the data type
						ANY.<footnote><p>
								As can be seen, the type keyword is in place of IDL's and Java's interface and
								C++ amd Java's class keyword. The alias clause is unique to this specification
								as we do have the need for extremely short data type mnemonics in addition to
								more descriptive names. The specializes clause is
								preferred over C++ or IDL's colon clause as its meaning is more obvious.
							</p></footnote></p><exhibit role="dtdl"><caption/><pre>
type Boolean alias BL specializes ANY
   values(true, false)
{
   BL  not;
   BL  and(BL x);
};</pre></exhibit><p>
						The Boolean data type declaration also contains a
						<emph role="strong">values</emph>-clause that declares the Boolean's
						complete set of values (its extension) as named entities. These named
						values are also valid character string literals. None of the other
						data types defined in this specification has a finite value set, which
						is why the <emph role="strong">values</emph>-clause is unique to the
						Boolean. In the marked-up formal language, value names use Italics
						font.
					</p><p>
						The block in curly braces following the header contains declarations
						of the semantic properties that hold for every value of the data
						type. A semicolon terminates each property declaration; and another
						semicolon after the closing curly brace terminates the data type
						declaration.
					</p><p>
						A property declaration mentions from left to right: (1) the data type
						of the property's value domain, (2) the property name, and (3) an optional
						argument list. The argument list of a property is enclosed in
						parentheses containing a sequence of argument declarations. Each
						argument is declared by the data type name and argument name. Semantic
						properties without arguments do not use an empty argument
						list.<footnote><p>
								Note that the IDL's notion of input and output arguments and IDL's,
								JAVA's and C++'s notion of return values and exceptions are all
								irrelevant concepts for this specification. The semantics of data
								types is not about procedure calls and parameter passing or normal and
								abnormal returns of control from a procedure body. Instead, each
								semantic property is conceptualized as a function that maps a value
								and optional arguments to another value. This mapping is not
								"computed" or "generated", it logically exists and we do not need to
								"call" such a function to actualize the mapping.
							</p></footnote></p><p>
						The <emph role="strong">specializes</emph>-clause means (a)
						inheritance of properties from the genus to the species, and (b)
						substitutability of values of the species type for variables of the
						genus type. Specialization can include the definition of additional
						properties and the specification of constraints on inherited
						properties for the specialized type.
					</p><p>
						An example for inheritance is: when <termref ref="dt-CD">CD</termref> has the property code
						and <termref ref="dt-CS">CS</termref> specializes <termref ref="dt-CD">CD</termref> then
						<termref ref="dt-CS">CS</termref> also has this property code even though isNull
						is not listed explicitly in the property declaration of <termref ref="dt-BL">BL</termref>.
						An example for substitutability is: when a property is declared as of a data
						type <termref ref="dt-CD">CD</termref>, and <termref ref="dt-CS">CS</termref> specializes
						<termref ref="dt-CD">CD</termref>, then a value of such property may be of type
						<termref ref="dt-CS">CS</termref>. In other words, substitutability is the same as
						subsumption of all values of type <termref ref="dt-CS">CS</termref> being also values
						of type <termref ref="dt-CD">CD</termref>.<footnote><p>
								The restriction aspect of specialization deserves explanation. It is
								generally touted that inheritance should not retract properties that
								have been defined for the genus. This is still true for the
								restriction as properties are not actually retracted but constrained
								to a smaller value set. This may mean constraining properties to NULL,
								if NULL was an allowed value for that property in the parent type. In
								any case, logically, restriction is a specialization, with inheritance
								and substitutability.
							</p></footnote></p><!--
					<p>
						An example of substitution used throughout
					</p>
  --><p>
						The <emph role="strong">type</emph>-declaration may be qualified by
						the keyword <emph role="strong">abstract</emph>, <emph role="strong">protected.</emph>, or <emph role="strong">private</emph>. An abstract type is a type where no
						value can be just of this type without belonging to a concrete
						specialization of the abstract. A protected type is a type that is
						used inside this specification but no property outside this
						specification should be declared of a protected type. A private type
						is an internal "helper" abstraction, defined only for the purpose of
						defining some aspect of the semantics of deata types but that is not
						used even as the type of another protected or public type's
						property.<footnote><p>
								Note the meaning of protected is a little different from the
								accessibility qualifiers (public, package, protected, private) as
								known from JAVA and C++. The protection used here is not about hiding
								the type information or barring properties defined by a protected type
								from access outside of this specification "package."  It mainly is a
								strong recommendation not to declare attributes or other features of
								such protected types. Protected types should be used as "wrapped" in
								other types. The protected type is still directly accessible within
								the "wrap," no notion of "delegated properties" exists.
							</p></footnote>
						(We also use the qualifier <emph role="strong">private</emph> at one
						point. Private types are only specified for the sake of formal
						definition of other types and are not used in any form outside this
						specification.)
					</p></div3><div3><head>Invariant Statements</head><p>
						The declaration of semantic properties, their names, data types, and
						arguments provide only clues as to what the new data type might be
						about. The true definition lies in the invariant statements. Invariant
						statements are logical statements that are true at all times.
					</p><p>
						Throughout this specification, invariant statements are provided in a
						formal syntax but are also written in plain English. The advantage of
						the formal syntax is that it can be interpreted unambiguously, and
						that it is strongly typed. The advantage of plain English statements
						is that they are more understandable, especially to those untrained in
						reading formal languages.
					</p><p>
						The formal syntax does help to sharpen the decisiveness of this
						specification. In some cases, however, the full semantics of a type
						are beyond what can be fully expressed in such invariant
						statements. The combination of both plain and formal language helps to
						make this specification more clear.
					</p><p>
						Invariant statements are formed using the 
						<emph role="strong">invariant</emph> keyword that declares one or more
						variables in the same form as an argument list of a property. The
						invariant statement can contain a <emph role="strong">where</emph>
						clause that constrains the arguments for the entire invariant
						body. The invariant body is enclosed in curly braces. It contains a
						list of assertions that must all be true.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(BL x)
      where x.nonNull {
   x.and(true).equal(x);
};</pre></exhibit><p>
						The semantics of the invariant statement is a logic predicate with a
						universal quantifier ("for all").
					</p><p>
						The above invariant statement can be read in English as "For all
						Boolean values x, where x is non-NULL it holds that x AND
						<emph>true</emph> equals x."  All properties should be named such that
						one can read the assertions like English sentences.<footnote><p>
								The invariant statement syntax and semantics is similar to the OCL
								"inv" clause. However, we did not use OCL in this specification for
								several reasons. (1) OCL syntax has a Smalltalk style that does not
								fit the C++/Java style of the data type definition language. (2) OCL
								has many primitive constructs and data types, while this specification
								avoids primitives as much as possible. (3) In part because of the
								richness in primitive constructs, OCL is fairly complex, more than is
								needed in this specification.
							</p></footnote></p><p>
						The argument list of an invariant statement need not be specified if no such 
						argument is needed.
					</p><exhibit role="dtdl"><caption/><pre>
invariant {
   true.not.equal(false);
   false.not.equal(true);
};</pre></exhibit><div4><head>Assertion Expressions</head><p>
							Assertions in invariant statements are expressions built with the
							semantic properties of defined data types. Assertion expressions must
							have a Boolean value (<emph>true</emph> or
							<emph>false</emph>.)<footnote><p>
									This construct is somewhat cyclical; there is a preexisting notion of
									Boolean values even though the Boolean is a type defined just like any
									other type. In addition, since this data type definition language is
									written in character strings, the notion of character strings
									pre-exists the definition of the character string type. These two
									types, character string and Boolean are therefore exceptional, but on
									the surface, they are defined just like any other data type. Since
									this data type specification language is not meant to be implemented,
									the cyclicality is not a real issue. Even if this language was
									implemented, one can use a "bootstrapping" technique as is common,
									e.g., for compilers that compile themselves.
								</p></footnote>
							No primitive data types, or operations, pre-exist the definition of
							any data type. The only preexisting features of the assertion
							expression language are:<footnote><p>
									Most of these syntactic features are in the spirit of the JAVA
									language, use of argument lists, curly braces to enclose blocks,
									semicolon to finish a statement, and the period to reference value
									properties. The double colon :: as used by C++ or IDL to distinguish
									between member-references and value-references are not used (as in
									Java). Unlike Java but like C++ and IDL, every statement is ended by a
									semicolon, including type declarations. Implicit type conversion is
									also retained from C++.
								</p></footnote></p><list role="unordered"><item>
								character strings representing utterances in the data type definition
								language;
							</item><item>
								the notion of an assertion being successful (<emph>true</emph>) or
								failing (<emph>false</emph>);
							</item><item>
								the invariant statement: <emph role="strong">invariant</emph>(...)
								<emph role="strong">where</emph> ... {...};
							</item><item>
								the universal quantifier expression form <emph role="strong">forall</emph>
								(...) <emph role="strong">where</emph>
								... {...}; synonymous to the invariant statement;
							</item><item>
								the existence quantifier expression form <emph role="strong">exists</emph>
								(...) <emph role="strong">where</emph>
								... {...};
							</item><item>
								the implicit conjunction (logical AND) between the semicolon-separated
								<emph>assertions</emph>: <emph>assertion</emph><emph role="sub">1</emph>; <emph>assertion</emph><emph role="sub">2</emph>; ... ; <emph>assertion</emph><emph role="sub">n</emph>;
							</item><item>
								variables and declarations in the invariant argument list;
							</item><item>
								the property reference using the period: <emph>x.property</emph>;
							</item><item>
								implicit and explicit type conversion: <emph role="strong">(</emph><emph>T</emph><emph role="strong">)</emph><emph>x</emph>;
							</item><item>
								parentheses to override the priorities of the conversion and property
								resolution operators: (<emph>T</emph>)<emph>x.property</emph>
								versus((<emph>T</emph>)<emph>x</emph>)<emph>.property</emph>.
							</item></list></div4><div4><head>Nested Quantifier Expressions</head><p>
							Within assertion expressions, nested quantifier statements can be
							formed similar to invariant statements. In fact, the universal
							quantifier built using the <emph role="strong">forall</emph> keyword
							is the same as the invariant statement. The universal quantifier can
							be used in a nested expression when the complexity of the problem
							requires it, such as in the following example:
						</p><exhibit role="dtdl"><caption/><pre>
invariant(SET&lt;T&gt; x, y)
      where x.nonNull {
   x.subset(y).equal(
      forall(T element) where x.contains(element) {
         y.contains(element);
         });
};</pre></exhibit><p>
							The existence quantifier has the meaning as in common propositional
							logic. For example, the following invariant means: "SET values
							<emph>x</emph> and <emph>y</emph> intersect if and only if there
							exists an element <emph>e</emph> that is contained in both sets
							<emph>x</emph> and <emph>y</emph>."
						</p><exhibit role="dtdl"><caption/><pre>
invariant(SET x, y)
      where x.nonNull {
   x.intersects(y).equal(
      exists(T e) {
         x.contains(e);
         y.contains(e);
         });
};</pre></exhibit><p>
							The existence quantifier may have a where-clause; however, there is no
							difference whether an assertion is made as a where-clause or in the
							body of the existence quantifier. Conversely, for universal
							quantifiers, the where-clause weakens the assertion since the body now
							only applies for values that meet the criterion in the where-clause.
						</p></div4></div3><div3><head>Type Conversion</head><p>
						This specification defines certain allowable conversions between data
						types. For example, there is a pair of conversions between the
						Character String (<termref ref="dt-ST">ST</termref>) and Encode Data (<termref ref="dt-ED">ED</termref>). 
						This means that if a one expects an <termref ref="dt-ED">ED</termref>
						value but actually has an <termref ref="dt-ST">ST</termref> value instead, one can
						turn the <termref ref="dt-ST">ST</termref> value into an <termref ref="dt-ED">ED</termref>.<footnote><p>
								This means that if a one expects an <termref ref="dt-ED">ED</termref> value but
								actually has an <termref ref="dt-ST">ST</termref> value instead, one can turn the
								<termref ref="dt-ST">ST</termref> value into an <termref ref="dt-ED">ED</termref>.
							</p></footnote></p><p>
						Three kinds of type conversions are defined: promotion, demotion, and
						character string literals. Type conversions can be implicit or
						explicit. Implicit type conversion occurs when a certain type is
						expected (e.g. as an argument to a statement) but a different type is
						actually provided. If the type provided has a conversion to the type
						expected the conversion should be done implicitly.
					</p><note role="its"><p>
							An Implementation Technology Specification will have to specify how
							implicit type conversions are supported. Some technologies support it
							directly others do not; in any case, processing rules can be set that
							specify how these conversions are realized.
						</p></note><p>
						An explicit conversion can be specified in an assertion expression
						using the converted-to type name in parenthesis before the converted
						value. For example the following is an explicit type conversion in the
						where clause of an invariant statement.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(ED x)
   where ((ST)x).nonNull { ... };</pre></exhibit><p>
						The type conversion has lower priority than the property resolution
						period. Thus "(<emph>T</emph>)a.<emph>b</emph> " converts the value of
						the property <emph>b</emph> of variable a to data type <emph>T</emph>
						while "((<emph>T</emph>)a).<emph>b</emph> " converts the value of
						variable a to <emph>T</emph> and then references property
						<emph>b</emph> of that converted value.
					</p><p>
						Implicit type conversions in the assertion expressions are performed
						where possible. If a property's formal argument is declared of data
						type <emph>T</emph>; but the expression used as an actual argument is
						of type <emph>U</emph>; and if <emph>U</emph> does not extend
						<emph>T</emph>; and if <emph>U</emph> defines a conversion to
						<emph>T</emph>, that conversion from <emph>T</emph> to <emph>U</emph>
						takes effect.
					</p><div4><head>Demotion</head><p>
							A demotion is a conversion with a net loss of information. Generally,
							this means that a more complex type is converted into a simple type.
						</p><p>
							An example for a demotion is the conversion from Interval 
							(<termref ref="dt-IVL">IVL</termref>) to a simple Quantity (<termref ref="dt-QTY">QTY</termref>), e.g. the
							center of the interval. In the data type definition language, a
							demotion is declared using the keyword <emph role="strong">demotion</emph> 
							and the data type name to which to demote:
						</p><exhibit role="dtdl"><caption/><pre>
type Interval alias IVL {
   ...
   demotion  QTY;
   ...
};</pre></exhibit><p>
							The specification of demotions shall indicate what information is lost
							and what the major consequences of losing this information are.
						</p></div4><div4><head>Promotion</head><p>
							A promotion is a conversion where new information is
							generated. Generally, this means that a simpler type is converted into
							a more complex type.
						</p><p>
							For example, we allow any Quantity (<termref ref="dt-QTY">QTY</termref>) to be
							converted to an Interval (<termref ref="dt-IVL">IVL</termref>). However, 
							<termref ref="dt-IVL">IVL</termref> has more semantic properties than
							<termref ref="dt-QTY">QTY</termref>, low
							and high boundary. Thus, the conversion of <termref ref="dt-QTY">QTY</termref> to
							<termref ref="dt-IVL">IVL</termref> is a promotion. The additional properties of 
							<termref ref="dt-QTY">QTY</termref> not present in <termref ref="dt-IVL">IVL</termref> must assume new 
							values, default values, or computed values. The specification of the promotion
							must indicate what these values are or how they can be generated.
						</p><p>
							A promoting conversion from type <termref ref="dt-QTY">QTY</termref> to type 
							<termref ref="dt-IVL">IVL</termref> is defined as a semantic property of data type 
							<termref ref="dt-QTY">QTY</termref> using the keyword promotion and the data type name to
							which to promote:
						</p><exhibit role="dtdl"><caption/><pre>
type Quantity alias QTY {
   ...
   promotion  IVL;
   ...
};</pre></exhibit><p>
							Typically, a promotion is defined from a simple type to a more complex
							type. Also typically, the simple type is declared earlier in this
							document than a more complex type. Declaring all promotions to complex
							types in the simple type would thus involve forward references and
							would be confusing to the reader. Therefore, an alternative syntax
							allows promotions to be defined in the more complex type. This is
							indicated by naming the type from which to promote in an argument list
							behind the type to which to promote.
						</p><exhibit role="dtdl"><caption/><pre>
type Interval alias IVL {
   ...
   promotion  IVL (QTY x);
   ...
};</pre></exhibit></div4></div3><div3 id="literalFormIntro"><head>Literal Form</head><p>
						A literal is a character string representation of a data
						value. Literals are defined for many types. A literal is a type
						conversion from and to a Character String (<termref ref="dt-ST">ST</termref>) with a
						specially defined syntax.
					</p><p>
						Not every conversion from and to an <termref ref="dt-ST">ST</termref> is a literal
						conversion, however. A literal for a data type should be able to
						represent the entire value set of a data type whereas any other
						conversion to and from <termref ref="dt-ST">ST</termref> may only map a smaller subset
						of the converted data type.
					</p><p>
						The purpose of having literals is so that one can write down values in
						a short human readable form. For example, literals for the types
						integer number (<termref ref="dt-INT">INT</termref>) and real number 
						(<termref ref="dt-REAL">REAL</termref>) are strings of sign, digits, possibly a decimal
						point, etc. The more important interval types 
						(<termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-REAL">REAL</termref>&gt;,
						<termref ref="dt-IVL_PQ">IVL&lt;PQ&gt;</termref>, <termref ref="dt-IVL_TS">IVL&lt;TS&gt;</termref>)
						have literal representations that allow one to use, e.g., "&lt;5" to
						mean "less than 5", which is much more readable than a fully
						structured form of the interval. For some of the more advanced data
						types such as intervals, general timing specification, and parametric
						probability distribution we expect that the literal form may be the
						only form seen for representing these values until users have become
						used to the underlying conceptualizations.
					</p><p>
						Each literal conversion has its own syntax (grammar,) often aligned
						with what people find intuitive. This syntax may therefore not be
						completely straightforward from a computer's perspective.<footnote><p>
								The different grammars of literals are not meant to be combined into
								one overall HL7 value expression grammar. Although attempt have been
								made to resolve potential ambiguities between the literals of
								different types where they would be harmful, some of these ambiguities
								still remain. For example "1.2" can be a valid literal for both Object
								Identifier (<termref ref="dt-OID">OID</termref>) and a Real Number.
							</p></footnote></p><note role="its"><p>
							Character string based Implementable Technology Specifications (ITS)
							of these abstract data types may or may not choose the literals
							defined here as their representations for these data types. We expect
							that the XML ITS, will use some but not all of the literals defined
							here.
						</p></note><div4><head>Declaration</head><p>
							In the data type definition language we declare a literal form as a
							property of a data type using the keyword literal followed by the data
							type name <termref ref="dt-ST">ST</termref>, since the literal is a conversion to and
							from the <termref ref="dt-ST">ST</termref> data type.
						</p><exhibit role="dtdl"><caption/><pre>
type IntegerNumber alias INT {
   ...
   literal  ST;
   ...
};</pre></exhibit></div4><div4><head>Definition</head><p>
							The actual definition of the literal form occurs outside the data type 
							declaration body using an attribute grammar. An attribute grammar is a grammar 
							that specifies both syntax and semantics of language structures. The syntax is 
							defined in essentially the Backus-Naur-Form (BNF).<footnote><p>
									The BNF variant used here is similar to the YACC parser and LEX lexical
									analyzer generator languages but is simplified and made consistent to the 
									syntax and declarative style of this data type definition language. The 
									differences are that all symbols have exactly one attribute, their value 
									strongly typed as one of the defined data types. Each symbol's type is 
									declared in front of the symbol's definition (e.g.: INT digit : "0" | "1" | 
									... | "9";). The start symbol has no name but just a type (e.g., INT : digit |
									INT digit;). A data type name can occur as a symbol name meaning a literal of 
									that data type.
								</p></footnote></p><p>
							For example, consider the following simple definition of a data type
							for cardinal numbers (positive integers.)  This type definition
							depends only the Boolean data type (<termref ref="dt-BL">BL</termref>) and has a
							character string literal declared:
						</p><exhibit role="dtdl"><caption/><pre>
type CardinalNumber alias CARD {
   BL       isZero;
   BL       equal(ANY x);
   CARD     successor;
   CARD     plus(CARD x);
   CARD     timesTen;
   literal  ST;
};</pre></exhibit><!-- Converted to bullet item from fifth-level heading --><!-- pvb: 20050804: list removed completely
						<list role="unordered">
							<item>
								Syntax Definition
							</item>
						</list>
   --><p>
							The literal syntax and semantics is first exposed completely and then
							described in all detail.
						</p><exhibit role="dtdl"><caption/><pre>
CARD.literal ST {
   CARD : CARD digit  { $.equal($1.timesTen.plus($2); }
        | digit       { $.equal($1); };

   CARD digit : "0"   { $.isZero; }
              | "1"   { $.equal(0.successor); }
              | "2"   { $.equal(1.successor); }
   ...
              | "8"   { $.equal(7.successor); }
              | "9"   { $.equal(8.successor); }
};</pre></exhibit><p>
							Every syntactic rule consists of the name of a symbol, a colon and the
							definition (so called <emph>production</emph>) of the symbol. A
							production is a sequence of symbols. These other symbols are also
							defined in the grammar, or they are terminal symbols. Terminal symbols
							are character strings written in double quotes or string patterns
							(called <emph>regular expressions</emph>.)  Thus the form:
						</p><exhibit role="dtdl"><caption/><pre>
CARD : CARD digit
     | digit;</pre></exhibit><p>
							means, that any cardinal number symbol is a cardinal number symbol
							followed by a digit or just a digit. The vertical bar stands for a
							disjunction (logical OR.)  A syntactic rule ends with a semicolon.
						</p><p>
							Every symbol has exactly one value of a defined data type. The data
							type of the symbol's value is declared where the symbol is defined:
						</p><exhibit role="dtdl"><caption/><pre>
CARD digit : "0"
           | "1"
           | "2"
           | ...
           | "8"
           | "9";</pre></exhibit><p>
							means that the symbol <emph>digits</emph> has a value of type
							CARD. The start-symbol is the data type itself and does not need a
							separate name.
						</p><!-- Converted to bullet item from fifth-level heading --><!-- pvb: 20050804: list removed completely
						<list role="unordered">
							<item>
								Semantics Definition
							</item>
						</list>
  --><p>
							The semantics of the literal expression is specified in semantic rules
							enclosed in curly braces for each of the defined productions of a
							symbol:
						</p><p><emph>symbol</emph><emph role="strong"> : </emph><emph>production</emph><emph role="sub">1</emph><emph role="strong"> { </emph><emph>rule</emph><emph role="sub">1</emph><emph role="strong"> } </emph><emph role="strong"> | </emph><emph>production</emph><emph role="sub">2</emph><emph role="strong"> { </emph><emph>rule</emph><emph role="sub">2</emph><emph role="strong"> } </emph><emph role="strong"> | </emph>
							... <emph role="strong"> | </emph><emph>production</emph><emph role="sub"><emph>n</emph></emph><emph role="strong"> { </emph><emph>rule</emph><emph role="sub"><emph>n</emph></emph><emph role="strong"> };</emph></p><p>
							A semantic rule is simply a semicolon-separated list of Boolean
							assertion expressions of the same kind as those used in invariant
							statements. However, there are special variables defined in the
							semantic rule that all begin with a dollar character (e.g., $, $1, $2,
							$3, ...)  The simple $ stands for the value of the currently defined
							symbol; while $1, $2, $3, etc. stand for the values of the parts of
							the semantic rule's associated production. For example, in
						</p><exhibit role="dtdl"><caption/><pre>
CARD : CARD digit  { $.equal($1.timesTen.plus($2); }
     | digit       { $.equal($1); };</pre></exhibit><p>
							the first production "CARD digit" has a semantic rule that says: the
							value $ of the defined symbol equals the value $1 of the first symbol
							CARD times ten plus the value $2 of the second symbol digit.<footnote><p>
								Note that the equal property (defined for all data types, see
								<termref ref="prop-ANY.equal">equal</termref>) is a relation, a test for equality, not an 
								assignment statement. One can not assign a value to another value. Unlike YACC
								and LEX analyzers, this data type definition language is purely
								declarative it has no concept of assignment. For this reason, the
								grammar rules define both parsing and building literal expressions.
							</p></footnote></p><!-- Converted to bullet item from fifth-level heading --><!-- pvb: 20050804: list removed completely
						<list role="unordered">
							<item>
								Terminal Symbols
							</item>
						</list>
  --><p>
							A terminal symbol can be specified as a string pattern, so-called
							<emph>regular expression</emph>. The regular expression syntax used
							here is the classic syntax invented by Aho and used in AWK, LEX, GREP,
							and PERL. Regular expressions appear between two slashes 
							<emph role="strong">/</emph>...<emph role="strong">/</emph>. In a regular
							expression pattern every character except <emph role="strong">[ ] ^ $
							. / : ( ) \ | ? * + { }</emph> matches itself. The other characters
							that are actually used in this specification are defined in 
							<tabref ref="special-regex-chars"/>.
						</p><table id="special-regex-chars"><caption>Special Characters for Regular Expressions</caption><col width="0.69" span="1"/><col width="5.06" span="1"/><thead><tr><th rowspan="1" colspan="1">Pattern</th><th rowspan="1" colspan="1">Definition</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">[ ... ]</td><td rowspan="1" colspan="1">
										Specifies a character class. For example, /[A-Za-z]/ 
										matches the characters of the upper and lower case English
										alphabet.
									</td></tr><tr><td rowspan="1" colspan="1">[^ ...]</td><td rowspan="1" colspan="1">
										Specifies a character class negatively. For example, 
										/[^BCD]/ matches any character except B, C, and D.
									</td></tr><tr><td rowspan="1" colspan="1">...?</td><td rowspan="1" colspan="1">
										The preceding pattern is optional. For example, /ab?c/ 
										matches  "ac" and "abc".
									</td></tr><tr><td rowspan="1" colspan="1">...*</td><td rowspan="1" colspan="1">
										The preceding pattern may occur zero or many times. For 
										example, /ab*c/ matches  "ac", "abc", "abbc", "abbbc",
										etc.
									</td></tr><tr><td rowspan="1" colspan="1">...+</td><td rowspan="1" colspan="1">
										The preceding pattern may occur one or more times. For 
										example, /ab+c/ matches "abc", "abbc", "abbbc", but not 
										"ac".
									</td></tr><tr><td rowspan="1" colspan="1">... {n,m}</td><td rowspan="1" colspan="1">
										The preceding pattern may occur <emph>n</emph> to 
										<emph>m</emph> times where <emph>n</emph> and <emph>m</emph> 
										are cardinal numbers 0 ( <emph>n</emph> ( <emph>m</emph>. 
										For example, /ab{2,4}c/ matches "abbc", "abbbc", and 
										"abbbbc".
									</td></tr><tr><td rowspan="1" colspan="1">... | ...</td><td rowspan="1" colspan="1">
										The pattern on either side of the bar may match. For 
										example, /ab|cd/ matches "abd" and "acd" but not "abcd".
									</td></tr><tr><td rowspan="1" colspan="1">( ... )</td><td rowspan="1" colspan="1">
										The pattern in parentheses is used as one pattern for 
										the above operators. For example, /a(bc)*/ matches "a", 
										"abc", "abcbc", "abcbcbc", etc.
									</td></tr><tr><td rowspan="1" colspan="1">... : ...</td><td rowspan="1" colspan="1">
										The left pattern matches if followed by the right 
										pattern, but the right pattern is not consumed by a match. 
										For example, /ab:c/ matches "abc" but not "ab", however,
										the value of a symbol thus matched is "ab" and the "c" is 
										left over for the next symbol. The colon is a slight 
										deviation from the conventional slash / but the slash is 
										also conventionally used to enclose the entire pattern and 
										may occur as a character to match - three meanings is one 
										too many.
									</td></tr><tr><td rowspan="1" colspan="1">... \ ...</td><td rowspan="1" colspan="1">
										Matches the following character literally, i.e. escapes
										from any special meaning of that character. For example, 
										/a\+b/ matches "a+b".
									</td></tr><tr><td rowspan="1" colspan="1">... \/ ...</td><td rowspan="1" colspan="1">
										Matches the slash as a character. For example, /a\/bc/ 
										macthes "a/bc".
									</td></tr></tbody></table></div4></div3><div3 id="generics"><head>Generic Data Types</head><p>
						Generic data types are incomplete type definitions. This
						incompleteness is signified by one or more <emph>parameters</emph> to
						the type definition. Usually parameters stand for other types. Using
						parameters, a generic type might declare semantic properties of other
						not fully specified data types. For example, the generic data type
						Interval is declared with a parameter <emph>T</emph> that can stand
						for any Quantity data type (<termref ref="dt-QTY">QTY</termref>). The components
						<emph>low</emph> and <emph>high</emph> are declared as being of type
						<emph>T</emph>.
					</p><exhibit role="dtdl"><caption/><pre>
template&lt;QTY T&gt;
type Interval&lt;T&gt; alias IVL&lt;T&gt; {
   T  low;
   T  high;
};</pre></exhibit><p>
						Instantiating a generic type means completing its definition. For
						example, to instantiate an Interval, one must specify of what base
						<emph>data type</emph> the interval should be. This is done by
						<emph>binding</emph> the parameter <emph>T</emph>. To instantiate an
						Interval of Integer numbers, one would bind the parameter
						<emph>T</emph> to the type Integer. Thus, the incomplete data type
						Interval is completed to the data type <emph>Interval of
						Integer</emph>.
					</p><p>
						For example the following type definition for MyType declares a
						property named "multiplicity" that is an interval of the cardinal
						number data type used in the above examples.
					</p><exhibit role="dtdl"><caption/><pre>
type MyType alias MT {
   IVL&lt;CARD&gt;  multiplicity;
};</pre></exhibit><div4><head>Generic Collections</head><p>
							Generic data types for collections are being used throughout this
							specification. The most important of them are
						</p><p><emph role="strong">Set</emph> (<termref ref="dt-SET">SET</termref>&lt;T&gt;)  A
							set contains elements in no particular order and without duplicate
							elements.
						</p><p><emph role="strong">Sequence</emph> 
							(<termref ref="dt-LIST">LIST</termref>&lt;T&gt;)  A sequence is a collection of
							values in an arbitrary but particular order. A sequence has a head and
							a tail, where the head is an element and the tail is the sequence
							without its head.
						</p><p><emph role="strong">Interval</emph> 
							(<termref ref="dt-IVL">IVL</termref>&lt;T&gt;)  An interval is a continuous subset
							of an ordered type.
						</p><p>
							These and other generic types are fully defined in 
							<specref ref="generics"/>. These generic data types and their
							properties are being used in this specification early on. For the best
							understanding of this specification knowledge about the set, sequence
							and interval is important and the reader is advised to refer to
							<specref ref="generics"/>. when coming across a
							generic type being used to define another type.
						</p></div4><div4><head>Generic Type Extensions</head><p>
							Generic data type extensions are generic types with one parameter type
							that the generic type specializes. In the formal data type definition
							language, generic type specializations follow the pattern:
						</p><exhibit role="dtdl"><caption/><pre>
template&lt;ANY T&gt; type GenericTypeExtensionName specializes T {
   ...
};</pre></exhibit><p>
							These generic type extensions inherit properties of their base type
							and add some specific feature to it. The generic type extension is a
							specialization of the base type, thus a value of the extension data
							type can be used instead of its base data type.<footnote><p>
									Generic type extensions are sometimes called "mixins", since their
									effect is to mix certain properties into the preexisting data type.
								</p></footnote></p><note role="its"><p>
								Values of extended types can be substituted for their base
								type. However, an ITS may make some constraints as to what extensions
								to accommodate. Particularly, extensions need not be defined for those
								components carrying the values of data value properties. Thus, while
								any data value can be annotated outside the data type specification,
								an ITS may not provide for a way to annotate the value of a data value
								property.
							</p></note><graphic source="graphics/dtUML-Basics.gif" alt="Fundamental data types"/></div4></div3></div2><div2><head>Conformance</head><p>
					If an application receives or parses an instance that is not valid with
					regard to this specification, the receiver is permitted to reject the
					instance in whatever fashion it deems appropriate but it is not required
					to. Note that some other HL7 standard or artefact such as a conformance
					statement may make additional constraints on behaviour in such cases.
				</p></div2><div2 id="dt-ANY"><anchor id="ANY"/><head>DataValue (ANY)</head><p><emph role="strong">Definition:</emph>
					Defines the basic properties of every data value. This is an abstract
					type, meaning that no value can be just a data value without belonging
					to any concrete type. Every concrete type is a specialization of this
					general abstract DataValue type.
				</p><exhibit role="dtdl"><caption/><pre>
abstract type DataValue alias ANY {
   TYPE  dataType;
   BN    nonNull;
   CS    nullFlavor;
   BN    isNull;
   BL    notApplicable;
   BL    unknown;
   BL    other;
   BL    equal(ANY x);
};</pre></exhibit><div3 id="prop-ANY.dataType"><head>Data Type : <termref ref="dt-TYPE">TYPE</termref></head><p><emph role="strong">Definition:</emph>
						Represents the fact that every data value implicitly carries
						information about its own data type. Thus, given a data value one can
						inquire about its data type.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(ANY x) {
   x.dataType.nonNull;
};</pre></exhibit></div3><div3 id="prop-ANY.nonNull"><head>Proper Value : <termref ref="dt-BN">BN</termref></head><p><emph role="strong">Definition:</emph>
						Indicates that a value is a non-exceptional value of the data type.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(ANY x) {
   x.isNull.equal(x.nonNull.not);
};</pre></exhibit><p>
						When a property, RIM attribute, or message field is called
						<emph>mandatory</emph> this means that any non-NULL value of the type
						to which the property belongs has a non-NULL value for that
						property, in other words, a field may not be NULL, providing that its
						container (object, segment, etc.) is to have a non-NULL value.
			        </p></div3><div3 id="prop-ANY.isNull"><head>Exceptional Value : <termref ref="dt-BN">BN</termref></head><p><emph role="strong">Definition:</emph>
						Indicates that a value is an exceptional value, or a NULL-value. A
						null value means that the information does not exist, is not
						available or cannot be expressed in the data type's normal value
						set.
					</p><p>
						Every data element has either a proper value or it is
						considered NULL. If (and only if) it is NULL, the <emph>isNull</emph> provides
						more detail as to in what way or why no proper value is supplied.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(ANY x) {
   x.isNull.equal(x.nullFlavor.implies(NI));
};</pre></exhibit></div3><div3 id="prop-ANY.nullFlavor"><head>Exceptional Value Detail : <termref ref="dt-CS">CS</termref></head><p><emph role="strong">Definition:</emph>
						If a value is an exceptional value (NULL-value), this specifies in
						what way and why proper information is missing.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(ANY x) {
   x.nonNull.equal(x.nullFlavor.isNull);
};</pre></exhibit><table id="domain-NullFlavor"><caption>Domain NullFlavor</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><td>NI</td><td>NoInformation</td><td>No information whatsoever can be inferred from this exceptional value.  This is the most general exceptional value.  It is also the default exceptional value.</td></tr><tr valign="top"><td>OTH</td><td>other</td><td>The actual value is not an element in the value domain of a variable.  (e.g., concept not provided by required code system).</td></tr><tr valign="top"><td>NINF</td><td>negative infinity</td><td>Negative infinity of numbers.</td></tr><tr valign="top"><td>PINF</td><td>positive infinity</td><td>Positive infinity of numbers.</td></tr><tr valign="top"><td>UNK</td><td>unknown</td><td>A proper value is applicable, but not known.</td></tr><tr valign="top"><td>ASKU</td><td>asked but unknown</td><td>Information was sought but not found (e.g., patient was asked but didn't know)</td></tr><tr valign="top"><td>NAV</td><td>temporarily unavailable</td><td>Information is not available at this time but it is expected that it will be available later.</td></tr><tr valign="top"><td>NASK</td><td>not asked</td><td>This information has not been sought (e.g., patient was not asked)</td></tr><tr valign="top"><td>TRC</td><td>trace</td><td>The content is greater than zero, but too small to be quantified.</td></tr><tr valign="top"><td>MSK</td><td>masked</td><td>There is information on this item available but it has not been provided by the sender due to security, privacy or other reasons. There may be an alternate mechanism for gaining access to this information.Note: using this null flavor does provide information that may be a breach of confidentiality, even though no detail data is provided.  Its primary purpose is for those circumstances where it is necessary to inform the receiver that the information does exist without providing any detail.</td></tr><tr valign="top"><td>NA</td><td>not applicable</td><td>No proper value is applicable in this context (e.g., last menstrual period for a male).</td></tr><tr valign="top"><td>NP</td><td>not present</td><td>Value is not present in a message.  This is only defined in messages, never in application data!  All values not present in the message must be replaced by the applicable default, or no-information (NI) as the default of all defaults.</td></tr></table><p>
						The null flavors are a general domain extension of all normal data
						types. Note the distinction between value domain of any data type and
						the vocabulary domain of coded data types. A vocabulary domain is a
						value domain for coded values, but not all value domains are
						vocabulary domains.
					</p><p>
						The null flavor "other" is used whenever the actual value is not in
						the required value domain, this may be, for example, when the value
						exceeds some constraints that are defined too restrictive (e.g., age
						less than 100 years.)
					</p><note role="its"><p>
							NULL-flavors are applicable to any property of a data value or a
							higher-level object attribute. Where the difference of null flavors is
							not significant, ITS are not required to represent them. If nothing
							else is noted in this specification, ITS need not represent general
							NULL-flavors for data-value properties.
						</p></note><p>
						Some of these null flavors are associated with named properties that can be
						used as simple predicates for all data values. This is done to
						simplify the formulation of invariants in the remainder of this
						specification.
					</p><p>
						Remember the difference between semantic properties and
						representational "components" of data values. An ITS must only
						represent those components that are needed to <emph>infer</emph> the
						semantic properties. The null-flavor predicates
						<termref ref="prop-ANY.nonNull">nonNull</termref>,
						<termref ref="prop-ANY.isNull">isNull</termref>, <termref ref="prop-ANY.notApplicable">notApplicable</termref>,
						<termref ref="prop-ANY.unknown">unknown</termref>, and
						<termref ref="prop-ANY.other">other</termref> can all be inferred from the <emph>nullFlavor</emph>
						property.
					</p></div3><div3 id="prop-ANY.notApplicable"><head>Inapplicable Proper Value : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph>
						A predicate indicating that this exceptional value is of
						<termref ref="prop-ANY.nullFlavor">nullFlavor</termref> not-applicable (NA), i.e., that a proper
						value is not meaningful in the given context.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(ANY x) {
   x.notApplicable.equal(x.nullFlavor.implies(NA));
};</pre></exhibit></div3><div3 id="prop-ANY.unknown"><head>unknown : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph>
						A predicate indicating that this exceptional value is of
						<termref ref="prop-ANY.nullFlavor">nullFlavor</termref> unknown (UNK).
        			</p><exhibit role="dtdl"><caption/><pre>
invariant(ANY x) {
   x.unknown.equal(x.nullFlavor.implies(UNK));
};</pre></exhibit></div3><div3 id="prop-ANY.other"><head>Value Domain Exception : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph>
						A predicate indicating that this exceptional value is of
						<termref ref="prop-ANY.nullFlavor">nullFlavor</termref> other (OTH), i.e., that the required
						value domain does not contain the appropriate value.
			        </p><exhibit role="dtdl"><caption/><pre>
invariant(ANY x) {
   x.other.equal(x.nullFlavor.implies(OTH));
};</pre></exhibit></div3><div3 id="prop-ANY.equal"><head>Equality : <termref ref="dt-BL">BL</termref></head><argument name="x" type="ANY"/><p><emph role="strong">Definition:</emph>
						Equality is a reflexive, symmetric, and transitive relation between
						any two data values. Only proper values can be equal, null values
						never are equal (even if they have the same null flavor.)
			        </p><exhibit role="dtdl"><caption/><pre>
invariant(ANY x, y, z)
      where x.nonNull.and(y.nonNull).and(z.nonNull) {
   x.equal(x);                                         /* reflexivity */
   x.equal(y).equal(y.equal(x));                       /* symmetry */
   x.equal(y).and(y.equal(z)).implies(x.equal(z))      /* transitivity */
   x.equal(y).implies(x.dataType.equal(y.dataType);
};</pre></exhibit><p>
						How equality is determined must be defined for each data type. If
						nothing else is specified, two data values are equal if they are
						indistinguishable, that is, if they differ in none of their semantic
						properties. A data type can "override" this general definition of
						equality, by specifying its own equal relationship. This overriding
						of the equality relation can be used to exclude semantic properties
						from the equality test. If a data type excludes semantic properties
						from its definition of equality, this implies that certain properties
						(or aspects of properties) that are not part of the equality test are
						not essential to the meaning of the value.
					</p><p>
						For example the physical quantity has the two semantic properties (1)
						a real number and (2) a coded unit of measure. The equality test,
						however, must account for the fact that, e.g., 1 meter equals 100
						centimeters; independent equality of the two semantic properties is
						too strong a criterion for the equality test. Therefore, physical
						quantity must override the equality definition.
					</p><!-- This dropped after membership ballot #1 on the grounds that it's
     not actually true - the meaning of equals is redefined for several types.
     GDG intends to revisit this subject later
					<note>
						<p>
							With data values, no distinction exists between equality and
							identity. Equality is a static property between two values, and values
							never change.
						</p>
					</note>
   --></div3></div2><div2 id="dt-TYPE"><anchor id="TYPE"/><head>DataType (TYPE) specializes <termref ref="dt-ANY">ANY</termref></head><p><emph role="strong">Definition:</emph>
					A meta-type declared in order to allow the formal definitions to speak
					about the data type of a value. Any data type defined in this
					specification is a value of the type DataType.
				</p><exhibit role="dtdl"><caption/><pre>
private type DataType alias TYPE specializes DataValue {
   CS  shortName;
   CS  longName;
   BN  implies(TYPE that);
};</pre></exhibit><div3 id="prop-DataType.shortName"><head>Short Name : <termref ref="dt-CS">CS</termref></head><p><emph role="strong">Definition:</emph>
						A <termref ref="dt-CS">CS</termref> specifying the alias of the data type.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(DataType x)
      where x.nonNull {
   x.shortName.nonNull;
};</pre></exhibit></div3><div3 id="prop-DataType.longName"><head>Long Name : <termref ref="dt-CS">CS</termref></head><p><emph role="strong">Definition:</emph>
						A <termref ref="dt-CS">CS</termref> specifying the full name of the data type.
					</p></div3><div3 id="prop-DataType.implies"><head>Implies : <termref ref="dt-BN">BN</termref></head><p><emph role="strong">Definition:</emph>
						A data type implies another data type if it has the same type or is
						a specialisation of it.
					</p></div3></div2></div1>
				<div1 id="datyp2bastyp"  ballotStatus="NormativeStandard"><head>Basic Types</head><div2 id="dt-BL"><anchor id="BL"/><head>Boolean (BL) specializes <termref ref="dt-ANY">ANY</termref></head><p><emph role="strong">Definition:</emph><emph>BL</emph> stands for the values of two-valued logic. A <emph>BL</emph>
					value can be either <emph>true</emph> or <emph>false</emph>, or, as
					any other value may be NULL.
				</p><exhibit role="dtdl" id="dtdl-BL"><anchor id="dtdl-BL"/><caption/><pre>
type Boolean alias BL specializes ANY
   values(true, false) {
            BL  and(BL x);
            BL  not;
   literal  ST;
            BL  or(BL x);
            BL  xor(BL x);
            BL  implies(BL x);
};</pre></exhibit><p>
					With any data value potentially being NULL, the two-valued logic is
					effectively extended to a three-valued logic as shown in the following
					truth tables:
				</p><table id="BL-truth-tables" borders="0"><caption>Truth tables for Boolean logic with NULL values</caption><col width="0.45" span="1"/><col width="0.45" span="1"/><col width="0.45" span="1"/><col width="0.45" span="1"/><col width="0.45" span="1"/><col width="0.45" span="1"/><col width="0.45" span="1"/><col width="0.45" span="1"/><col width="0.45" span="1"/><col width="0.45" span="1"/><col width="0.45" span="1"/><col width="0.45" span="1"/><thead><tr><!-- NOT --><th rowspan="1" colspan="1">NOT</th><th rowspan="1" colspan="1"></th><th rowspan="1" colspan="1"/><!-- AND --><th rowspan="1" colspan="1">AND</th><th rowspan="1" colspan="1">true</th><th rowspan="1" colspan="1">false</th><th rowspan="1" colspan="1">NULL</th><th rowspan="1" colspan="1"/><!-- OR  --><th rowspan="1" colspan="1">OR</th><th rowspan="1" colspan="1">true</th><th rowspan="1" colspan="1">false</th><th rowspan="1" colspan="1">NULL</th></tr></thead><tbody><tr><!-- NOT --><th rowspan="1" colspan="1">true</th><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1"/><!-- AND --><th rowspan="1" colspan="1">true</th><td rowspan="1" colspan="1">true</td><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">NULL</td><td rowspan="1" colspan="1"/><!-- OR  --><th rowspan="1" colspan="1">true</th><td rowspan="1" colspan="1">true</td><td rowspan="1" colspan="1">true</td><td rowspan="1" colspan="1">true</td></tr><tr><!-- NOT --><th rowspan="1" colspan="1">false</th><td rowspan="1" colspan="1">true</td><td rowspan="1" colspan="1"/><!-- AND --><th rowspan="1" colspan="1">false</th><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1"/><!-- OR  --><th rowspan="1" colspan="1">false</th><td rowspan="1" colspan="1">true</td><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">NULL</td></tr><tr><!-- NOT --><th rowspan="1" colspan="1">NULL</th><td rowspan="1" colspan="1">NULL</td><td rowspan="1" colspan="1"/><!-- AND --><th rowspan="1" colspan="1">NULL</th><td rowspan="1" colspan="1">NULL</td><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">NULL</td><td rowspan="1" colspan="1"/><!-- OR  --><th rowspan="1" colspan="1">NULL</th><td rowspan="1" colspan="1">true</td><td rowspan="1" colspan="1">NULL</td><td rowspan="1" colspan="1">NULL</td></tr></tbody></table><p>
					Where a boolean operation is performed upon 2 data types with different
					nullFlavors, the nullFlavor of the result is the first common ancestor
					of the 2 different nullFlavors, though conformant applications may also
					create a result that is any common ancestor
				</p><div3 id="prop-BL.not"><head>Negation : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph>
						Negation of a <emph>BL</emph> turns <emph>true</emph> into <emph>false</emph>
						and <emph>false</emph> into <emph>true</emph> and is NULL for NULL
						values.
					</p><exhibit role="dtdl" id="dtdl-BL.not"><anchor id="dtdl-BL.not"/><caption/><pre>
invariant(BL x) {
   true.not.equal(false);
   false.not.equal(true);
   x.isNull.equal(x.not.isNull);
};</pre></exhibit></div3><div3 id="prop-BL.and"><head>Conjunction : <termref ref="dt-BL">BL</termref></head><argument name="x" type="BL"/><p><emph role="strong">Definition:</emph>
						Conjunction (AND) is associative and commutative, with
						<emph>true</emph> as a neutral element. <emph>False</emph> AND any
						Boolean value is <emph>false</emph>. These rules hold even if one or
						both of the operands are NULL. If both operands for AND are NULL,
						the result is NULL.
					</p><exhibit role="dtdl" id="dtdl-BL.and"><anchor id="dtdl-BL.and"/><caption/><pre>
invariant(BL x) {
   x.and(true).equal(x);
   x.and(false).equal(false);
   x.isNull.implies(x.and(y).isNull);
};</pre></exhibit></div3><div3 id="prop-BL.or"><head>Disjunction : <termref ref="dt-BL">BL</termref></head><argument name="x" type="BL"/><p><emph role="strong">Definition:</emph>
						The disjunction <emph>x</emph> OR <emph>y</emph> is <emph>false</emph>
						if and only if <emph>x</emph> is <emph>false</emph> and <emph>y</emph>
						is <emph>false</emph>.
					</p><exhibit role="dtdl" id="dtdl-BL.or"><anchor id="dtdl-BL.or"/><caption/><pre>
invariant(BL x, y) {
   x.or(y).equal(x.not.and(y.not).not);
};</pre></exhibit></div3><div3 id="prop-BL.xor"><head>Exclusive Disjunction : <termref ref="dt-BL">BL</termref></head><argument name="x" type="BL"/><p><emph role="strong">Definition:</emph>
						The exclusive-OR constrains OR such that the two operands may not both
						be <emph>true</emph>.
					</p><exhibit role="dtdl" id="dtdl-BL.xor"><anchor id="dtdl-BL.xor"/><caption/><pre>
invariant(BL x, y) {
   x.xor(y).equal(x.or(y).and(x.and(y).not));
};</pre></exhibit></div3><div3 id="prop-BL.implies"><head>Implication : <termref ref="dt-BL">BL</termref></head><argument name="x" type="BL"/><p><emph role="strong">Definition:</emph>
						A rule of the form IF <emph>condition</emph> THEN
						<emph>conclusion</emph>. Logically the implication is defined as the
						disjunction of the negated condition and the conclusion, meaning that
						when the condition is <emph>true</emph> the conclusion must be
						<emph>true</emph> to make the overall statement <emph>true</emph>.
						The logical implication is important to make invariant statements. 
					</p><exhibit role="dtdl" id="dtdl-BL.implies"><anchor id="dtdl-BL.implies"/><caption/><pre>
invariant(BL condition, conclusion) {
   condition.implies(conclusion).equal(
      condition.not.or(conclusion));
};</pre></exhibit><p>
						The implication is not reversible and does not specify what is
						<emph>true</emph> when the condition is <emph>false</emph> (<emph>ex
						falso quodlibet</emph> lat. &#8220;from false follows anything&#8221;).
					</p></div3><div3 id="prop-BL.literal"><head>Literal Form</head><p>
						The literal form of the Boolean is determined by the named values
						specified in the values clause, i.e., <emph>true</emph> and
						<emph>false</emph>.
					</p></div3></div2><div2 id="dt-BN"><anchor id="BN"/><head>BooleanNonNull (BN) specializes <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph><emph>BN</emph> constrains the boolean type so that the value may not be NULL.
					This type is created for use within the data types specification where it is not
					appropriate for a null value to be used
				</p><exhibit role="dtdl" id="dtdl-BN"><anchor id="dtdl-BN"/><caption/><pre>
private type BooleanNonNull alias BN specializes BL;
};</pre></exhibit><div3 id="prop-BN.isNull"><head>isNull : <termref ref="dt-BN">BN</termref></head><exhibit role="dtdl"><caption/><pre>
invariant (BN x) {
   x.isNull.not
};</pre></exhibit></div3></div2><graphic source="graphics/dtUML-Text.gif" alt="Overview of Text and Multimedia Data Types"/><div2 id="dt-BIN"><anchor id="BIN"/><head>Binary Data (BIN) specializes <termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-BN">BN</termref>&gt;</head><p><emph role="strong">Definition:</emph><emph>BIN</emph> is a raw block of bits. <emph>BIN</emph> is a protected
					type that should not be declared outside the data type specification.
				</p><p>
					A bit is semantically identical with a non-null <termref ref="dt-BL">BL</termref> value. Thus,
					all binary data is &#8212; semantically &#8212; a sequence of non-null
					<termref ref="dt-BL">BL</termref> values.
				</p><exhibit role="dtdl" id="dtdl-BIN"><anchor id="dtdl-BIN"/><caption/><pre>
protected type BinaryData alias BIN specializes LIST&lt;BN&gt;;</pre></exhibit><note role="ITS"><p>
						The representation of arbitrary binary data is the responsibility of
						an ITS. How the ITS accomplishes this depends on the underlying
						Implementation Technology (whether it is character-based or binary)
						and on the represented data. Semantically character data is
						represented as binary data, however, a character-based ITS should not
						convert character data into arbitrary binary data and then represent
						binary data in a character encoding. Ultimately even character-based
						implementation technology will communicate binary data.
					</p></note><p>
						An empty sequence is not considered binary data but counts as a
						NULL-value. In other words, non-NULL binary data contains at least one
						bit. No bit in a non-NULL binary data value can be NULL.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(BIN x)
      where x.nonNull {
   x.notEmpty;
   x.length.greaterThan(0);
};</pre></exhibit></div2><div2 id="dt-ED"><anchor id="ED"/><head>Encapsulated Data (ED) specializes <termref ref="dt-BIN">BIN</termref></head><p><emph role="strong">Definition:</emph>
					Data that is primarily intended for human interpretation or for
					further machine processing outside the scope of HL7. This includes
					unformatted or formatted written language, multimedia data, or
					structured information in as defined by a different standard (e.g.,
					XML-signatures.)  Instead of the data itself, an <emph>ED</emph>
					may contain only a reference (see <termref ref="dt-TEL">TEL</termref>.) Note that
					<termref ref="dt-ST">ST</termref> is a specialization of the
					<emph>ED</emph> where the <termref ref="prop-ED.mediaType">mediaType</termref> is fixed to text/plain.
				</p><table id="dt-ED-prop-summary"><caption>Property Summary of
      Encapsulated Data</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-ED.mediaType">mediaType</termref></td><td><termref ref="dt-CS">CS</termref></td><td>
						Identifies the type of the encapsulated data and identifies a
						method to interpret or render the data.
					</td></tr><tr><td><termref ref="prop-ED.charset">charset</termref></td><td><termref ref="dt-CS">CS</termref></td><td>
						For character-based encoding types, this property specifies the
						character set and character encoding used. The charset shall be
						identified by an Internet Assigned Numbers Authority (IANA) 
						Charset Registration [<loc href="http://www.iana.org/assignments/character-sets" xlink-form="simple" show="embed" actuate="auto"/>] 
						in accordance with RFC 2978 [<loc href="http://www.ietf.org/rfc/rfc2978.txt" xlink-form="simple" show="embed" actuate="auto"/>].
					</td></tr><tr><td><termref ref="prop-ED.language">language</termref></td><td><termref ref="dt-CS">CS</termref></td><td>
						For character based information the language property specifies the
						human language of the text.
					</td></tr><tr><td><termref ref="prop-ED.compression">compression</termref></td><td><termref ref="dt-CS">CS</termref></td><td>
						Indicates whether the raw byte data is compressed, and what
						compression algorithm was used.
					</td></tr><tr><td><termref ref="prop-ED.reference">reference</termref></td><td><termref ref="dt-TEL">TEL</termref></td><td>
						A telecommunication address (<termref ref="dt-TEL">TEL</termref>), such as a URL for HTTP or FTP,
						which will resolve to precisely the same binary data that could as
						well have been provided as inline data.
					</td></tr><tr><td><termref ref="prop-ED.integrityCheck">integrityCheck</termref></td><td><termref ref="dt-BIN">BIN</termref></td><td>
						The integrity check is a short binary value representing a
						cryptographically strong checksum that is calculated over the binary
						data. The purpose of this property, when communicated with a reference
						is for anyone to validate later whether the reference still resolved
						to the same data that the reference resolved to when the encapsulated
						data value with reference was created.
					</td></tr><tr><td><termref ref="prop-ED.integrityCheckAlgorithm">integrityCheckAlgorithm</termref></td><td><termref ref="dt-CS">CS</termref></td><td>
						Specifies the algorithm used to compute the integrityCheck
						value.<footnote><p>
								The cryptographically strong checksum algorithm Secure Hash
								Algorithm-1 (SHA-1) is currently the industry standard. It has
								superseded the MD5 algorithm only a couple of years ago, when certain
								flaws in the security of MD5 were discovered. Currently the SHA-1 hash
								algorithm is the default choice for the integrity check algorithm.
								Note that SHA-256 is also entering widespread usage.
							</p></footnote></td></tr><tr><td><termref ref="prop-ED.thumbnail">thumbnail</termref></td><td><termref ref="dt-ED">ED</termref></td><td>
						An abbreviated rendition of the full data. A thumbnail requires
						significantly fewer resources than the full data, while still
						maintaining some distinctive similarity with the full data. A
						thumbnail is typically used with by-reference encapsulated data. It
						allows a user to select data more efficiently before actually
						downloading through the reference.
					</td></tr></tbody></table><exhibit role="dtdl" id="dtdl-ED"><anchor id="dtdl-ED"/><caption/><pre>
type EncapsulatedData alias ED specializes BIN {
   CS   mediaType;
   CS   charset;
   CS   language;
   CS   compression;
   TEL  reference;
   BIN  integrityCheck;
   CS   integrityCheckAlgorithm;
   ED   thumbnail;
   BL   equal(ANY x);
};</pre></exhibit><p>
					Encapsulated data can be present in two forms, inline or by
					reference. Inline data is communicated or moved as part of the
					encapsulated data value, whereas by-reference data may reside at a
					different (remote) location. The data is the same whether it is
					located inline or remote.
				</p><div3 id="prop-ED.mediaType"><head>Media Type : <termref ref="dt-CS">CS</termref></head><p><emph role="strong">Definition:</emph>
						Identifies the type of the encapsulated data and identifies a
						method to interpret or render the data.
					</p><p><emph>mediaType</emph> is a mandatory property, i.e., every non-NULL instance of
							<emph>ED</emph> must have a non-NULL <emph>mediaType</emph> property.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(ED x)
      where x.nonNull {
   x.mediaType.nonNull;
};</pre></exhibit><p>
						The IANA defined domain of media types is established by the Internet
						standard RFC 2045 [<loc href="http://www.ietf.org/rfc/rfc2045.txt" xlink-form="simple" show="embed" actuate="auto"/>]
						and 2046 [<loc href="http://www.ietf.org/rfc/rfc2046.txt" xlink-form="simple" show="embed" actuate="auto"/>].
						RFC 2046 defines the media type to consist of two parts:
					</p><list role="ordered"><item>
							top level media type, and
						</item><item>
							media subtype
						</item></list><p>
						However, this specification treats the entire media type as one atomic
						code symbol in the form defined by IANA, i.e., top level type followed
						by a slash "/" followed by media subtype. Currently defined media
						types are registered in a database
						[<loc href="http://www.iana.org/assignments/media-types/index.html" xlink-form="simple" show="embed" actuate="auto"/>]
						maintained by IANA. Currently more than 160 different MIME media types are
						defined, with the list growing rapidly. In general, all those types
						defined by the IANA may be used.
					</p><p>
						To promote interoperability, this specification prefers certain media
						types to others. This is to define a greatest common denominator on
						which interoperability is not only possible, but that is powerful
						enough to support even advanced multimedia communication needs.
					</p><p><tabref ref="domain-MediaType"/> below assigns a status to
						certain MIME media types, where the status means one of the following:
					</p><list role="unordered"><item><emph role="strong">required</emph>: Every HL7 application
							must support at least the required media types if it supports a given
							kind of media. One required media-type for each kind of media
							exists. Some media types are required for a specific purpose, which is
							then indicated as "required for ..."
						</item><item><emph role="strong">recommended</emph>: Other media types are
							recommended for a particular purpose. For any given purpose there
							should be only very few additionally recommended media types and the
							rationale, conditions and assumptions of such recommendations must be
							made very clear.
						</item><item><emph role="strong">indifferent</emph>: This status means, HL7
							neither forbids nor endorses the use of this media type. All media
							types not mentioned in <tabref ref="domain-MediaType"/> have status indifferent by default.
							Since there is one required and several recommended media types for most
							practically relevant use cases, media types of this status should be used
							very conservatively.
						</item><item><emph role="strong">deprecated</emph>: Deprecated media types
							should not be used, because these media types are flawed, because
							there are better alternatives, or because of certain risks. Such risks
							could be security risks, for example, the risk that such a media type
							could spread computer viruses. Not every flawed media type is marked
							as deprecated, though. A media type that is not mentioned in Table 6,
							and thus has status indifferent, may well be flawed.
						</item></list><table id="domain-MediaType"><caption>Domain MediaType</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>status</th><th>definition</th></tr></thead><tbody><tr valign="top"><td>text/plain</td><td>Plain Text</td><td>required</td><td>For any plain text.  This is the default and is equivalent to a character string (ST) data type.</td></tr><tr valign="top"><td>text/x-hl7-ft</td><td>HL7 Text</td><td>recommended</td><td>For compatibility, this represents the HL7 v2.x FT data type.  Its use is recommended only for backward compatibility with HL7 v2.x systems.</td></tr><tr valign="top"><td>text/html</td><td>HTML Text</td><td>recommended</td><td>For marked-up text according to the Hypertext Mark-up Language.  HTML markup is sufficient for typographically marking-up most written-text documents.  HTML is platform independent and widely deployed.</td></tr><tr valign="top"><td>application/pdf</td><td>PDF</td><td>recommended</td><td>The Portable Document Format is recommended for written text that is completely laid out and read-only.  PDF is a platform independent, widely deployed, and open specification with freely available creation and rendering tools.</td></tr><tr valign="top"><td>text/xml</td><td>XML Text</td><td>indifferent</td><td>For structured character based data.  There is a risk that general SGML/XML is too powerful to allow a sharing of general SGML/XML documents between different applications.</td></tr><tr valign="top"><td>text/rtf</td><td>RTF Text</td><td>indifferent</td><td>The Rich Text Format is widely used to share word-processor documents.  However, RTF does have compatibility problems, as it is quite dependent on the word processor.  May be useful if word processor edit-able text should be shared.</td></tr><tr valign="top"><td>application/msword</td><td>MSWORD</td><td>deprecated</td><td>This format is very prone to compatibility problems.  If sharing of edit-able text is required, text/plain, text/html or text/rtf should be used instead.</td></tr><tr valign="top"><td>audio/basic</td><td>Basic Audio</td><td>required</td><td>This is a format for single channel audio, encoded using 8bit ISDN mu-law [PCM] at a sample rate of 8000 Hz.  This format is standardized by: CCITT, Fascicle III.4 -Recommendation G.711.  Pulse Code Modulation (PCM) of Voice Frequencies.  Geneva, 1972.</td></tr><tr valign="top"><td>audio/mpeg</td><td>MPEG audio layer 3</td><td>required</td><td>MPEG-1 Audio layer-3 is an audio compression algorithm and file format                       defined in ISO 11172-3 and ISO 13818-3. MP3 has an adjustable sampling frequency for highly compressed telephone to CD quality audio.</td></tr><tr valign="top"><td>audio/k32adpcm</td><td>K32ADPCM Audio</td><td>indifferent</td><td>ADPCM allows compressing audio data.  It is defined in the Internet specification RFC 2421 [ftp://ftp.isi.edu/in-notes/rfc2421.txt].  Its implementation base is unclear.</td></tr><tr valign="top"><td>image/png</td><td>PNG Image</td><td>required</td><td>Portable Network Graphics (PNG) [http://www.cdrom.com/pub/png] is a widely supported lossless image compression standard with open source code available.</td></tr><tr valign="top"><td>image/gif</td><td>GIF Image</td><td>indifferent</td><td>GIF is a popular format that is universally well supported. However GIF is patent encumbered and should therefore be used with caution.</td></tr><tr valign="top"><td>image/jpeg</td><td>JPEG Image</td><td>required</td><td>This format is required for high compression of high color photographs.  It is a "lossy" compression, but the difference to lossless compression is almost unnoticeable to the human vision.</td></tr><tr valign="top"><td>application/dicom</td><td>DICOM</td><td>recommended</td><td>Digital Imaging and Communications in Medicine (DICOM) MIME type defined in RFC3240 [http://ietf.org/rfc/rfc3240.txt].</td></tr><tr valign="top"><td>image/g3fax</td><td>G3Fax Image</td><td>recommended</td><td>This is recommended only for fax applications.</td></tr><tr valign="top"><td>image/tiff</td><td>TIFF Image</td><td>indifferent</td><td>Although TIFF (Tag Image File Format) is an international standard it has many interoperability problems in practice.  Too many different versions that are not handled by all software alike.</td></tr><tr valign="top"><td>video/mpeg</td><td>MPEG Video</td><td>required</td><td>MPEG is an international standard, widely deployed, highly efficient for high color video; open source code exists; highly interoperable.</td></tr><tr valign="top"><td>video/x-avi</td><td>X-AVI Video</td><td>deprecated</td><td>The AVI file format is just a wrapper for many different codecs; it is a source of many interoperability problems.</td></tr><tr valign="top"><td>model/vrml</td><td>VRML Model</td><td>recommended</td><td>This is an openly standardized format for 3D models that can be useful for virtual reality applications such as anatomy or biochemical research (visualization of the steric structure of macromolecules)</td></tr></tbody></table><p>
						The set of required media types is very small so that no undue
						requirements are forced on HL7 applications, especially legacy
						systems. In general, no HL7 application is forced to support any given
						kind of media other than written text. For example, many systems just
						do not want to receive audio data, because those systems can only show
						written text to their users. It is a matter of application conformance
						statements to say: "I will not handle audio". Only if a system claims
						to handle audio media, it must support the required media type for
						audio.
					</p></div3><div3 id="prop-ED.charset"><head>Charset : <termref ref="dt-CS">CS</termref></head><p><emph role="strong">Definition:</emph>
						For character-based encoding types, this property specifies the
						character set and character encoding used. The charset shall be
						identified by an Internet Assigned Numbers Authority (IANA) 
						Charset Registration [<loc href="http://www.iana.org/assignments/character-sets" xlink-form="simple" show="embed" actuate="auto"/>] 
						in accordance with RFC 2978 [<loc href="http://www.ietf.org/rfc/rfc2978.txt" xlink-form="simple" show="embed" actuate="auto"/>].
					</p><!-- EDNOTE the bibliography references are a problem if taken out
     of this document and copied into schemas etc the references
     are left dangling. Consider the citations in full in line.
     Perhaps should make a "cite" tag that contains all bibliographic
     data and can then be rendered either inline, with href or as
     a bibliography endnote reference. If we do bibrefs we need
     a bibliography post-processing step like bibTeX or refer(1).
 --><p>
						The charset domain is maintained by the <emph>Internet Assigned
						Numbers Authority</emph> (IANA) [<loc href="http://www.iana.org/assignments/character-sets" xlink-form="simple" show="embed" actuate="auto"/>].
						The IANA source specifies names and multiple aliases for most character
						sets. For HL7's purposes, use of multiple alias names is not
						allowed. The standard name for HL7 is the one marked by IANA as
						"preferred for MIME."  If IANA has not marked one of the aliases as
						"preferred for MIME" the main name shall be the one used for HL7.
					</p><p><tabref ref="domain-Charset"/> lists a few of the IANA defined
						character sets that are of interest to current HL7 members.
<!--
						<hide>
							The definition of the "status" column is as given for <tabref
							ref="domain-MediaType"/>.
						</hide>
  --></p><table id="domain-Charset"><caption>Domain Charset</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><td>EBCDIC</td><td>EBCDIC</td><td>HL7 is indifferent to the use of this Charset.</td></tr><tr valign="top"><td>ISO-10646-UCS-2</td><td>ISO-10646-UCS-2</td><td>Deprecated for HL7 use.</td></tr><tr valign="top"><td>ISO-10646-UCS-4</td><td>ISO-10646-UCS-4</td><td>Deprecated for HL7 use.</td></tr><tr valign="top"><td>ISO-8859-1</td><td>ISO-8859-1</td><td>HL7 is indifferent to the use of this Charset.</td></tr><tr valign="top"><td>ISO-8859-2</td><td>ISO-8859-2</td><td>HL7 is indifferent to the use of this Charset.</td></tr><tr valign="top"><td>ISO-8859-5</td><td>ISO-8859-5</td><td>HL7 is indifferent to the use of this Charset.</td></tr><tr valign="top"><td>JIS-2022-JP</td><td>JIS-2022-JP</td><td>HL7 is indifferent to the use of this Charset.</td></tr><tr valign="top"><td>US-ASCII</td><td>US-ASCII</td><td>Required for HL7 use.</td></tr><tr valign="top"><td>UTF-7</td><td>UTF-7</td><td>HL7 is indifferent to the use of this Charset.</td></tr><tr valign="top"><td>UTF-8</td><td>UTF-8</td><td>Required for Unicode support.</td></tr></table><note><p>
							The above list is not complete let alone exclusive. In particular,
							international HL7 affiliates may make special recommendations about
							charsets to be used in their realm. These recommendations may add
							additional charsets and may reassign the recommendations status of a
							listed charset.
						</p></note><p>
						The charset property needs to be known where the data of the <emph>ED</emph> is character type
						data in any form. If the data is provided in-line, then the charset must be 
						known. If the data is provided as a reference, and the access method does not provide
						the charset for the data, typically as a mime header, then the charset must be 
						conveyed as part of the <emph>ED</emph>. 
					</p><p>
						Interested readers may also want to consult the "Character Model for
						the World Wide Web" [<loc href="http://www.w3.org/TR/charmod" xlink-form="simple" show="embed" actuate="auto"/>] for a more complete
						discussion of character set and related issues
					</p></div3><div3 id="prop-ED.language"><head>Language : <termref ref="dt-CS">CS</termref></head><p><emph role="strong">Definition:</emph>
						For character based information the language property specifies the
						human language of the text.
					</p><p role="defense">
						The need for a language code for text data values is documented in RFC
						2277, IETF Policy on Character Sets and Languages
						[<loc href="http://www.ietf.org/rfc/rfc2277.txt" xlink-form="simple" show="embed" actuate="auto"/>]. Further background
						information can be found in Using International Characters in Internet
						Mail [<loc href="http://www.imc.org/mail-i18n.html" xlink-form="simple" show="embed" actuate="auto"/>], a memo by the
						Internet Mail Consortium.
					</p><p>
						The principles of the code domain of this attribute are specified by
						the Internet standard RFC 3066 [<loc href="http://www.ietf.org/rfc/rfc3066.txt" xlink-form="simple" show="embed" actuate="auto"/>].
						The RFC 3066 coding scheme is constructed from a primary subtag component encoded
						using the language codes of ISO 639, plus two codes for extensions
						for languages not represented in ISO 639.  The code optionally includes a
						second subtag component encoded using the two letter country codes of ISO
						3166, or a language code extension registered by the Internet Assigned
						Names Authority [<loc href="http://www.iana.org/assignments/language-tags" xlink-form="simple" show="embed" actuate="auto"/>].<footnote><p>
								RFC 3066 [<loc href="http://www.ietf.org/rfc/rfc3066.txt" xlink-form="simple" show="embed" actuate="auto"/>] is
								the HL7-approved coding system for all reference to human languages,
								in data types and elsewhere.
							</p></footnote></p><!-- FIXME table shows nothing: domain table="HumanLanguage" --><p>
						While Language tags usually alter the meaning of the text, the language does
						not alter the meaning of the characters in the text.<footnote><p>
								For this reason, a system or site that does not deal with multilingual
								text or names in the real world can safely ignore the language
								property.
							</p></footnote></p><note role="ITS"><p>
							Representation of language tags to text is highly dependent on the
							ITS. An ITS may use the native way of language tagging provided by
							its target implementation technology. Some may have language
							information in a separate component, e.g., XML has the xml:lang tag
							for strings. Others may rely on language tags as part of the binary
							character string representation, e.g., ISO 10646 (Unicode) and its
							"plane-14" language tags.
						</p></note><!-- FIXME: consider dropping this language tag once and for all --><p>
						The language tag should not be mandatory if it is not mandatory in the
						implementation technology. Semantically, language tagging of strings
						follows a default-logic. In circumstances where a realm may support
						multiple langauges, it is up to the realm to define rules to handle
						language where none is specified when no language is specified. If no
						other rule is specified, the local language of the reader is assumed.
						If a language is set for an entire message or document, that language
						is the default. If any information element or value that is superior in
						the syntax hierarchy specifies a language, that language is the default
						for all subordinate text values.
					</p><p>
						If language tags are present in the beginning of the encoded binary
						text (e.g., through Unicode's plane-14 tags) this is the source of the
						language property of the encapsulated data value.
					</p></div3><div3 id="prop-ED.compression"><head>Compression : <termref ref="dt-CS">CS</termref></head><p><emph role="strong">Definition:</emph>
						Indicates whether the raw byte data is compressed, and what
						compression algorithm was used.
					</p><table id="domain-CompressionAlgorithm"><caption>Domain CompressionAlgorithm</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>status</th><th>definition</th></tr></thead><tbody><tr valign="top"><td>DF</td><td>deflate</td><td>required</td><td>The deflate compressed data format as specified in RFC 1951 [http://www.ietf.org/rfc/rfc1951.txt].</td></tr><tr valign="top"><td>GZ</td><td>gzip</td><td>indifferent</td><td>A compressed data format that is compatible with the widely used GZIP utility as specified in RFC 1952 [http://www.ietf.org/rfc/rfc1952.txt] (uses the deflate algorithm).</td></tr><tr valign="top"><td>ZL</td><td>zlib</td><td>indifferent</td><td>A compressed data format that also uses the deflate algorithm.  Specified as RFC 1950 [http://www.ietf.org/rfc/rfc1952.txt]</td></tr><tr valign="top"><td>Z</td><td>compress</td><td>deprecated</td><td>Original UNIX compress algorithm and file format using the LZC algorithm (a variant of LZW).  Patent encumbered and less efficient than deflate.</td></tr></tbody></table><p><!--
						<hide>
							The definition of the "status" column is as given for 
							<tabref ref="domain-MediaType"/>. Compression may not be allowed for
							encapsulated data depending on the attribute or component that is
							declared encapsulated data.
						</hide>
  -->
						Values of type <termref ref="dt-ST">ST</termref> may never be compressed.
					</p></div3><div3 id="prop-ED.reference"><head>Reference : <termref ref="dt-TEL">TEL</termref></head><p><emph role="strong">Definition:</emph>
						A telecommunication address (<termref ref="dt-TEL">TEL</termref>), such as a URL for HTTP or FTP,
						which will resolve to precisely the same binary data that could as
						well have been provided as inline data.
					</p><p>
						The semantic value of an encapsulated data value is the same,
						regardless whether the data is present inline data or just
						by-reference. However, an encapsulated data value without inline data
						behaves differently, since any attempt to examine the data requires
						the data to be downloaded from the reference. An encapsulated data
						value may have both inline data and a reference.
					</p><p>
						The reference must point to the same data as provided inline.
						It is an error if the data resolved through the reference does
						not match either the integrity check, in-line data, or data that
						had earlier been retrieved through the reference and then cached.
					</p><p>
						The reference may contain a usablePeriod to indicate that the
						data may only be available for a limited period of time. Whether
						the reference is limited by a usablePeriod or not, the content of
						the reference is fixed for all time. Any application using the
						reference must always receive the same data. The reference cannot
						be reused to send a different version of the same data, or different
						data.
					</p><p>
						By-reference encapsulated data may not be allowed depending on the
						attribute or component that is declared encapsulated data.
						Values of type <termref ref="dt-ST">ST</termref> must always be inline.
					</p></div3><div3 id="prop-ED.integrityCheck"><head>Integrity Check : <termref ref="dt-BIN">BIN</termref></head><p><emph role="strong">Definition:</emph>
						The integrity check is a short binary value representing a
						cryptographically strong checksum that is calculated over the binary
						data. The purpose of this property, when communicated with a reference
						is for anyone to validate later whether the reference still resolved
						to the same data that the reference resolved to when the encapsulated
						data value with reference was created.
					</p><p>
						It is an error if the data resolved through the reference does not match
						the integrity check.
					</p><p>
						The integrity check is calculated according to the
						<termref ref="prop-ED.integrityCheckAlgorithm">integrityCheckAlgorithm</termref>. By default,
						the <emph>Secure Hash Algorithm-1</emph> (SHA-1) shall be used.
						The integrity check is binary encoded according to the rules of
						the integrity check algorithm.
					</p><p>
						The integrity check is calculated over the raw binary data that is
						contained in the data component, or that is accessible through the
						reference. No transformations are made before the integrity check is
						calculated. If the data is compressed, the Integrity Check is
						calculated over the compressed data.
					</p></div3><div3 id="prop-ED.integrityCheckAlgorithm"><head>Integrity Check Algorithm : <termref ref="dt-CS">CS</termref></head><p><emph role="strong">Definition:</emph>
						Specifies the algorithm used to compute the integrityCheck
						value.<footnote><p>
								The cryptographically strong checksum algorithm Secure Hash
								Algorithm-1 (SHA-1) is currently the industry standard. It has
								superseded the MD5 algorithm only a couple of years ago, when certain
								flaws in the security of MD5 were discovered. Currently the SHA-1 hash
								algorithm is the default choice for the integrity check algorithm.
								Note that SHA-256 is also entering widespread usage.
							</p></footnote></p><table id="domain-IntegrityCheckAlgorithm"><caption>Domain IntegrityCheckAlgorithm</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><td>SHA-1</td><td>secure hash algorithm - 1</td><td>This algorithm is defined in FIPS PUB 180-1: Secure Hash Standard.  As of April 17, 1995.</td></tr><tr valign="top"><td>SHA-256</td><td>secure hash algorithm - 256</td><td>This algorithm is defined in FIPS PUB 180-2: Secure Hash Standard.</td></tr></table></div3><div3 id="prop-ED.thumbnail"><head>Thumbnail : <termref ref="dt-ED">ED</termref></head><p><emph role="strong">Definition:</emph>
						An abbreviated rendition of the full data. A thumbnail requires
						significantly fewer resources than the full data, while still
						maintaining some distinctive similarity with the full data. A
						thumbnail is typically used with by-reference encapsulated data. It
						allows a user to select data more efficiently before actually
						downloading through the reference.
					</p><p>
						Originally, the term thumbnail refers to an image in a lower
						resolution (or smaller size) than another image. However, the
						thumbnail concept can be metaphorically used for media types other
						than images. For example, a movie may be represented by a shorter
						clip; an audio-clip may be represented by another audio-clip that is
						shorter, has a lower sampling rate, or a lossy compression.
					</p><p>
							Thumbnails may not be allowed depending on the attribute or component
							that is declared encapsulated data. Values of type <termref ref="dt-ST">ST</termref>
							never have thumbnails, and a thumbnail may not itself
							contain a thumbnail.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(ED x)
      where x.thumbnail.nonNull {
   x.thumbnail.thumbnail.isNull;
};</pre></exhibit><note role="its"><p>
							ITS's should consider the case where the thumbnail and the original
							both have the same properties of type, charset and compression. In
							this case, these properties need not be represented explicitly for the
							thumbnail but might be "inherited" from the main encapsulated data
							value to its thumbnail.
						</p></note></div3><div3 id="prop-ED.equal"><head>Equality : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref></head><p>
						Two values of type <emph>ED</emph> are equal if and only if their mediatype
						and data are equal. For those <emph>ED</emph> values
						with compressed data or referenced data, only the de-referenced and
						uncompressed data counts for the equality test. The compression, thumbnail
						and reference property themselves are excluded from the equality test.
						In addition the language property is excluded from the test, due to the
						problems this would introduce values of type <emph>ED</emph> where the language is not
						specified. If the <termref ref="prop-ED.mediaType">mediaType</termref> is character based and the charset property
						is not equal, the charset property must be resolved through mapping of the
						data between the different character sets.
					</p><p>
						The integrity check algorithm and integrity check is excluded from the
						equality test. However, since equality of integrity check value is
						strong indication for equality of the data, the equality test can be
						practically based on the integrity check, given equal integrity check
						algorithm properties.
					</p></div3></div2><div2 id="dt-ST"><anchor id="ST"/><head>Character String (ST) specializes <termref ref="dt-ED">ED</termref></head><p><emph role="strong">Definition:</emph>
					The character string data type stands for text data, primarily
					intended for machine processing (e.g., sorting, querying, indexing,
					etc.) Used for names, symbols, and formal expressions.
				</p><p><termref ref="dt-ST">ST</termref> is a restricted <termref ref="dt-ED">ED</termref>,
					whose <termref ref="prop-ED.mediaType">ED.mediaType</termref> property is fixed to <emph>text/plain</emph>,
					and whose data must be inlined and not compressed. Thus, the properties compression, reference,
					integrity check, algorithm, and thumbnail are not applicable. The character
					string data type is used when the appearance of text does not bear meaning,
					which is true for formalized text and all kinds of names.
				</p><table id="dt-ST-prop-summary"><caption>Property Summary of
      Character String</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-ST.mediaType">mediaType</termref></td><td><termref ref="dt-CS">CS</termref></td><td>
						Identifies the type of the encapsulated data and identifies a
						method to interpret or render the data.
					</td></tr><tr><td><termref ref="prop-ST.charset">charset</termref></td><td><termref ref="dt-CS">CS</termref></td><td>
						For character-based encoding types, this property specifies the
						character set and character encoding used. The charset shall be
						identified by an Internet Assigned Numbers Authority (IANA) 
						Charset Registration [<loc href="http://www.iana.org/assignments/character-sets" xlink-form="simple" show="embed" actuate="auto"/>] 
						in accordance with RFC 2978 [<loc href="http://www.ietf.org/rfc/rfc2978.txt" xlink-form="simple" show="embed" actuate="auto"/>].
					</td></tr><tr><td><termref ref="prop-ST.language">language</termref></td><td><termref ref="dt-CS">CS</termref></td><td>
						For character based information the language property specifies the
						human language of the text.
					</td></tr></tbody></table><p><emph>ST</emph> data type interprets the encapsulated data
					as character data (as opposed to bits), depending on the charset
					property of the encapsulated data type.
				</p><exhibit role="dtdl" id="dtdl-ST"><anchor id="dtdl-ST"/><caption/><pre>
type CharacterString alias ST specializes ED {
   INT  length;
   ST   headCharacter;
   ST   tailString;
};</pre></exhibit><note role="its"><p>
						Because many of the properties of the encapsulated data are bound to a
						default value, an ITS need not represent these properties at all. In
						fact, if the character encoding is also fixed, the ITS only represents
						the encoded character data.
					</p></note><p>
					The headCharacter and tailString properties define <emph>ST</emph> as a sequence
					of entities each of which uniquely identifies one character from the
					joint set of all characters known by any language of the world.<footnote><p>
							ISO/IEC 10646-1: 1993 defines a character as "A member of a set of
							elements used for the organization, control, or representation of
							data."  ISO/IEC TR 15285 - An operational model for characters and
							glyphs. Discusses the problems involved in defining
							characters. Notably, characters are abstract entities of information,
							independent of type font or language. The ISO 10646 (UNICODE
							[http://www.unicode.org]) - or in Japan, JIS X0221 - is a globally
							applicable character set that uniquely identifies all characters of
							any language in the world.
						</p><p>
							In this specification, ISO 10646 serves as a semantic model for
							character strings. The important point is that for semantic purposes,
							there is no notion of separate character sets and switching between
							character sets. Character set and character encoding are ITS layer
							considerations. The formal definition gives indication to this effect
							because each character is by itself an <emph>ST</emph> value that
							has a charset property. Thus, the binary encoding of each character is
							always understood in the context of a certain character set. This does
							not mean that the ITS should represent a character string as a
							sequence of full blown <termref ref="dt-ED">ED</termref> values. What it means is that
							on the application layer the notion of character encoding is
							irrelevant when we deal with character strings.
						</p></footnote></p><p>
					The head of an <emph>ST</emph> is a string of only one character. An <emph>ST</emph>
					must have at least one character or else it is NULL. A
					zero-length <emph>ST</emph> is an exceptional value (NULL), not a proper
					value.
				</p><exhibit role="dtdl"><caption/><pre>
invariant(ST x)
      where x.nonNull {
   x.headCharacter.notEmpty;
   x.headCharacter.length.equal(1);
   x.headCharacter.tailString.isEmpty;
   x.tailString.isEmpty.implies(x.length.equal(1));
   x.tailString.notEmpty.implies(x.length.equal(x.tailString.length.successor));
};</pre></exhibit><p>
					The length of an <emph>ST</emph> is the number of characters, not the number of
					encoded bytes, in the string. Byte encoding is an ITS issue and is not relevant on
					the application layer.
				</p><p>
					The following rules apply to whitespace contained within values of type <emph>ST</emph>:
				</p><list role="unordered"><item>
						TAB, space and end-of-line are all considered whitespace characters.
					</item><item>
						Both preceding and trailing whitespace is significant.
					</item><item>
						Different whitespace characters are not interchangable.
					</item><item>
						Different representations of end-of-line are normalised according to the
						method described in the XML specification
						[<loc href="http://www.w3.org/TR/2000/REC-xml-20001006#sec-line-ends" xlink-form="simple" show="embed" actuate="auto">Section 2.11 End-of-Line Handling</loc>]
					</item><item>
						Sequences of whitespace cannot be compressed to shorter sequences.
					</item></list><exhibit role="requirement"><emph role="strong">Requirement</emph><p><emph>ST</emph> is a specialization of <termref ref="dt-ED">ED</termref> so that any RIM attribute which has the type
						<termref ref="dt-ED">ED</termref> can be constrained to a <emph>ST</emph>. The most important case is Act.text, which is
						an <termref ref="dt-ED">ED</termref> to cater for the use of references and multimedia data, but is often
						constrained to plain text.
					</p></exhibit><div3 id="prop-ST.mediaType"><head>Media Type : <termref ref="dt-CS">CS</termref>, inherited from <termref ref="dt-ED">ED</termref></head><exhibit role="dtdl"><caption/><pre>
invariant(ST x)
      where x.nonNull {
   x.mediaType.equal("text/plain");
};</pre></exhibit><p>
						Fixed to be "text/plain".
					</p></div3><div3 id="prop-ST.charset"><head>Charset : <termref ref="dt-CS">CS</termref>, inherited from <termref ref="dt-ED">ED</termref></head><exhibit role="dtdl"><caption/><pre>
invariant(ST x)
      where x.nonNull {
   x.charset.nonNull;
};</pre></exhibit><p>
						Values of type <emph>ST</emph> must have a known charset. 
					</p></div3><div3 id="prop-ST.language"><head>Language : <termref ref="dt-CS">CS</termref>, inherited from <termref ref="dt-ED">ED</termref></head><p><emph role="strong">Definition:</emph>
						For character based information the language property specifies the
						human language of the text.
					</p><p role="defense">
						The need for a language code for text data values is documented in RFC
						2277, IETF Policy on Character Sets and Languages
						[<loc href="http://www.ietf.org/rfc/rfc2277.txt" xlink-form="simple" show="embed" actuate="auto"/>]. Further background
						information can be found in Using International Characters in Internet
						Mail [<loc href="http://www.imc.org/mail-i18n.html" xlink-form="simple" show="embed" actuate="auto"/>], a memo by the
						Internet Mail Consortium.
					</p><p>
						The principles of the code domain of this attribute are specified by
						the Internet standard RFC 3066 [<loc href="http://www.ietf.org/rfc/rfc3066.txt" xlink-form="simple" show="embed" actuate="auto"/>].
						The RFC 3066 coding scheme is constructed from a primary subtag component encoded
						using the language codes of ISO 639, plus two codes for extensions
						for languages not represented in ISO 639.  The code optionally includes a
						second subtag component encoded using the two letter country codes of ISO
						3166, or a language code extension registered by the Internet Assigned
						Names Authority [<loc href="http://www.iana.org/assignments/language-tags" xlink-form="simple" show="embed" actuate="auto"/>].<footnote><p>
								RFC 3066 [<loc href="http://www.ietf.org/rfc/rfc3066.txt" xlink-form="simple" show="embed" actuate="auto"/>] is
								the HL7-approved coding system for all reference to human languages,
								in data types and elsewhere.
							</p></footnote></p><p>
						While Language tags usually alter the meaning of the text, the language does
						not alter the meaning of the characters in the text.<footnote><p>
								For this reason, a system or site that does not deal with multilingual
								text or names in the real world can safely ignore the language
								property.
							</p></footnote></p><note role="ITS"><p>
							Representation of language tags to text is highly dependent on the
							ITS. An ITS may use the native way of language tagging provided by
							its target implementation technology. Some may have language
							information in a separate component, e.g., XML has the xml:lang tag
							for strings. Others may rely on language tags as part of the binary
							character string representation, e.g., ISO 10646 (Unicode) and its
							"plane-14" language tags.
						</p></note><p>
						The language tag should not be mandatory if it is not mandatory in the
						implementation technology. Semantically, language tagging of strings
						follows a default-logic. In circumstances where a realm may support
						multiple langauges, it is up to the realm to define rules to handle
						language where none is specified when no language is specified. If no
						other rule is specified, the local language of the reader is assumed.
						If a language is set for an entire message or document, that language
						is the default. If any information element or value that is superior in
						the syntax hierarchy specifies a language, that language is the default
						for all subordinate text values.
					</p><p>
						If language tags are present in the beginning of the encoded binary
						text (e.g., through Unicode's plane-14 tags) this is the source of the
						language property of the encapsulated data value.
					</p></div3><div3 id="prop-ST.compression"><head>Compression : <termref ref="dt-CS">CS</termref>, (fixed)</head><exhibit role="dtdl"><caption/><pre>
invariant(ST x)
      where x.nonNull {
   x.compression.notApplicable;
};</pre></exhibit><p>
						Values of type <emph>ST</emph> cannot be compressed.
					</p></div3><div3 id="prop-ST.reference"><head>Reference : <termref ref="dt-TEL">TEL</termref>, (fixed)</head><exhibit role="dtdl"><caption/><pre>
invariant(ST x)
      where x.nonNull {
   x.reference.notApplicable;
};</pre></exhibit><p>
						Values of type <emph>ST</emph> may not reference content from some other location.
					</p></div3><div3 id="prop-ST.integrityCheck"><head>Integrity Check : <termref ref="dt-BIN">BIN</termref>, (fixed)</head><exhibit role="dtdl"><caption/><pre>
invariant(ST x)
      where x.nonNull {
   x.integrityCheck.notApplicable;
};</pre></exhibit><p>
						Integrity check code is not used with values of type <emph>ST</emph>.
					</p></div3><div3 id="prop-ST.integrityCheckAlgorithm"><head>Integrity Check Algorithm : <termref ref="dt-CS">CS</termref>, (fixed)</head><exhibit role="dtdl"><caption/><pre>
invariant(ST x)
      where x.nonNull {
   x.integrityCheckAlgorithm.notApplicable;
};</pre></exhibit><p>
						Integrity check algorithm is not used with values of type <emph>ST</emph>.
					</p></div3><div3 id="prop-ST.thumbnail"><head>Thumbnail : <termref ref="dt-ED">ED</termref>, (fixed)</head><exhibit role="dtdl"><caption/><pre>
invariant(ST x)
      where x.nonNull {
   x.thumbnail.notApplicable;
};</pre></exhibit><p>
						Values of type <emph>ST</emph> do not have thumbnails.
					</p></div3><div3 id="prop-ST.literal"><head>Literal Form</head><p>
						Two variations of <emph>ST</emph> literals are defined, a token form
						and a quoted string.<footnote><p>
								An <emph>ST</emph> literal is a conversion from a character string to
								another data type. Obviously, <emph>ST</emph> literals for character
								strings is a cyclical if not redundant feature. This literal form,
								therefore, mainly specifies how character strings are parsed in the
								data type specification language.
							</p></footnote>
						The token form consists only of the lower case and upper case Latin
						alphabet, the ten decimal digits and the underscore. The quoted string
						can contain any character between double-quotes. The double quotes
						prevent a character string from being interpreted as some other
						literal. The token form allows keywords and names to be parsed from
						the data type specification language.
					</p><exhibit role="dtdl"><caption/><pre>
ST.literal ST {
   ST : /"[^]+"/         { $.equal($1); }  /* quoted string */
      | /[a-zA-Z0-9_]+/  { $.equal($1); }; /* token form */
};</pre></exhibit><note role="its"><p>
							Since <emph>ST</emph> literals are so fundamental to implementation
							technology, most ITS will specify some modified character string
							literal form. However, ITS designers must be aware of the interaction
							between the <emph>ST</emph> literal form and the literal forms
							defined for other data types. This is particularly critical if the
							other data type's literal form is structured with major components
							separated by break-characters (e.g., real number, physical quantity,
							set, and list literals, etc.)
						</p></note></div3></div2><graphic source="graphics/dtUML-Concepts.gif" alt="The Concept Descriptor information model."/><div2 id="dt-CD"><anchor id="CD"/><head>Concept Descriptor (CD) specializes <termref ref="dt-ANY">ANY</termref></head><p><emph role="strong">Definition:</emph>
					A <emph>CD</emph> represents any kind of concept usually by
					giving a code defined in a code system.

					A <emph>CD</emph> can contain the original text or phrase that
					served as the basis of the coding and one or more translations into
					different coding systems.

					A <emph>CD</emph> can also contain qualifiers to describe, e.g., the
					concept of a "left foot" as a postcoordinated term built from the
					primary code "FOOT" and the qualifier "LEFT".

					In cases of an exceptional value, the <emph>CD</emph> need not contain a code
					but only the original text describing that concept.
				</p><table id="dt-CD-prop-summary"><caption>Property Summary of
      Concept Descriptor</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-CD.code">code</termref></td><td><termref ref="dt-ST">ST</termref></td><td>
						The plain code symbol defined by the code system. For example,
						"784.0" is the code symbol of the ICD-9 code "784.0" for headache.
					</td></tr><tr><td><termref ref="prop-CD.codeSystem">codeSystem</termref></td><td><termref ref="dt-UID">UID</termref></td><td>
						Specifies the code system that defines the code.
					</td></tr><tr><td><termref ref="prop-CD.codeSystemName">codeSystemName</termref></td><td><termref ref="dt-ST">ST</termref></td><td>
						The common name of the coding system.
					</td></tr><tr><td><termref ref="prop-CD.codeSystemVersion">codeSystemVersion</termref></td><td><termref ref="dt-ST">ST</termref></td><td>
						If applicable, a version descriptor defined specifically for the given
						code system.
					</td></tr><tr><td><termref ref="prop-CD.displayName">displayName</termref></td><td><termref ref="dt-ST">ST</termref></td><td>
						A name or title for the code, under which the sending system shows the
						code value to its users.
					</td></tr><tr><td><termref ref="prop-CD.originalText">originalText</termref></td><td><termref ref="dt-ED">ED</termref></td><td>
						The text or phrase used as the basis for the coding.
					</td></tr><tr><td><termref ref="prop-CD.translation">translation</termref></td><td><termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-CD">CD</termref>&gt;</td><td>
						A set of other concept descriptors that translate this concept
						descriptor into other code systems.
					</td></tr><tr><td><termref ref="prop-CD.qualifier">qualifier</termref></td><td><termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-CR">CR</termref>&gt;</td><td>
						Specifies additional codes that increase the specificity of the the
						primary code.
					</td></tr></tbody></table><exhibit role="dtdl" id="dtdl-CD"><anchor id="dtdl-CD"/><caption/><pre>
type ConceptDescriptor alias CD specializes ANY {
            ST        code;
            ST        displayName;
            UID       codeSystem;
            ST        codeSystemName;
            ST        codeSystemVersion;
            ED        originalText;
            LIST&lt;CR&gt;  qualifier;
            SET&lt;CD&gt;   translation;
            BL        equal(ANY x);
            BL        implies(CD x);
  demotion  ED;
};</pre></exhibit><p><emph>CD</emph> is mostly used in one of its restricted or
					"profiled" forms, <termref ref="dt-CS">CS</termref>, <termref ref="dt-CE">CE</termref>, <termref ref="dt-CV">CV</termref>.
					Use of the full concept descriptor data type is not common. It
					requires a conscious decision and documented rationale. In all other
					cases, one of the <emph>CD</emph> restrictions shall be
					used.<footnote><p>
							The advantage of the <emph>CD</emph> data type is its expressiveness,
							however, if all of its features, such as coding exceptions, text, translations 
							and qualifiers are used at all times, implementation and use become very 
							difficult and unsafe. Therefore, <emph>CD</emph> is most often
							used in a restricted form with reduced features.
						</p></footnote></p><p>
					All <emph>CD</emph> restrictions constrain certain properties.
					Properties may be constrained to the extent that
					only one value may be allowed for that property, in which case
					mentioning the property becomes redundant. Constraining a property to
					one value is referred to as suppressing that property. Although,
					conceptually a suppressed property is still semantically applicable,
					it is safe for an HL7 interface to assume the implicit default value
					without testing.
				</p><note><p>
						In general, this is true of many types in this data types specification,
						however it is a frequently asked question concerning the <emph>CD</emph> descendents.
					</p></note><div3 id="prop-CD.code"><head>Code : <termref ref="dt-ST">ST</termref></head><p><emph role="strong">Definition:</emph>
						The plain code symbol defined by the code system. For example,
						"784.0" is the code symbol of the ICD-9 code "784.0" for headache.
					</p><p>
						A non-exceptional <emph>CD</emph> value has a non-NULL <emph>code</emph> property
						whose value is a character string that is a symbol defined by the
						coding system identified by <termref ref="prop-CD.codeSystem">codeSystem</termref>. Conversely, a
						<emph>CD</emph> value without a value for the code property, or with
						a value that is not from the cited coding system is an exceptional
						value (NULL of flavor <emph>other</emph>).
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x)
      where x.nonNull {
   x.code.nonNull;
};</pre></exhibit></div3><div3 id="prop-CD.codeSystem"><head>Code System : <termref ref="dt-UID">UID</termref></head><p><emph role="strong">Definition:</emph>
						Specifies the code system that defines the code.
					</p><p>
						Code systems shall be referred to by a <termref ref="dt-UID">UID</termref>, which allows unambiguous 
						reference to standard HL7 codes, other standard code systems, as well as local
						codes. HL7 shall assign a <termref ref="dt-UID">UID</termref> to each of its code
						tables as well as to external standard coding systems that are being
						used with HL7. Local sites must use their ISO Object Identifier
						(<termref ref="dt-OID">OID</termref>) to construct a globally unique local coding
						system identifier.
					</p><!-- FIXME: is this still correct? --><p>
						Under HL7's branch, 2.16.840.1.113883, the sub-branches 5 and 6
						contain HL7 standard and external code system identifiers
						respectively. The HL7 Vocabulary Technical Committee maintains these
						two branches.
					</p><p>
						A non-exceptional <emph>CD</emph> value (i.e. a <emph>CD</emph>
						value that has a non-null code property) has a non-NULL <emph>codeSystem</emph>
						specifying the system of concepts that defines the code. In other
						words whenever there is a code there is also a code system.
					</p><note role="its"><p>
							Although every non-NULL <emph>CD</emph> value has a defined code
							system, in some circumstances, the ITS representation for the
							<emph>CD</emph> value needs not explicitly mention the code
							system. For example, when the context mandates one and only one code
							system to be used specifying the code system explicitly would be
							redundant. However, in that case the <emph>codeSystem</emph> takes on that
							context-specific default value and is not NULL.
						</p></note><exhibit role="dtdl"><caption/><pre>
invariant(CD x)
      where x.code.nonNull {
   x.codeSystem.nonNull;
};</pre></exhibit><p>
						An exceptional <emph>CD</emph> of NULL-flavor <emph>other</emph> indicates that
						a concept could not be coded in the coding system specified. Thus, for
						these coding exceptions, the code system that did not contain the
						appropriate concept must be provided in <emph>codeSystem</emph>.
					</p><p>
						Some code domains are qualified such that they include the portion of
						any pertinent local coding system that does not simply paraphrase the
						standard coding system (<emph>coded with extensibility</emph>, CWE.)
						If a CWE qualified field actually contains such a local code, the
						coding system must specify the local coding system from which the
						local code was taken. However, for CWE domains the local code is a
						valid member of the domain, so that local codes in CWE domains
						constitute neither an error nor an exceptional (NULL/other) value in
						the sense of this specification.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x)
      where x.other {
   x.code.other;
   x.codeSystem.nonNull;
};</pre></exhibit></div3><div3 id="prop-CD.codeSystemName"><head>Code System Name : <termref ref="dt-ST">ST</termref></head><p><emph role="strong">Definition:</emph>
						The common name of the coding system.
					</p><p>
						The code system name has no computational value. The purpose of a code
						system name is to assist an unaided human interpreter of a code value to
						interpret <termref ref="prop-CD.codeSystem">codeSystem</termref>.
						It is suggested &#8212; though
						not absolutely required &#8212; that ITS provide for <emph>codeSystemName</emph> in
						order to annotate the <termref ref="dt-UID">UID</termref> for human comprehension.
					</p><p>
						HL7 systems must not functionally rely on <emph>codeSystemName</emph>. <emph>codeSystemName</emph> can
						never modify the meaning of <termref ref="prop-CD.codeSystem">codeSystem</termref> and
						cannot exist without <termref ref="prop-CD.codeSystem">codeSystem</termref>.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x) {
   x.codeSystemName.nonNull.implies(x.codeSystem.nonNull);
};</pre></exhibit></div3><div3 id="prop-CD.codeSystemVersion"><head>Code System Version : <termref ref="dt-ST">ST</termref></head><p><emph role="strong">Definition:</emph>
						If applicable, a version descriptor defined specifically for the given
						code system.
					</p><p>
						HL7 shall specify how these version strings are formed for each
						external code system. If HL7 has not specified how version strings are
						formed for a particular coding system, version designations have no
						defined meaning for such coding system.
					</p><p>
						Different versions of one code system must be compatible. Whenever a
						code system changes in an incompatible way, it will constitute a new
						code system, not simply a different version, regardless of how the
						vocabulary publisher calls it.
					</p><p>
						For example, the publisher of ICD-9 and ICD-10 calls these code
						systems, "revision 9" and "revision 10" respectively. However, ICD-10
						is a complete redesign of the ICD code, not a backward compatible
						version. Therefore, for the purpose of this data type specification,
						ICD-9 and ICD-10 are different code systems, not just different
						versions. By contrast, when LOINC updates from revision "1.0j" to
						"1.0k", HL7 would consider this to be just another version of LOINC,
						since LOINC revisions are backwards compatible.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x) {
   x.codeSystemVersion.nonNull.implies(x.codeSystem.nonNull);
};</pre></exhibit></div3><div3 id="prop-CD.displayName"><head>Display Name : <termref ref="dt-ST">ST</termref></head><p><emph role="strong">Definition:</emph>
						A name or title for the code, under which the sending system shows the
						code value to its users.
					</p><p><emph>displayName</emph> is included both as a courtesy to an unaided human
						interpreter of a code value and as a documentation of the name used to
						display the concept to the user. The display name has no functional
						meaning; it can never exist without a code; <!-- FIXME: This isn't
						true! The CWE allows it to exist w/o a code --> and it can never
						modify the meaning of <termref ref="prop-CD.code">code</termref>.
					</p><note><p>
							HL7 offers a "print name" in it's predefined vocabulary domains. These
							values are suitable for use in the displayName.
						</p></note><note><p>
							Display names may not alter the meaning of the code value. Therefore,
							display names should not be presented to the user on a receiving
							application system without ascertaining that the display name
							adequately represents the concept referred to by the code
							value. Communication must not simply rely on the display name. The
							display name's main purpose is to support debugging of HL7 protocol
							data units (e.g., messages.)
						</p></note><exhibit role="dtdl"><caption/><pre>
invariant(CD x) {
   x.displayName.nonNull.implies(x.code.nonNull);
};</pre></exhibit></div3><div3 id="prop-CD.originalText"><head>Original Text : <termref ref="dt-ED">ED</termref></head><p><emph role="strong">Definition:</emph>
						The text or phrase used as the basis for the coding.
					</p><p>
						The original text exists in a scenario where an originator of the
						information does not assign a code, but where the code is assigned
						later by a coder (post-coding.)  In the production of a concept
						descriptor, original text may thus exist without a code.
					</p><note><p>
							Although post-coding is often performed from free text information,
							such as documents, scanned images or dictation, multi-media data is
							explicitly not permitted as original text. Also, the original text
							property is not meant to be a link into the entire source
							document. The link between different artifacts of medical information
							(e.g., document and coded result) is outside the scope of this
							specification and is maintained elsewhere in the HL7 standards. The
							original text is an excerpt of the relevant information in the
							original sources, rather than a pointer or exact reproduction. Thus
							the original text is to be represented in plain text form.
   <!-- FIXME: why are we so specific? --></p></note><p>
						Values of type <emph>CD</emph> may have a non-NULL original text
						property despite having a NULL <termref ref="prop-CD.code">code</termref>. Any <emph>CD</emph> value
						with <termref ref="prop-CD.code">code</termref> of NULL signifies a coding exception. In this case,
						<emph>originalText</emph> is a name or description of the concept that was
						not coded. Such exceptional <emph>CD</emph> values may also contain <termref ref="prop-CD.translation">translation</termref>s.
						Such translations directly encode the concept described in <emph>originalText</emph>.
					</p><p>
						A <emph>CD</emph> can be demoted into an <termref ref="dt-ST">ST</termref>
						value representing only the <emph>originalText</emph> of the <emph>CD</emph> value.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x)
      where x.originalText.nonNull {
   ((ST)x).equal(x.originalText);
};</pre></exhibit></div3><div3 id="prop-CD.translation"><head>Translation : <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-CD">CD</termref>&gt;</head><p><emph role="strong">Definition:</emph>
						A set of other concept descriptors that translate this concept
						descriptor into other code systems.
					</p><p><emph>translation</emph> is a set of other <emph>CD</emph>s that
						each translate the first <emph>CD</emph> into different code
						systems. Each element of the translation set was translated from the
						first <emph>CD</emph>. Each translation may, however, also contain
						translations. Thus, when a code is translated multiple times the
						information about which code served as the input to which translation
						will be preserved.
					</p><note><p>
							The translations are quasi-synonyms of one real-world concept. Every
							translation in the set is supposed to express the same meaning "in
							other words."  However, exact synonymy rarely exists between two
							structurally different coding systems. For this reason, not all of the
							translations will be equally exact.
						</p></note></div3><div3 id="prop-CD.qualifier"><head>Qualifier : <termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-CR">CR</termref>&gt;</head><p><emph role="strong">Definition:</emph>
						Specifies additional codes that increase the specificity of the the
						primary code.
					</p><p>
						The primary code and all the qualifiers together make up one
						concept. A <emph>CD</emph> with qualifiers is also called a
						<emph>code phrase</emph> or <emph>postcoordinated expression</emph>.
					</p><p>
						Qualifiers constrain the meaning of the primary code, but cannot negate
						it or change it's meaning to that of another value in the primary coding
						system
					</p><p>
						Qualifiers can only be used according to well-defined rules of
						post-coordination. A value of type <emph>CD</emph> may only have qualifiers if it's
						code system defines the use of such qualifiers or if there is a third
						code system that specifies how other code systems may be combined.
					</p><p>
						For example, SNOMED CT allows constructing concepts as a combination
						of multiple codes. SNOMED CT defines a concept "cellulitis (disorder)"
						(128045006) an attribute "finding site" (363698007) and another
						concept "foot structure (body structure)" (56459004). SNOMED CT allows
						one to combine these codes in a code phrase:
					</p><exhibit role="example" verbatim="yes">
&lt;observation&gt;
   ...
   &lt;value code="128045006" codeSystem="&amp;amp;SNOMED-CT;" displayName="cellulitis (disorder)"&gt;
      &lt;qualifier code="56459004" displayName="foot structure"&gt;
         &lt;name code="363698007" displayName="finding site"/&gt;
      &lt;/qualifier&gt;
   &lt;/value&gt;
   ...
&lt;/observation&gt;</exhibit><p>
						In this example, there is one code system, SNOMED-CT that defines the
						primary code and all the qualifiers and how these are used, which is why in our
						example representation the codeSystem does not need to be mentioned for the
						qualifier name and value (the codeSystem is inherited from the primary code.)
					</p><p>
						It is important to note that the allowable qualifiers are specified by
						the code system. For instance, in SNOMED CT, there is a defined set of
						qualifying attributes, and only Findings and Disorders can be
						qualified with the "finding site" attribute. Use of qualifiers outside
						the boundaries specified by the code system is a non-conformant use of
						the <emph>CD</emph> data type. Adherence to the rules specified by the code system
						enables post-coordinated expressions to be compared with
						pre-coordinated concepts (such as where one might compare the above
						code phrase to the pre-coordinated concept "cellulitis of foot
						(disorder)" (128276007), which is defined within SNOMED CT as having a
						finding site of foot structure).   <emph>CD</emph> does not provide
						for normalization of compositional expressions, therefore it is
						possible to create ambiguous expressions.  Users should understand
						that they must provide the additional constraints necessary to assure
						unambiguous data representation, if they are planning to create
						compositional expressions using <emph>CD</emph>.  Otherwise, they risk
						the inability to retrieve a complete set of all records corresponding
						to any given query.
					</p><p>
						Another common example is the U.S. Centers for Medicare and Medicaid
						Services (CMS) (previously known as the Health Care Financing
						Administration, HCFA) procedure codes. CMS procedure codes (HCPCS) are
						based on CPT-4 and add additional qualifiers to it. For example, the
						patient with above finding (plus peripheral arterial disease, diabetes
						mellitus, and a chronic skin lesion at the left great toe) may have an
						amputation of that toe. The CPT-4 concept is "Amputation, toe
						metatarsophalangeal joint" (28820) and a HCPCS qualifier needs to be
						added to indicate "left foot, great toe" (TA). Thus we code:
					</p><exhibit role="example" verbatim="yes">
&lt;procedure&gt;
   ...
   &lt;cd code="28820" codeSystem="&amp;amp;CP4;" displayName="Amputation, toe metatarsophalangeal joint"&gt;
      &lt;qualifier code="TA" codeSystem="&amp;amp;HCP;" displayName="left foot, great toe"/&gt;
   &lt;/cd&gt;
   ...
&lt;/procedure&gt;</exhibit><p>
						In this example, the code system of the qualifier (HCPCS) is different
						than the code system of the primary code (CPT-4.) It is only because
						there are well-defined rules that define how these codes can be
						combined, that the qualifier may be used. Note also, that the role
						name is optional, and for HCPCS codes there are no distinguished role
						names.
					</p><p>
						The order of qualifiers is preserved, particularly for the case where
						the coding system allows post-coordination but defines no role
						names. (e.g., some ICD-9CM codes, or the old SNOMED "multiaxial"
						coding.)
					</p></div3><div3 id="prop-CD.equal"><head>Equality : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref></head><p>
						The main use of concept descriptors is for the purpose of indexing,
						querying and decision-making based on a coded value. A semantically
						unambiguous specification of coded values therefore requires a clear
						definition of what equality of concept descriptor values means and how
						<emph>CD</emph> values should be compared. (For more details on
						comparing pre- and post-coordinated expressions, see Dolin RH,
						Spackman KA, Markwell D. Selective Retrieval of Pre- and
						Post-coordinated SNOMED Concepts. Fall AMIA 2002; 210-14, or the July
						2003 SNOMED CT Implementation Guide.)
					</p><p>
						The equality of two <emph>CD</emph> values is determined solely
						based upon <termref ref="prop-CD.code">code</termref> and <termref ref="prop-CD.codeSystem">codeSystem</termref>.
						<termref ref="prop-CD.codeSystemVersion">codeSystemVersion</termref> is
						excluded from the equality test.<footnote><p><termref ref="prop-CD.codeSystemVersion">codeSystemVersion</termref> does not count in the equality test since by
								definition a code symbol must have the same meaning throughout all
								versions of a code system. Between versions, codes may be retired but
								not withdrawn or reused.
							</p></footnote>
						If qualifiers are present, the qualifiers are included in the equality
						test. Translations are not included in the equality test.<footnote><p>
								Translations are not included in the equality test of concept
								descriptors for safety reasons. An alternative would have been to
								consider two <emph>CD</emph> values equal if any of their
								translations are equal. However, some translations may be equal
								because the coding system of that translation is very
								coarse-grained. More sophisticated comparisons between concept
								descriptors are application considerations that are not covered by
								this specification.
							</p></footnote>
						Exceptional <emph>CD</emph> values are not equal even if they have
						the same NULL-flavor or the same original text.<footnote><p>
								NULL-values are exceptional values, not proper concepts. It would be unsafe to 
								equate two values merely on the basis that both are exceptional (e.g., not 
								codable or unknown.)  Likewise there is no guarantee that original text
								represents a meaningful or unique description of the concept so that equality 
								of that original text does not constitute concept equality. The reverse is 
								also true: since there is more than one possible original text for a concept, 
								the fact that original text differs does not constitute a difference of the 
								concepts.
							</p></footnote></p><exhibit role="dtdl"><caption/><pre>
invariant(CD x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.code.equal(y.code)
             .and(x.codeSystem.equal(y.codingSystem))
             .and(x.qualifier.equal(y.qualifier)));
};</pre></exhibit><p>
						Some code systems define certain style options to their code
						values. For example, the U.S. National Drug Code (NDC) has a dash and
						a non-dash form. An example for the dash form may be 1234-5678-90 when
						the non-dash form is 01234567890. Another example for this problem is
						when certain ISO or ANSI code tables define optional alphanumeric and
						numeric forms of two or three character lengths all in one standard.
					</p><p>
						In the case where code systems provide for multiple representations,
						HL7 shall make a ruling about which is the preferred form. HL7 shall
						document that ruling where that respective external coding system is
						recognized. HL7 shall decide upon the preferred form based on criteria
						of practicality and common use. In absence of clear criteria of
						practicality and common use, the safest, most extensible, and least
						stylized (the least decorated) form shall be given
						preference.<footnote><p>
								This ruling at design-time is necessary to prevent HL7 interfaces from
								being burdened by code literal style conversions at runtime. This is
								notwithstanding the fact that some applications may require mapping
								from one form into another if that application has settled with the
								representation option that was not chosen by HL7.
							</p></footnote></p></div3><div3 id="prop-CD.implies"><head>Implies : <termref ref="dt-BL">BL</termref></head><argument name="x" type="CD"/><p><emph role="strong">Definition:</emph>
						Specifies whether this <emph>CD</emph> is a specialization of
						the operand <emph>CD</emph>.
					</p><p>
						Naturally, concepts can be narrowed and widened to include or exclude
						other concepts. Many coding systems have an explicit notion of concept
						specialization and generalization. The HL7 vocabulary principles also
						provide for concept specialization for HL7 defined value sets.
						<emph>implies</emph> is a predicate that compares whether one
						concept is a specialization of another concept, and therefore implies
						that other concept.
					</p><p>
						When writing predicates (e.g., conditional statements) that compare
						two codes, one should usually test for implication not equality of
						codes.
					</p><p>
						For example, in <tabref ref="domain-TelecommunicationAddressUse"/> the
						"telecommunication use" concepts: work (W), home (H), primary home
						(HP), and vacation home (HV) are defined, where both HP and HV imply
						H. When selecting any home phone number, one should test whether the
						given use-code <emph>c</emph><emph>implies</emph> H. Testing for
						<emph>c</emph><emph>equal</emph> H would only find unspecified home
						phone numbers, but not the primary home phone number.
<!-- fixme: why are &nbsp; required above? - seems very crude --></p><p>
						Operationally, implication can be evaluated in one of two ways. The
						code system literals may be designed such that one single hierarchy is
						reflected in the code literal itself (e.g., ICD-9.) Apart from such
						special cases, however, a terminological knowledge base and an
						appropriate subsumption algorithm will be required to evaluate
						implication statements. For post-coordinated coding systems, designing
						such a subsumption algorithm is a non-trivial task.<footnote><p>
								This is one reason why <termref ref="prop-CD.qualifier">qualifier</termref> is to
								be used sparingly for post-coordination and with caution. An additional problem of
								post-coordinated coding is that a general rule for equality may not
								exist at all.
							</p></footnote></p></div3></div2><div2 id="dt-CR"><anchor id="CR"/><head>Concept Role (CR) specializes <termref ref="dt-ANY">ANY</termref></head><p><emph role="strong">Definition:</emph>
					A concept qualifier code with optionally named role.  Both qualifier
					role and value codes must be defined by the coding system of the <termref ref="dt-CD">CD</termref>
					containing the concept qualifier.  For example, if SNOMED RT defines a concept "leg", a
					role relation "has-laterality", and another concept "left", the concept role
					relation allows to add the qualifier "has-laterality: left" to a
					primary code "leg" to construct the meaning "left leg".
				</p><table id="dt-CR-prop-summary"><caption>Property Summary of
      Concept Role</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-CR.name">name</termref></td><td><termref ref="dt-CV">CV</termref></td><td>
						Specifies the manner in which the concept role value contributes to
						the meaning of a code phrase.  For example, if SNOMED RT defines a
						concept "leg", a role relation "has-laterality", and another concept
						"left", the concept role relation allows to add the qualifier
						"has-laterality: left" to a primary code "leg" to construct the
						meaning "left leg".  In this example, <emph>name</emph> is "has-laterality".
					</td></tr><tr><td><termref ref="prop-CR.value">value</termref></td><td><termref ref="dt-CD">CD</termref></td><td>
						The concept that modifies the primary code of a code phrase through
						the role relation.  For example, if SNOMED RT defines a concept "leg",
						a role relation "has-laterality", and another concept "left", the
						concept role relation allows adding the qualifier "has-laterality:
						left" to a primary code "leg" to construct the meaning "left leg".  In
						this example, <termref ref="prop-CR.value">value</termref> is "left".
					</td></tr><tr><td><termref ref="prop-CR.inverted">inverted</termref></td><td><termref ref="dt-BN">BN</termref></td><td>
						Indicates if the sense of <termref ref="prop-CR.name">name</termref> is inverted.  This can be used
						in cases where the underlying code system defines inversion but does
						not provide reciprocal pairs of role names. By default, inverted is
						<emph>false</emph>.
					</td></tr></tbody></table><p>
					The use of qualifiers is strictly governed by the code system
					used. <termref ref="dt-CD">CD</termref> does not permit using code
					qualifiers with code systems that do not provide for qualifiers
					(e.g. pre-coordinated systems, such as LOINC, ICD-10 PCS.)
				</p><exhibit role="dtdl" id="dtdl-CR"><anchor id="dtdl-CR"/><caption/><pre>
protected type ConceptRole alias CR specializes ANY {
   CV  name;
   BN  inverted;
   CD  value;
};</pre></exhibit><div3 id="prop-CR.name"><head>Name : <termref ref="dt-CV">CV</termref></head><p><emph role="strong">Definition:</emph>
						Specifies the manner in which the concept role value contributes to
						the meaning of a code phrase.  For example, if SNOMED RT defines a
						concept "leg", a role relation "has-laterality", and another concept
						"left", the concept role relation allows to add the qualifier
						"has-laterality: left" to a primary code "leg" to construct the
						meaning "left leg".  In this example, <emph>name</emph> is "has-laterality".
					</p><p>
						If the parent <termref ref="prop-CD.codeSystem">CD.codeSystem</termref> allows postcoordination
						but no role names (e.g. SNOMED) then <emph>name</emph> can be NULL.
					</p></div3><div3 id="prop-CR.value"><head>Value : <termref ref="dt-CD">CD</termref></head><p><emph role="strong">Definition:</emph>
						The concept that modifies the primary code of a code phrase through
						the role relation.  For example, if SNOMED RT defines a concept "leg",
						a role relation "has-laterality", and another concept "left", the
						concept role relation allows adding the qualifier "has-laterality:
						left" to a primary code "leg" to construct the meaning "left leg".  In
						this example, <termref ref="prop-CR.value">value</termref> is "left".
					</p><p><emph>value</emph> is of type <termref ref="dt-CD">CD</termref> and thus can in turn have
						qualifiers. This allows qualifiers to nest. Qualifiers can only be
						used as far as the underlying code system defines them. It is not
						allowed to use any kind of qualifiers for code systems that do not
						explicitly allow and regulate such use of qualifiers.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CR x)
      where x.nonNull {
   x.value.nonNull;
};</pre></exhibit></div3><div3 id="prop-CR.inverted"><head>Inversion Indicator : <termref ref="dt-BN">BN</termref></head><p><emph role="strong">Definition:</emph>
						Indicates if the sense of <termref ref="prop-CR.name">name</termref> is inverted.  This can be used
						in cases where the underlying code system defines inversion but does
						not provide reciprocal pairs of role names. By default, inverted is
						<emph>false</emph>.
					</p><p>
						For example, a code system may define the role relation "causes"
						and the concepts "Streptococcus pneumoniae" and "Pneumonia". If
						that code system allows its roles to be inverted, one can construct
						the post-coordinated concept "Pneumococcus pneumonia" through
						"Pneumonia - causes, inverted - Streptococcus pneumoniae."
					</p><p>
						Roles may only be inverted if the underlying coding system allows such
						inversion. Notably, if a coding system defines roles in inverse pairs
						or intentionally does not define certain inversions, the appropriate
						role code (e.g. "caused-by") must be used rather than inversion. It
						must be known whether the inverted property is <emph>true</emph> or
						<emph>false</emph>, since if it is NULL, the role cannot be interpreted.
					</p><note role="its"><p><emph>inverted</emph> should be conveyed in an indicator attribute,
							whose default value is <emph>false</emph>. That way the inverted
							indicator does not have to be sent when the role is not inverted.
						</p></note></div3></div2><div2 id="dt-CS"><anchor id="CS"/><head>Coded Simple Value (CS) specializes <termref ref="dt-CV">CV</termref></head><p><emph role="strong">Definition:</emph>
					Coded data in its simplest form, where only the code is not predetermined.
					The code system and code system version are fixed by the context in which
					the <emph>CS</emph> value occurs. <emph>CS</emph> is used for coded attributes that have a single
					HL7-defined value set.
				</p><table id="dt-CS-prop-summary"><caption>Property Summary of
      Coded Simple Value</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-CS.code">code</termref></td><td><termref ref="dt-ST">ST</termref></td><td>
						The plain code symbol defined by the code system. For example,
						"784.0" is the code symbol of the ICD-9 code "784.0" for headache.
					</td></tr></tbody></table><exhibit role="dtdl" id="dtdl-CS"><anchor id="dtdl-CS"/><caption/><pre>
type CodedSimpleValue alias CS specializes CV {
            ST  code;
   literal  ST;
};</pre></exhibit><p><emph>CS</emph> can only be used in either of the following cases:
				</p><list role="ordered"><item>
						for a coded attribute which has a single HL7-defined code system, and
						where code additions to that value set require formal HL7 action (such
						as harmonization.) Such coded attributes must have type <emph>CS</emph>.
					</item><item>
						for a property in this specification that is assigned to a single code
						system defined either in this specification or defined outside HL7 by a body
						that has authority over the concept and the maintenance of that code system.
					</item></list><p>
					For example, since <termref ref="dt-ED">ED</termref> subscribes to the MIME
					design, it trusts IETF to manage the media type. This includes that this
					specification subscribes to the extension mechanism built into the MIME media
					type code (e.g., "application/x-myapp").
				</p><p>
					For <emph>CS</emph> values, the designation of the domain qualifier
					will always be CNE (<emph>coded, non-extensible</emph>) and the
					context will determine which HL7 values to use.<footnote><p>
							This is not withstanding the fact that an external referenced domain,
							such as the IETF MIME media type may include an extension
							mechanism. These extended MIME type codes would not be considered
							"extensions" in the sense of violating the CNE provision. The CNE
							provision is only violated if an attempt is made in using a different
							code system (by means of <termref ref="prop-CD.codeSystem">CD.codeSystem</termref>), which is not
							possible with <emph>CS</emph>.
						</p></footnote></p><div3 id="prop-CS.code"><head>Code : <termref ref="dt-ST">ST</termref>, inherited from <termref ref="dt-CD">CD</termref></head><exhibit role="dtdl"><caption/><pre>
invariant(CS x)
      where x.nonNull {
   x.code.nonNull;
};</pre></exhibit></div3><div3 id="prop-CS.codeSystem"><head>Code System : <termref ref="dt-UID">UID</termref>, (fixed)</head><p>
						Every non-NULL <emph>CS</emph> value has a defined <emph/>.  The
						ITS representation of <emph>CS</emph> need not explicitly mention
						the code system, because the context mandates one and only one code
						system to be used. Specifying the code system explicitly would be
						redundant. However, <emph/> assumes the
						context-specific default value and is not NULL.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CS x)
      where x.code.nonNull {
   x.codeSystem.nonNull;
   x.codeSystem.equal(CONTEXT.codeSystem);
};</pre></exhibit><p>
						An exceptional <emph>CS</emph> of NULL-flavor <emph>other</emph> indicates that a
						concept could not be coded in the coding system specified. In these cases,
						<termref ref="prop-CS.code">code</termref> must be Null.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CS x)
      where x.other {
   x.code.isNull;
   x.codeSystem.nonNull;
};</pre></exhibit></div3><div3 id="prop-CS.codeSystemName"><head>Code System Name : <termref ref="dt-ST">ST</termref>, (fixed)</head><exhibit role="dtdl"><caption/><pre>
invariant(CS x) {
   x.codeSystemName.equal(CONTEXT.codeSystemName);
};</pre></exhibit></div3><div3 id="prop-CS.codeSystemVersion"><head>Code System Version : <termref ref="dt-ST">ST</termref>, (fixed)</head><exhibit role="dtdl"><caption/><pre>
invariant(CS x) {
   x.codeSystemVersion.equal(CONTEXT.codeSystemVersion);
};</pre></exhibit></div3><div3 id="prop-CS.displayName"><head>Display Name : <termref ref="dt-ST">ST</termref>, (fixed)</head><exhibit role="dtdl"><caption/><pre>
invariant(CS x) {
   x.displayName.notApplicable;
};</pre></exhibit></div3><div3 id="prop-CS.originalText"><head>Original Text : <termref ref="dt-ED">ED</termref>, (fixed)</head><exhibit role="dtdl"><caption/><pre>
invariant(CS x) {
   x.originalText.notApplicable;
};</pre></exhibit></div3><div3 id="prop-CS.translation"><head>Translation : <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-CD">CD</termref>&gt;, (fixed)</head><exhibit role="dtdl"><caption/><pre>
invariant(CS x) {
   x.translation.notApplicable;
};</pre></exhibit></div3><div3 id="prop-CS.qualifier"><head>Qualifier : <termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-CR">CR</termref>&gt;, (fixed)</head><exhibit role="dtdl"><caption/><pre>
invariant(CS x) {
   x.qualifier.notApplicable;
};</pre></exhibit></div3><div3 id="prop-CS.literal"><head>Literal Form</head><exhibit role="dtdl"><caption/><pre>
CS.literal ST {
   ST : /[a-zA-Z0-9_]+/  { $.equal($1); };
};</pre></exhibit><p>
						The string literal form of <emph>CS</emph> is primarily defined for the purposes of
						this specification. The literal form is a string representation of the code
						for the codeSystem for the context of the <emph>CS</emph>. You
						cannot determine <termref ref="prop-CS.codeSystem">codeSystem</termref> or
						<termref ref="prop-CS.codeSystemVersion">codeSystemVersion</termref> from the literal itself,
						so the literal only has use where the context is known.
					</p></div3></div2><div2 id="dt-CV"><anchor id="CV"/><head>Coded Value (CV) specializes <termref ref="dt-CE">CE</termref></head><p><emph role="strong">Definition:</emph>
					Coded data, specifying only a code, code system, and optionally
					display name and original text. Used only as the type of
					properties of other	data types.
				</p><table id="dt-CV-prop-summary"><caption>Property Summary of
      Coded Value</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-CV.code">code</termref></td><td><termref ref="dt-ST">ST</termref></td><td>
						The plain code symbol defined by the code system. For example,
						"784.0" is the code symbol of the ICD-9 code "784.0" for headache.
					</td></tr><tr><td><termref ref="prop-CV.codeSystem">codeSystem</termref></td><td><termref ref="dt-UID">UID</termref></td><td>
						Specifies the code system that defines the code.
					</td></tr><tr><td><termref ref="prop-CV.codeSystemName">codeSystemName</termref></td><td><termref ref="dt-ST">ST</termref></td><td>
						The common name of the coding system.
					</td></tr><tr><td><termref ref="prop-CV.codeSystemVersion">codeSystemVersion</termref></td><td><termref ref="dt-ST">ST</termref></td><td>
						If applicable, a version descriptor defined specifically for the given
						code system.
					</td></tr><tr><td><termref ref="prop-CV.displayName">displayName</termref></td><td><termref ref="dt-ST">ST</termref></td><td>
						A name or title for the code, under which the sending system shows the
						code value to its users.
					</td></tr><tr><td><termref ref="prop-CV.originalText">originalText</termref></td><td><termref ref="dt-ED">ED</termref></td><td>
						The text or phrase used as the basis for the coding.
					</td></tr></tbody></table><exhibit role="dtdl" id="dtdl-CV"><anchor id="dtdl-CV"/><caption/><pre>
type CodedValue alias CV specializes CE {
   ST   code;
   UID  codeSystem;
   ST   codeSystemName;
   ST   codeSystemVersion;
   ST   displayName;
   ED   originalText;
};</pre></exhibit><p><emph>CV</emph> is used when any reasonable use case will require only a
					single code value to be sent. Thus, it should not be used in
					circumstances where multiple alternative codes for a given value are
					desired. This type may be used with both the CNE (<emph>coded,
					non-extensible</emph>) and the CWE (<emph>coded, with
					extensibility</emph>) domain qualifiers.
				</p><div3 id="prop-CV.code"><head>Code : <termref ref="dt-ST">ST</termref>, inherited from <termref ref="dt-CD">CD</termref></head><p><emph role="strong">Definition:</emph>
						The plain code symbol defined by the code system. For example,
						"784.0" is the code symbol of the ICD-9 code "784.0" for headache.
					</p><p>
						A non-exceptional <emph/> value has a non-NULL <emph>code</emph> property
						whose value is a character string that is a symbol defined by the
						coding system identified by <termref ref="prop-CD.codeSystem">codeSystem</termref>. Conversely, a
						<emph/> value without a value for the code property, or with
						a value that is not from the cited coding system is an exceptional
						value (NULL of flavor <emph>other</emph>).
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x)
      where x.nonNull {
   x.code.nonNull;
};</pre></exhibit></div3><div3 id="prop-CV.codeSystem"><head>Code System : <termref ref="dt-UID">UID</termref>, inherited from <termref ref="dt-CD">CD</termref></head><p><emph role="strong">Definition:</emph>
						Specifies the code system that defines the code.
					</p><p>
						Code systems shall be referred to by a <termref ref="dt-UID">UID</termref>, which allows unambiguous 
						reference to standard HL7 codes, other standard code systems, as well as local
						codes. HL7 shall assign a <termref ref="dt-UID">UID</termref> to each of its code
						tables as well as to external standard coding systems that are being
						used with HL7. Local sites must use their ISO Object Identifier
						(<termref ref="dt-OID">OID</termref>) to construct a globally unique local coding
						system identifier.
					</p><p>
						Under HL7's branch, 2.16.840.1.113883, the sub-branches 5 and 6
						contain HL7 standard and external code system identifiers
						respectively. The HL7 Vocabulary Technical Committee maintains these
						two branches.
					</p><p>
						A non-exceptional <emph/> value (i.e. a <emph/>
						value that has a non-null code property) has a non-NULL <emph>codeSystem</emph>
						specifying the system of concepts that defines the code. In other
						words whenever there is a code there is also a code system.
					</p><note role="its"><p>
							Although every non-NULL <emph/> value has a defined code
							system, in some circumstances, the ITS representation for the
							<emph/> value needs not explicitly mention the code
							system. For example, when the context mandates one and only one code
							system to be used specifying the code system explicitly would be
							redundant. However, in that case the <emph>codeSystem</emph> takes on that
							context-specific default value and is not NULL.
						</p></note><exhibit role="dtdl"><caption/><pre>
invariant(CD x)
      where x.code.nonNull {
   x.codeSystem.nonNull;
};</pre></exhibit><p>
						An exceptional <emph/> of NULL-flavor <emph>other</emph> indicates that
						a concept could not be coded in the coding system specified. Thus, for
						these coding exceptions, the code system that did not contain the
						appropriate concept must be provided in <emph>codeSystem</emph>.
					</p><p>
						Some code domains are qualified such that they include the portion of
						any pertinent local coding system that does not simply paraphrase the
						standard coding system (<emph>coded with extensibility</emph>, CWE.)
						If a CWE qualified field actually contains such a local code, the
						coding system must specify the local coding system from which the
						local code was taken. However, for CWE domains the local code is a
						valid member of the domain, so that local codes in CWE domains
						constitute neither an error nor an exceptional (NULL/other) value in
						the sense of this specification.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x)
      where x.other {
   x.code.other;
   x.codeSystem.nonNull;
};</pre></exhibit></div3><div3 id="prop-CV.codeSystemName"><head>Code System Name : <termref ref="dt-ST">ST</termref>, inherited from <termref ref="dt-CD">CD</termref></head><p><emph role="strong">Definition:</emph>
						The common name of the coding system.
					</p><p>
						The code system name has no computational value. The purpose of a code
						system name is to assist an unaided human interpreter of a code value to
						interpret <termref ref="prop-CD.codeSystem">codeSystem</termref>.
						It is suggested &#8212; though
						not absolutely required &#8212; that ITS provide for <emph>codeSystemName</emph> in
						order to annotate the <termref ref="dt-UID">UID</termref> for human comprehension.
					</p><p>
						HL7 systems must not functionally rely on <emph>codeSystemName</emph>. <emph>codeSystemName</emph> can
						never modify the meaning of <termref ref="prop-CD.codeSystem">codeSystem</termref> and
						cannot exist without <termref ref="prop-CD.codeSystem">codeSystem</termref>.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x) {
   x.codeSystemName.nonNull.implies(x.codeSystem.nonNull);
};</pre></exhibit></div3><div3 id="prop-CV.codeSystemVersion"><head>Code System Version : <termref ref="dt-ST">ST</termref>, inherited from <termref ref="dt-CD">CD</termref></head><p><emph role="strong">Definition:</emph>
						If applicable, a version descriptor defined specifically for the given
						code system.
					</p><p>
						HL7 shall specify how these version strings are formed for each
						external code system. If HL7 has not specified how version strings are
						formed for a particular coding system, version designations have no
						defined meaning for such coding system.
					</p><p>
						Different versions of one code system must be compatible. Whenever a
						code system changes in an incompatible way, it will constitute a new
						code system, not simply a different version, regardless of how the
						vocabulary publisher calls it.
					</p><p>
						For example, the publisher of ICD-9 and ICD-10 calls these code
						systems, "revision 9" and "revision 10" respectively. However, ICD-10
						is a complete redesign of the ICD code, not a backward compatible
						version. Therefore, for the purpose of this data type specification,
						ICD-9 and ICD-10 are different code systems, not just different
						versions. By contrast, when LOINC updates from revision "1.0j" to
						"1.0k", HL7 would consider this to be just another version of LOINC,
						since LOINC revisions are backwards compatible.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x) {
   x.codeSystemVersion.nonNull.implies(x.codeSystem.nonNull);
};</pre></exhibit></div3><div3 id="prop-CV.displayName"><head>Display Name : <termref ref="dt-ST">ST</termref>, inherited from <termref ref="dt-CD">CD</termref></head><p><emph role="strong">Definition:</emph>
						A name or title for the code, under which the sending system shows the
						code value to its users.
					</p><p><emph>displayName</emph> is included both as a courtesy to an unaided human
						interpreter of a code value and as a documentation of the name used to
						display the concept to the user. The display name has no functional
						meaning; it can never exist without a code; <!-- FIXME: This isn't
						true! The CWE allows it to exist w/o a code --> and it can never
						modify the meaning of <termref ref="prop-CD.code">code</termref>.
					</p><note><p>
							HL7 offers a "print name" in it's predefined vocabulary domains. These
							values are suitable for use in the displayName.
						</p></note><note><p>
							Display names may not alter the meaning of the code value. Therefore,
							display names should not be presented to the user on a receiving
							application system without ascertaining that the display name
							adequately represents the concept referred to by the code
							value. Communication must not simply rely on the display name. The
							display name's main purpose is to support debugging of HL7 protocol
							data units (e.g., messages.)
						</p></note><exhibit role="dtdl"><caption/><pre>
invariant(CD x) {
   x.displayName.nonNull.implies(x.code.nonNull);
};</pre></exhibit></div3><div3 id="prop-CV.originalText"><head>Original Text : <termref ref="dt-ED">ED</termref>, inherited from <termref ref="dt-CD">CD</termref></head><p><emph role="strong">Definition:</emph>
						The text or phrase used as the basis for the coding.
					</p><p>
						The original text exists in a scenario where an originator of the
						information does not assign a code, but where the code is assigned
						later by a coder (post-coding.)  In the production of a concept
						descriptor, original text may thus exist without a code.
					</p><note><p>
							Although post-coding is often performed from free text information,
							such as documents, scanned images or dictation, multi-media data is
							explicitly not permitted as original text. Also, the original text
							property is not meant to be a link into the entire source
							document. The link between different artifacts of medical information
							(e.g., document and coded result) is outside the scope of this
							specification and is maintained elsewhere in the HL7 standards. The
							original text is an excerpt of the relevant information in the
							original sources, rather than a pointer or exact reproduction. Thus
							the original text is to be represented in plain text form.
   <!-- FIXME: why are we so specific? --></p></note><p>
						Values of type <emph/> may have a non-NULL original text
						property despite having a NULL <termref ref="prop-CD.code">code</termref>. Any <emph/> value
						with <termref ref="prop-CD.code">code</termref> of NULL signifies a coding exception. In this case,
						<emph>originalText</emph> is a name or description of the concept that was
						not coded. Such exceptional <emph/> values may also contain <termref ref="prop-CD.translation">translation</termref>s.
						Such translations directly encode the concept described in <emph>originalText</emph>.
					</p><p>
						A <emph/> can be demoted into an <termref ref="dt-ST">ST</termref>
						value representing only the <emph>originalText</emph> of the <emph/> value.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x)
      where x.originalText.nonNull {
   ((ST)x).equal(x.originalText);
};</pre></exhibit></div3><div3 id="prop-CV.translation"><head>Translation : <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-CD">CD</termref>&gt;, (fixed)</head><exhibit role="dtdl"><caption/><pre>
invariant(CV x) {
   x.translation.notApplicable;
};</pre></exhibit></div3><div3 id="prop-CV.qualifier"><head>Qualifier : <termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-CR">CR</termref>&gt;, (fixed)</head><exhibit role="dtdl"><caption/><pre>
invariant(CV x) {
   x.qualifier.notApplicable;
};</pre></exhibit></div3></div2><div2 id="dt-CO"><anchor id="CO"/><head>Coded Ordinal (CO) specializes <termref ref="dt-CV">CV</termref></head><p><emph role="strong">Definition:</emph>
					Coded data, where the coding system from which the code comes is ordered.
					<emph>CO</emph> adds semantics related to ordering so that models
					that make use of such domains may introduce model elements that involve
					statements about the order of the terms in a domain.
				</p><exhibit role="dtdl" id="dtdl-CO"><anchor id="dtdl-CO"/><caption/><pre>
type CodedOrdinal alias CO specializes CV {
   BL  lessOrEqual(CO o);
   BL  lessThan(CO o);
   BL  greaterThan(CO o);
   BL  greaterOrEqual(CO o);
};</pre></exhibit><p>
					The relative order of <emph>CO</emph> values need not be independently
					obvious in their literal representation. It is expected that an
					application will look up the ordering of these values from some
					table.
				</p><div3 id="prop-CO.lessOrEqual"><head>Less-or-equal : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph>
						The ordering relation is based on lessOrEqual which is taken as
						primitive in this specification.
					</p><p>
						All other order relations can be derived from this one.
						Since <emph>lessOrEqual</emph> is primitive, this accomodates partial orderings.
					</p><p>
						Order relationships typically hold only within a single coding 
						system.
					</p></div3><div3 id="prop-CO.lessThan"><head>Less-than : <termref ref="dt-BL">BL</termref></head><exhibit role="dtdl"><caption/><pre>
invariant(CO x, y)
      where x.nonNull.and(y.nonNull) {
   x.lessThan(y).equal(y.lessOrEqual(x).and(x.equal(y).not));
};</pre></exhibit></div3><div3 id="prop-CO.greaterThan"><head>Greater-than : <termref ref="dt-BL">BL</termref></head><exhibit role="dtdl"><caption/><pre>
invariant(CO x, y)
      where x.nonNull.and(y.nonNull) {
   x.greaterThan(y).equal(y.lessThan(x));
};</pre></exhibit></div3><div3 id="prop-CO.greaterOrEqual"><head>Greater-or-equal : <termref ref="dt-BL">BL</termref></head><exhibit role="dtdl"><caption/><pre>
invariant(CO x, y)
      where x.nonNull.and(y.nonNull) {
   x.greaterOrEqual(y).equal(y.lessOrEqual(x));
};</pre></exhibit></div3></div2><div2 id="dt-CE"><anchor id="CE"/><head>Coded With Equivalents (CE) specializes <termref ref="dt-CD">CD</termref></head><p><emph role="strong">Definition:</emph>
					Coded data that consists of a coded value and, optionally, coded
					value(s) from other coding systems that identify the same
					concept. Used when alternative codes may exist.
				</p><table id="dt-CE-prop-summary"><caption>Property Summary of
      Coded With Equivalents</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-CE.code">code</termref></td><td><termref ref="dt-ST">ST</termref></td><td>
						The plain code symbol defined by the code system. For example,
						"784.0" is the code symbol of the ICD-9 code "784.0" for headache.
					</td></tr><tr><td><termref ref="prop-CE.codeSystem">codeSystem</termref></td><td><termref ref="dt-UID">UID</termref></td><td>
						Specifies the code system that defines the code.
					</td></tr><tr><td><termref ref="prop-CE.codeSystemName">codeSystemName</termref></td><td><termref ref="dt-ST">ST</termref></td><td>
						The common name of the coding system.
					</td></tr><tr><td><termref ref="prop-CE.codeSystemVersion">codeSystemVersion</termref></td><td><termref ref="dt-ST">ST</termref></td><td>
						If applicable, a version descriptor defined specifically for the given
						code system.
					</td></tr><tr><td><termref ref="prop-CE.displayName">displayName</termref></td><td><termref ref="dt-ST">ST</termref></td><td>
						A name or title for the code, under which the sending system shows the
						code value to its users.
					</td></tr><tr><td><termref ref="prop-CE.originalText">originalText</termref></td><td><termref ref="dt-ED">ED</termref></td><td>
						The text or phrase used as the basis for the coding.
					</td></tr><tr><td><termref ref="prop-CE.translation">translation</termref></td><td><termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-CD">CD</termref>&gt;</td><td>
						A set of other concept descriptors that translate this concept
						descriptor into other code systems.
					</td></tr></tbody></table><exhibit role="dtdl" id="dtdl-CE"><anchor id="dtdl-CE"/><caption/><pre>
type CodedWithEquivalents alias CE specializes CD {
   ST       code;
   UID      codeSystem;
   ST       codeSystemName;
   ST       codeSystemVersion;
   ST       displayName;
   ED       originalText;
   SET&lt;CV&gt;  translation;
};</pre></exhibit><p><emph>CE</emph> is used when the use case indicates that alternative
					codes may exist and where it is useful to communicate these.
					<emph>CE</emph> provides for a primary code value, plus a set of
					alternative or equivalent representations.
				</p><div3 id="prop-CE.code"><head>Code : <termref ref="dt-ST">ST</termref>, inherited from <termref ref="dt-CD">CD</termref></head><p><emph role="strong">Definition:</emph>
						The plain code symbol defined by the code system. For example,
						"784.0" is the code symbol of the ICD-9 code "784.0" for headache.
					</p><p>
						A non-exceptional <emph/> value has a non-NULL <emph>code</emph> property
						whose value is a character string that is a symbol defined by the
						coding system identified by <termref ref="prop-CD.codeSystem">codeSystem</termref>. Conversely, a
						<emph/> value without a value for the code property, or with
						a value that is not from the cited coding system is an exceptional
						value (NULL of flavor <emph>other</emph>).
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x)
      where x.nonNull {
   x.code.nonNull;
};</pre></exhibit></div3><div3 id="prop-CE.codeSystem"><head>Code System : <termref ref="dt-UID">UID</termref>, inherited from <termref ref="dt-CD">CD</termref></head><p><emph role="strong">Definition:</emph>
						Specifies the code system that defines the code.
					</p><p>
						Code systems shall be referred to by a <termref ref="dt-UID">UID</termref>, which allows unambiguous 
						reference to standard HL7 codes, other standard code systems, as well as local
						codes. HL7 shall assign a <termref ref="dt-UID">UID</termref> to each of its code
						tables as well as to external standard coding systems that are being
						used with HL7. Local sites must use their ISO Object Identifier
						(<termref ref="dt-OID">OID</termref>) to construct a globally unique local coding
						system identifier.
					</p><p>
						Under HL7's branch, 2.16.840.1.113883, the sub-branches 5 and 6
						contain HL7 standard and external code system identifiers
						respectively. The HL7 Vocabulary Technical Committee maintains these
						two branches.
					</p><p>
						A non-exceptional <emph/> value (i.e. a <emph/>
						value that has a non-null code property) has a non-NULL <emph>codeSystem</emph>
						specifying the system of concepts that defines the code. In other
						words whenever there is a code there is also a code system.
					</p><note role="its"><p>
							Although every non-NULL <emph/> value has a defined code
							system, in some circumstances, the ITS representation for the
							<emph/> value needs not explicitly mention the code
							system. For example, when the context mandates one and only one code
							system to be used specifying the code system explicitly would be
							redundant. However, in that case the <emph>codeSystem</emph> takes on that
							context-specific default value and is not NULL.
						</p></note><exhibit role="dtdl"><caption/><pre>
invariant(CD x)
      where x.code.nonNull {
   x.codeSystem.nonNull;
};</pre></exhibit><p>
						An exceptional <emph/> of NULL-flavor <emph>other</emph> indicates that
						a concept could not be coded in the coding system specified. Thus, for
						these coding exceptions, the code system that did not contain the
						appropriate concept must be provided in <emph>codeSystem</emph>.
					</p><p>
						Some code domains are qualified such that they include the portion of
						any pertinent local coding system that does not simply paraphrase the
						standard coding system (<emph>coded with extensibility</emph>, CWE.)
						If a CWE qualified field actually contains such a local code, the
						coding system must specify the local coding system from which the
						local code was taken. However, for CWE domains the local code is a
						valid member of the domain, so that local codes in CWE domains
						constitute neither an error nor an exceptional (NULL/other) value in
						the sense of this specification.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x)
      where x.other {
   x.code.other;
   x.codeSystem.nonNull;
};</pre></exhibit></div3><div3 id="prop-CE.codeSystemName"><head>Code System Name : <termref ref="dt-ST">ST</termref>, inherited from <termref ref="dt-CD">CD</termref></head><p><emph role="strong">Definition:</emph>
						The common name of the coding system.
					</p><p>
						The code system name has no computational value. The purpose of a code
						system name is to assist an unaided human interpreter of a code value to
						interpret <termref ref="prop-CD.codeSystem">codeSystem</termref>.
						It is suggested &#8212; though
						not absolutely required &#8212; that ITS provide for <emph>codeSystemName</emph> in
						order to annotate the <termref ref="dt-UID">UID</termref> for human comprehension.
					</p><p>
						HL7 systems must not functionally rely on <emph>codeSystemName</emph>. <emph>codeSystemName</emph> can
						never modify the meaning of <termref ref="prop-CD.codeSystem">codeSystem</termref> and
						cannot exist without <termref ref="prop-CD.codeSystem">codeSystem</termref>.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x) {
   x.codeSystemName.nonNull.implies(x.codeSystem.nonNull);
};</pre></exhibit></div3><div3 id="prop-CE.codeSystemVersion"><head>Code System Version : <termref ref="dt-ST">ST</termref>, inherited from <termref ref="dt-CD">CD</termref></head><p><emph role="strong">Definition:</emph>
						If applicable, a version descriptor defined specifically for the given
						code system.
					</p><p>
						HL7 shall specify how these version strings are formed for each
						external code system. If HL7 has not specified how version strings are
						formed for a particular coding system, version designations have no
						defined meaning for such coding system.
					</p><p>
						Different versions of one code system must be compatible. Whenever a
						code system changes in an incompatible way, it will constitute a new
						code system, not simply a different version, regardless of how the
						vocabulary publisher calls it.
					</p><p>
						For example, the publisher of ICD-9 and ICD-10 calls these code
						systems, "revision 9" and "revision 10" respectively. However, ICD-10
						is a complete redesign of the ICD code, not a backward compatible
						version. Therefore, for the purpose of this data type specification,
						ICD-9 and ICD-10 are different code systems, not just different
						versions. By contrast, when LOINC updates from revision "1.0j" to
						"1.0k", HL7 would consider this to be just another version of LOINC,
						since LOINC revisions are backwards compatible.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x) {
   x.codeSystemVersion.nonNull.implies(x.codeSystem.nonNull);
};</pre></exhibit></div3><div3 id="prop-CE.displayName"><head>Display Name : <termref ref="dt-ST">ST</termref>, inherited from <termref ref="dt-CD">CD</termref></head><p><emph role="strong">Definition:</emph>
						A name or title for the code, under which the sending system shows the
						code value to its users.
					</p><p><emph>displayName</emph> is included both as a courtesy to an unaided human
						interpreter of a code value and as a documentation of the name used to
						display the concept to the user. The display name has no functional
						meaning; it can never exist without a code; <!-- FIXME: This isn't
						true! The CWE allows it to exist w/o a code --> and it can never
						modify the meaning of <termref ref="prop-CD.code">code</termref>.
					</p><note><p>
							HL7 offers a "print name" in it's predefined vocabulary domains. These
							values are suitable for use in the displayName.
						</p></note><note><p>
							Display names may not alter the meaning of the code value. Therefore,
							display names should not be presented to the user on a receiving
							application system without ascertaining that the display name
							adequately represents the concept referred to by the code
							value. Communication must not simply rely on the display name. The
							display name's main purpose is to support debugging of HL7 protocol
							data units (e.g., messages.)
						</p></note><exhibit role="dtdl"><caption/><pre>
invariant(CD x) {
   x.displayName.nonNull.implies(x.code.nonNull);
};</pre></exhibit></div3><div3 id="prop-CE.originalText"><head>Original Text : <termref ref="dt-ED">ED</termref>, inherited from <termref ref="dt-CD">CD</termref></head><p><emph role="strong">Definition:</emph>
						The text or phrase used as the basis for the coding.
					</p><p>
						The original text exists in a scenario where an originator of the
						information does not assign a code, but where the code is assigned
						later by a coder (post-coding.)  In the production of a concept
						descriptor, original text may thus exist without a code.
					</p><note><p>
							Although post-coding is often performed from free text information,
							such as documents, scanned images or dictation, multi-media data is
							explicitly not permitted as original text. Also, the original text
							property is not meant to be a link into the entire source
							document. The link between different artifacts of medical information
							(e.g., document and coded result) is outside the scope of this
							specification and is maintained elsewhere in the HL7 standards. The
							original text is an excerpt of the relevant information in the
							original sources, rather than a pointer or exact reproduction. Thus
							the original text is to be represented in plain text form.
   <!-- FIXME: why are we so specific? --></p></note><p>
						Values of type <emph/> may have a non-NULL original text
						property despite having a NULL <termref ref="prop-CD.code">code</termref>. Any <emph/> value
						with <termref ref="prop-CD.code">code</termref> of NULL signifies a coding exception. In this case,
						<emph>originalText</emph> is a name or description of the concept that was
						not coded. Such exceptional <emph/> values may also contain <termref ref="prop-CD.translation">translation</termref>s.
						Such translations directly encode the concept described in <emph>originalText</emph>.
					</p><p>
						A <emph/> can be demoted into an <termref ref="dt-ST">ST</termref>
						value representing only the <emph>originalText</emph> of the <emph/> value.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x)
      where x.originalText.nonNull {
   ((ST)x).equal(x.originalText);
};</pre></exhibit></div3><div3 id="prop-CE.translation"><head>Translation : <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-CD">CD</termref>&gt;, inherited from <termref ref="dt-CD">CD</termref></head><p><emph role="strong">Definition:</emph>
						A set of other concept descriptors that translate this concept
						descriptor into other code systems.
					</p><p><emph>translation</emph> is a set of other <emph/>s that
						each translate the first <emph/> into different code
						systems. Each element of the translation set was translated from the
						first <emph/>. Each translation may, however, also contain
						translations. Thus, when a code is translated multiple times the
						information about which code served as the input to which translation
						will be preserved.
					</p><note><p>
							The translations are quasi-synonyms of one real-world concept. Every
							translation in the set is supposed to express the same meaning "in
							other words."  However, exact synonymy rarely exists between two
							structurally different coding systems. For this reason, not all of the
							translations will be equally exact.
						</p></note></div3><div3 id="prop-CE.qualifier"><head>Qualifier : <termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-CR">CR</termref>&gt;, (fixed)</head><exhibit role="dtdl"><caption/><pre>
invariant(CE x) {
   x.qualifier.notApplicable;
};</pre></exhibit></div3></div2><div2 id="dt-SC"><anchor id="SC"/><head>Character String with Code (SC) specializes <termref ref="dt-ST">ST</termref></head><p><emph role="strong">Definition:</emph>
					A character string that optionally may have a code attached. The text
					must always be present if a code is present.  The code is often a
					local code.
				</p><table id="dt-SC-prop-summary"><caption>Property Summary of
      Character String with Code</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-SC.code">code</termref></td><td><termref ref="dt-CE">CE</termref></td><td>
						A code representing the string data. For example, the string data may
						be a user-message out of a message-catalog where the code represents
						the identifier of the message in the message catalog.
					</td></tr></tbody></table><exhibit role="dtdl" id="dtdl-SC"><anchor id="dtdl-SC"/><caption/><pre>
type CharacterStringWithCode alias SC specializes ST {
   CE code;
};</pre></exhibit><p><emph>SC</emph> is used in cases where coding is exceptional (e.g.,
					user text messages are essentially text messages, and a printable
					message is the important content. Yet, sometimes messages come from a
					catalog of canned messages, which <emph>SC</emph> allows to reference.  
				</p><p>
						Any non-null <emph>SC</emph> value MAY have a code, however, a code MUST NOT be
						given without the text.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(SC x)
      where x.nonNull {
   x.code.nonNull.implies(x.notEmpty);
};</pre></exhibit><div3 id="prop-SC.code"><head>Code : <termref ref="dt-CE">CE</termref></head><p><emph role="strong">Definition:</emph>
						A code representing the string data. For example, the string data may
						be a user-message out of a message-catalog where the code represents
						the identifier of the message in the message catalog.
					</p></div3></div2><graphic source="graphics/dtUML-Identifiers.gif" alt="Instance Identifier data types."/><div2 id="dt-UID"><anchor id="UID"/><head>Unique Identifier String (UID) specializes <termref ref="dt-ST">ST</termref></head><p><emph role="strong">Definition:</emph>
					A unique identifier string is a character string which identifies an
					object in a globally unique and timeless manner. The allowable formats
					and values and procedures of this data type are strictly controlled by
					HL7. At this time, user-assigned identifiers may be certain character
					representations of ISO Object Identifiers (<termref ref="dt-OID">OID</termref>) and DCE Universally
					Unique Identifiers (<termref ref="dt-UUID">UUID</termref>). HL7 also reserves the right to assign other
					forms of <emph>UID</emph>s (<termref ref="dt-RUID">RUID</termref>), such as mnemonic identifiers for code systems.
				</p><p>
					The sole purpose of <emph>UID</emph> is to be a globally and timelessly unique
					identifier. The form of <emph>UID</emph>, whether it is an <termref ref="dt-OID">OID</termref>,
					a <termref ref="dt-UUID">UUID</termref> or a <termref ref="dt-RUID">RUID</termref>, is entirely irrelevant.
					As far as HL7 is concerned, the
					only thing one can do with a <emph>UID</emph> is denote to the object for which it
					stands. Comparison of <emph>UID</emph>s is literal, i.e. if two <emph>UID</emph>s are literally
					identical, they are assumed to denote to the same object. If two <emph>UID</emph>s
					are not literally identical they <emph>may</emph> not denote to the
					same object.
				</p><exhibit role="dtdl" id="dtdl-UID"><anchor id="dtdl-UID"/><caption/><pre>
type UniqueIdentifierString alias UID specializes ST { };</pre></exhibit><p>
					No difference in semantics is recognized between the different
					allowed forms of the <emph>UID</emph>. The different forms are not distinguished
					by a component within or aside from the identifier string itself.
				</p><p>
					Even though this specification recognizes no semantic difference
					between the different forms of the unique identifier forms, there are
					differences of how these identifiers are built and managed, which is
					the sole reason to define subtypes to the <emph>UID</emph> for each of the
					variants.
				</p></div2><div2 id="dt-OID"><anchor id="OID"/><head>ISO Object Identifier (OID) specializes <termref ref="dt-UID">UID</termref></head><p><emph role="strong">Definition:</emph>
					A globally unique string representing an ISO Object Identifier
					(OID) in a form that consists only of numbers and dots (e.g.,
					"2.16.840.1.113883.3.1"). According to ISO, <emph>OID</emph>s are paths in a tree
					structure, with the left-most number representing the root and the
					right-most number representing a leaf.
				</p><p>
					Each branch under the root corresponds to an assigning authority. Each
					of these assigning authorities may, in turn, designate its own set of
					assigning authorities that work under its auspices, and so on down the
					line. Eventually, one of these authorities assigns a unique (to it as
					an assigning authority) number that corresponds to a leaf node on the
					tree. The leaf may represent an assigning authority (in which case the
					root <emph>OID</emph> identifies the authority), or an instance of an object. An
					assigning authority owns a namespace, consisting of its sub-tree.
				</p><p><emph>OID</emph>s are the preferred scheme for unique identifiers. <emph>OID</emph>s should
					always be used except if one of the inclusion criteria for other
					schemes apply.
				</p><p>
					ISO/IEC 8824:1990(E) clause 28 defines the Object Identifier as
				</p><quote><p><emph role="strong">28.9</emph> The semantics of an
						object identifier value are defined by reference to an <emph role="strong">
						object identifier tree</emph>. An object identifier tree is a tree whose root
						corresponds to [the ISO/IEC 8824 standard] and whose vertices [i.e. nodes]
						correspond to administrative authorities responsible for allocating arcs [i.e.
						branches] from that vertex. Each arc from that tree is labeled by an object
						identifier component, which is [an integer number]. Each information object to
						be identified is allocated precisely one vertex (normally a leaf) and no other
						information object (of the same or a different type) is allocated to
						that same vertex. Thus an information object is uniquely and
						unambiguously identified by the sequence of [integer numbers] (object
						identifier components) labeling the arcs in a path from the root to
						the vertex allocated to the information object.
					</p><p><emph role="strong">28.10</emph> An object identifier value is
						semantically an ordered list of object identifier component
						values. Starting with the root of the object identifier tree, each
						object identifier component value identifies an arc in the object
						identifier tree. The last object identifier component value identifies
						an arc leading to a vertex to which an information object has been
						assigned. It is this information object, which is identified by the
						object identifier value. [...]
					</p></quote><exhibit role="dtdl" id="dtdl-OID"><anchor id="dtdl-OID"/><caption/><pre>
type ObjectIdentifier alias OID specializes UID, LIST&lt;INT&gt; {
           INT  leaf;
           OID  butLeaf;
           OID  value(namespace OID);
   literal ST;
};</pre></exhibit><p>
					According to ISO/IEC 8824 an object identifier is a sequence of object
					identifier component values, which are integer numbers. These
					component values are ordered such that the root of the object
					identifier tree is the head of the list followed by all the arcs down
					to the leaf representing the information object identified by the
					OID. The fact that <emph>OID</emph> specializes <termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-INT">INT</termref>&gt;
					represents this path of object identifier component
					values from the root to the leaf.
				</p><p>
					The <emph role="strong">leaf</emph> and "<emph role="strong">butLeaf</emph>"
					properties take the opposite view. The
					leaf is the last object identifier component value in the list, and
					the "butLeaf" property is all of the OID <emph>but</emph> the
					<emph>leaf</emph>. In a sense, the leaf is the identifier value and
					all of the OID but the leaf refers to the namespace in which the leaf
					is unique and meaningful.
				</p><p>
					However, what part of the OID is considered <emph role="strong">value</emph>
					and what is <emph role="strong">namespace</emph> may be viewed differently. In
					general, any OID component sequence to the left can be considered the namespace
					in which the rest of the sequence to the right is defined as a
					meaningful and unique identifier value. The value-property with a
					namespace OID as its argument represents this point of view.<footnote><p>
							The value/namespace view on ISO object identifiers has important
							semantic relevance. It represents the notion of identifier value
							versus identifier assigning authority (= namespace), which is common
							in healthcare information systems in general, and HL7 v2.x in
							particular.
						</p></footnote></p><exhibit role="dtdl"><caption/><pre>
invariant(OID x)
      where x.nonNull {
   x.notEmpty;
   x.tail.isEmpty.implies(x.leaf.equal(x.tail));
   x.tail.notEmpty.implies(x.leaf.equal(x.tail.leaf);
   x.tail.isEmpty.implies(x.butLeaf.isNull);
   x.tail.notEmpty.implies(x.butLeaf.head.equal(x.head)
         .and(x.butLeaf.tail.equal(x.butLeaf(x.tail))));
   forall(OID v; OID n) where v.equal(x.value(n)) {
      n.isEmpty.implies(v.equal(x));
      n.notEmpty.implies(v.equal(x.value(n.tail)));
      };
};</pre></exhibit><div3 id="section-OID.procedures"><head>HL7-Assigned OIDs</head><p>
						HL7 shall establish an OID registry and assign OIDs in its branch for
						HL7 users and vendors upon their request. HL7 shall also assign OIDs
						to public identifier-assigning authorities both U.S. nationally (e.g.,
						the U.S. State driver license bureaus, U.S. Social Security
						Administration, HIPAA Provider ID registry, etc.) and internationally
						(e.g., other countries Social Security Administrations, Citizen ID
						registries, etc.) The HL7 registered OIDs must be used for these
						organizations, regardless whether these organizations have other OIDs
						assigned from other sources.
					</p><p>
						When assigning OIDs to third parties or entities, HL7 shall
						investigate whether an OID is already assigned for such entities
						through other sources. It this is the case, HL7 shall record such OID
						in a catalog, but HL7 shall not assign a duplicate OID in the HL7
						branch. If possible, HL7 shall notify a third party when an OID is
						being assigned for that party in the HL7 branch.
					</p><p>
						Though HL7 shall exercise diligence before assigning an OID in the HL7
						branch to third parties, given the lack of a global OID registry
						mechanism, one cannot make absolutely certain that there is no
						preexisting OID assignment for such third-party entity. Also, a
						duplicate assignment can happen in the future through another
						source. If such cases of supplicate assignment become known to HL7,
						HL7 shall make efforts to resolve this situation. For continued
						interoperability in the meantime, the HL7 assigned OID shall be the
						preferred OID used.
					</p><p>
						While most owners of an OID will "design" their namespace sub-tree in
						some meaningful way, there is no way to generally infer any meaning on
						the parts of an OID. HL7 does not standardize or require any namespace
						sub-structure. An OID owner, or anyone having knowledge about the
						logical structure of part of an OID, may still use that knowledge to
						infer information about the associated object; however, the techniques
						cannot be generalized.
					</p><graphic source="graphics/datyp2fig5.jpg" alt="&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Example for a tree of ISO object identifiers. HL7's OID&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;is 2.16.840.1.113883.&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;"/><p><emph role="strong">An HL7 interface must not rely on any
						knowledge about the substructure of an OID for which it cannot control the
						assignment policies.</emph></p></div3><div3 id="prop-OID.literal"><head>Literal Form</head><p>
						The structured definition of the OID is provided mostly to be faithful
						to the OID specification. Within HL7, OIDs are used as UID strings
						only, i.e., the literal string value is the only thing that is
						communicated and is the only thing that a reciever should have to
						consider when working with UIDs in the scope of the HL7 specification.
					</p><exhibit role="dtdl"><caption/><pre>
OID.literal ST {
   OID : INT "." OID { $.head.equal($1);
                       $.tail.equal($3); }
       | INT         { $.head.equal($1);
                       $.tail.isEmpty; }
};</pre></exhibit><p>
						For compatibility with the DICOM standard, the literal form of the OID
						should not exceed 64 characters. (see DICOM part 5, section 9).
					</p></div3></div2><div2 id="dt-UUID"><anchor id="UUID"/><head>DCE Universal Unique Identifier (UUID) specializes <termref ref="dt-UID">UID</termref></head><p><emph role="strong">Definition:</emph>
					A globally unique string representing a DCE Universal Unique
					Identifier (UUID) in the common UUID format that consists of 5
					hyphen-separated groups of hexadecimal digits having 8, 4, 4, 4,
					and 12 places respectively.
				</p><!-- FIXME: need to make a proper bibliographic reference
     including the URL http://www.opengroup.org/onlinepubs/9629399/apdxa.htm
    --><p>
					Both the UUID and its string representation are defined by the Open
					Group, CDE 1.1 Remote Procedure Call specification, Appendix A.
				</p><p>
					UUIDs are assigned based on Ethernet MAC addresses, the point in time
					of creation and some random component. This mix is believed to
					generate sufficiently unique identifiers without any organizational
					policy for identifier assignment (in fact this piggy-backs on the
					organization of MAC address assignment.)
				</p><p>
					UUIDs are <emph role="strong">not</emph> the preferred identifier
					scheme for use as HL7 UIDs. UUIDs may be used when identifiers are
					issued to objects representing individuals (e.g., entity instance
					identifiers, act event identifiers, etc.) For objects describing
					classes of things or events (e.g., catalog items), OIDs are the
					preferred identifier scheme.
				</p><exhibit role="dtdl" id="dtdl-UUID"><anchor id="dtdl-UUID"/><caption/><pre>
type UniversalUniqueIdentifier alias UUID specializes UID {
   INT  timeLow;
   INT  timeMid;
   INT  timeHighAndVersion;
   INT  clockSequence;
   INT  node;
};</pre></exhibit><div3 id="prop-UUID.literal"><head>Literal Form</head><p>
						The structured definition of the UUID is provided mostly to be
						faithful to the UUID specification. Within HL7, UUIDs are used as UID
						strings only, i.e., the literal string value is the only thing that is
						communicated and is the only thing that a reciever should have to
						consider when working with UIDs in the scope of the HL7 specification.
					</p><p>
						The literal form for the UUID is defined according to the original
						specification of the UUID. However, because the HL7 UIDs are case
						sensitive, for use with HL7, the hexadecimal digits A-F in UUIDs
						must be converted to upper case.
					</p><exhibit role="dtdl" id="dtdl-UUID.literal"><anchor id="dtdl-UUID.literal"/><caption/><pre>
UUID.literal ST {
   UUID        : hex8 "-" hex4 "-" hex4 "-" hex4 "-" hex12 {
                    $.timeLow.equal($1);
                    $.timeMid.equal($3);
                    $.timeHighAndVersion.equal($5);
                    $.clockSequence.equal($7);
                    $.node.equal($9);
                    }

   INT hex4    : hexDigit hexDigit hexDigit hexDigit {
                    $.equal($1.times(16).plus($2)
                     .times(16).plus($3)
                     .times(16).plus($4);
                    }

   INT hex8    : hexDigit hexDigit hexDigit hexDigit
                       hexDigit hexDigit hexDigit hexDigit {
                    $.equal($1.times(16).plus($2)
                     .times(16).plus($3)
                     .times(16).plus($4)
                     .times(16).plus($5)
                     .times(16).plus($6)
                     .times(16).plus($7)
                     .times(16).plus($8);
                     }

   INT hex12    : hexDigit hexDigit hexDigit hexDigit
                        hexDigit hexDigit hexDigit hexDigit
                        hexDigit hexDigit hexDigit hexDigit {
                     $.equal($1.times(16).plus($2)
                      .times(16).plus($3)
                      .times(16).plus($4)
                      .times(16).plus($5)
                      .times(16).plus($6)
                      .times(16).plus($7)
                      .times(16).plus($8)
                      .times(16).plus($9)
                      .times(16).plus($10)
                      .times(16).plus($11)
                      .times(16).plus($12);
                     }

   INT hexDigit : "0"     { $.equal(0); }
                | "1"     { $.equal(1); }
                | "2"     { $.equal(2); }
                | "3"     { $.equal(3); }
                | "4"     { $.equal(4); }
                | "5"     { $.equal(5); }
                | "6"     { $.equal(6); }
                | "7"     { $.equal(7); }
                | "8"     { $.equal(8); }
                | "9"     { $.equal(9); }
                | "A"     { $.equal(10); }
                | "B"     { $.equal(11); }
                | "C"     { $.equal(12); }
                | "D"     { $.equal(13); }
                | "E"     { $.equal(14); }
                | "F"     { $.equal(15); }
};</pre></exhibit><note><p>
							The output of UUID related programs and functions may use all sorts of
							forms, upper case, lower case, and with or without the hyphens that
							group the digits. This variate output must be postprocessed to conform
							to the HL7 specification, i.e., the hyphens must be inserted for the
							8-4-4-4-12 grouping and all hexadecimal digits must be converted to
							upper case.
						</p></note></div3></div2><div2 id="dt-RUID"><anchor id="RUID"/><head>HL7 Reserved Identifier Scheme (RUID) specializes <termref ref="dt-UID">UID</termref></head><p><emph role="strong">Definition:</emph>
					A globally unique string defined exclusively by HL7. Identifiers in
					this scheme are only defined by balloted HL7 specifications. Local
					communities or systems must never use such reserved identifiers based
					on bilateral negotiations.
				</p><p>
					HL7 reserved identifiers are strings that consist only of (US-ASCII)
					letters, digits and hyphens, where the first character must be a
					letter. HL7 may assign these reserved identifiers as mnemonic
					identifiers for major concepts of interest to HL7.
				</p></div2><div2 id="dt-II"><anchor id="II"/><head>Instance Identifier (II) specializes <termref ref="dt-ANY">ANY</termref></head><p><emph role="strong">Definition:</emph>
					An identifier that uniquely identifies a thing or object. Examples
					are object identifier for HL7 RIM objects, medical record number,
					order id, service catalog item id, Vehicle Identification Number
					(VIN), etc. Instance identifiers are defined based on ISO object
					identifiers.
				</p><table id="dt-II-prop-summary"><caption>Property Summary of
      Instance Identifier</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-II.root">root</termref></td><td><termref ref="dt-UID">UID</termref></td><td>
						A unique identifier that guarantees the global uniqueness of the
						instance identifier. The root alone may be the entire instance
						identifier.
					</td></tr><tr><td><termref ref="prop-II.extension">extension</termref></td><td><termref ref="dt-ST">ST</termref></td><td>
						A character string as a unique identifier within the scope of the
						identifier root.
					</td></tr><tr><td><termref ref="prop-II.assigningAuthorityName">assigningAuthorityName</termref></td><td><termref ref="dt-ST">ST</termref></td><td>
						A human readable name or mnemonic for the assigning authority. The Assigning
						Authority Name has no computational value. The purpose of a Assigning Authority
						Name is to assist an unaided human interpreter of an II value to interpret
						the authority. Note: no automated processing must depend on the assigning
						authority name to be present in any form.
					</td></tr><tr><td><termref ref="prop-II.displayable">displayable</termref></td><td><termref ref="dt-BL">BL</termref></td><td>
						Specifies if the identifier is intended for human
						display and data entry (displayable = true) as opposed to pure machine
						interoperation (displayable = false).
					</td></tr></tbody></table><exhibit role="dtdl" id="dtdl-II"><anchor id="dtdl-II"/><caption/><pre>
type InstanceIdentifier alias II specializes ANY {
   ST   extension;
   UID  root;
   ST   assigningAuthorityName;
   BL   equal(ANY x);
};</pre></exhibit><div3 id="prop-II.root"><head>Root : <termref ref="dt-UID">UID</termref></head><p><emph role="strong">Definition:</emph>
						A unique identifier that guarantees the global uniqueness of the
						instance identifier. The root alone may be the entire instance
						identifier.
					</p><!-- FIXME: integrate new language about root --><p>
						In the presence of a non-null extension, the root is commonly
						interpreted as the "assigning authority", that is, it is supposed that
						the root somehow refers to an organization that assigns identifiers
						sent in the extension. However, the root does not have to be an
						organizational UID, it can also be a UID specifically registered for
						an identifier scheme.<footnote><p>
								DICOM objects are identified by UID only. For the purpose of DICOM/HL7
								integration, it would be awkward if HL7 required the extension to be
								mandatory and to consider the UID only as an assigning
								authority. Since UID values are simpler and do not contain the risks
								of containing meaningless decoration, we do encourage systems to use
								simple UID identifiers as external references to their objects.
							</p></footnote></p><exhibit role="dtdl"><caption/><pre>
invariant(II x)
      where x.nonNull {
   root.nonNull;
};</pre></exhibit></div3><div3 id="prop-II.extension"><head>Extension : <termref ref="dt-ST">ST</termref></head><p><emph role="strong">Definition:</emph>
						A character string as a unique identifier within the scope of the
						identifier root.
					</p><p>
						The extension is a character string that is unique in the namespace
						designated by the root. If a non-NULL extension is exists, the root
						specifies a namespace (sometimes called "assigning authority" or
						"identifier type".)  The extension property may be NULL in which case
						the root <termref ref="dt-OID">OID</termref> is the complete unique identifier.
					</p><p>
						The root and extension scheme effectively means that the concatenation
						of root and extension must be a globally unique identifier for the
						item that this II value identifies.
					</p><p>
						It is recommended that systems use the <termref ref="dt-OID">OID</termref> scheme for external
						identifiers of their communicated objects. The extension property is
						mainly provided to accommodate legacy alphanumeric identifier schemes.
					</p><p>
						Some identifier schemes define certain style options to their code
						values. For example, the U.S. Social Security Number (SSN) is normally
						written with dashes that group the digits into a pattern
						"123-12-1234". However, the dashes are not meaningful and a SSN can
						just as well be represented as "123121234" without the dashes.
					</p><p>
						In the case where identifier schemes provide for multiple
						representations, HL7 shall make a ruling about which is the preferred
						form. HL7 shall document that ruling where that respective external
						identifier scheme is recognized. HL7 shall decide upon the preferred
						form based on criteria of practicality and common use. In absence of
						clear criteria of practicality and common use, the safest, most
						extensible, and least stylized (the least decorated) form shall be
						given preference.<footnote><p>
								This ruling at design-time is necessary to prevent HL7 interfaces from
								being burdened by identifier literal style conversions at
								runtime. This is notwithstanding the fact that some applications may
								require mapping from one form into another if that application has
								settled with the representation option that was not chosen by HL7.
							</p><p>
								From practical experience it is recommended that II.extensions as
								an alphanumeric identifier not contain leading zero digits (if any
								zeroes at all), for these are often erroneously stripped. "000123"
								and "123" would be different extension values, but this is prone
								to be misunderstood, leading to false non-matches and duplicate
								record entries. However applications should maintain any leading zero
								digits encountered in II extensions. Leading zero digits are
								prohibited in <termref ref="dt-OID">OID</termref>'s, but may occur in <termref ref="dt-UUID">UUID</termref>'s,
								where they must be maintained.
							</p><p>
								There is no separate check digit property. Check digits are used
								for human purpose and work best if kept completely transparent.
								II.extensions MAY contain check digits anywhere, and the
								particular check digit scheme (if any) would be implied by the
								II.root. However, a separate check digit property is intentionally
								not recognized by this specification.
							</p></footnote></p><p>
						HL7 may also decide to map common external identifiers to the value
						portion of the II.root <termref ref="dt-OID">OID</termref>. For example, the U.S. SSN could be
						represented as 2.16.840.1.113883.4.1.123121234. The criteria of
						practicality and common use will guide HL7's decision on each
						individual case.
					</p></div3><div3 id="prop-II.assigningAuthorityName"><head>Assigning Authority Name : <termref ref="dt-ST">ST</termref></head><p><emph role="strong">Definition:</emph>
						A human readable name or mnemonic for the assigning authority. The Assigning
						Authority Name has no computational value. The purpose of a Assigning Authority
						Name is to assist an unaided human interpreter of an II value to interpret
						the authority. Note: no automated processing must depend on the assigning
						authority name to be present in any form.
					</p><!--- still deleted. assigningAuthorityName was removed at harmonisation
      in Cleveland, but restored after the first membership ballot. The comment
      "can have no computational meaning" was added at this point, to (try to)
      ensure that the presence of assigningAuthorityName didn't confuse people
      about the way that II works. Though since it was always largely redundant
      anyway, this probably won't work. However it was felt that there is a need
      for this property when working on widely distributed messaging systems
      however this text below is still deleted, as it may add to the confusion
      concerning the use of assigningAuthorityName
					<p>
						The assigning authority name is not the name for the individually
						identified object, but for the namespace, that immediately contains
						that object identifier. Two cases exist.
					</p>
					<list role="ordered">
						<item>
							If the extension property is non-NULL, the root <dtref ref='dt-OID'/> identifies the
							assigning authority; hence the assigning authority name is a name or
							mnemonic for the entire root <dtref ref='dt-OID'/>.
						</item>
						<item>
							If the extension is NULL, the assigning authority name is the name or
							mnemonic of the namespace property of the OID value.
						</item>
					</list>
  --></div3><div3 id="prop-II.displayable"><head>Displayable : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph>
						Specifies if the identifier is intended for human
						display and data entry (displayable = true) as opposed to pure machine
						interoperation (displayable = false).
					</p></div3><div3 id="prop-II.equal"><head>Equality : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref></head><p>
						Two instance identifiers are equal if and only if their root and extension
						properties are equal.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(II x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.root.equal(y.root)
             .and(x.extension.equal(y.extension)));
};</pre></exhibit></div3></div2><graphic source="graphics/dtUML-Tel.gif" alt="URL And TEL data types"/><div2 id="dt-URL"><anchor id="URL"/><head>Universal Resource Locator (URL) specializes <termref ref="dt-ANY">ANY</termref></head><p><emph role="strong">Definition:</emph>
					A telecommunications address specified according to Internet standard
					RFC 2396 [<loc href="http://www.ietf.org/rfc/rfc2396.txt" xlink-form="simple" show="embed" actuate="auto"/>]. The
					URI specifies the protocol and the contact point defined by that
					protocol for the resource.  Notable uses of the telecommunication
					address data type are for telephone and telefax numbers, e-mail
					addresses, Hypertext references, FTP references, etc.
				</p><p>
					The Internet standard RFC 2396 [<loc href="http://www.ietf.org/rfc/rfc2396.txt" xlink-form="simple" show="embed" actuate="auto"/>] defines a URI as
					follows:
				</p><quote><p>
						Just as there are many different methods of access to resources, there
						are several schemes for describing the location of such resources.
						The generic syntax for URLs provides a framework for
						new schemes to be established using protocols other than those defined
						in this document.
					</p><p>
						URLs are used to "locate" resources, by providing an abstract
						identification of the resource location. Having located a resource, a
						system may perform a variety of operations on the resource, as might
						be characterized by such words as "access", "update", "replace", "find
						attributes". In general, only the "access" method needs to be
						specified for any URL scheme.
					</p><p>
						By agreement, it is permissable to use a URI in place of a URL. In these
						cases, it is still expected that the resources identified is accessible
						by some agreed method. A common use of URI's is to refer to SOAP attachments
					</p></quote><exhibit role="dtdl" id="dtdl-URL"><anchor id="dtdl-URL"/><caption/><pre>
protected type UniversalResourceLocator alias URL specializes ANY {
           CS  scheme;
           ST  address;
   literal ST;
};</pre></exhibit><div3 id="prop-URL.scheme"><head>Scheme : <termref ref="dt-CS">CS</termref></head><p><emph role="strong">Definition:</emph>
						Identifies the protocol used to interpret the address string and 
						to access the resource so addressed.
					</p><p>
						Some URL schemes are registered by the <emph>Internet Assigned Numbers
						Authority</emph> (IANA) [http://www.iana.org], however IANA only
						registers URL schemes that are defined in Internet RFC documents. In
						fact there are a number of URL schemes defined outside RFC documents,
						part of which are registered with the World Wide Web Consortium
						(W3C).<footnote><p>
								The data type of the <emph>scheme</emph> is still <termref ref="dt-CS">CS</termref> and for
								HL7 purposes, the <emph>scheme</emph> is a CNE domain. This appears to be
								at odds with the fact that there is no one official list of URL
								schemes, and so many URL schemes in use may be defined locally.
								However, we cannot allow extension of the <termref ref="dt-URL">URL</termref> scheme
								using the HL7 mechanism of local alternative code systems, which is
								why technically the <emph>scheme</emph> is a <termref ref="dt-CS">CS</termref> data type.
							</p></footnote></p><p>
						Similar to the <termref ref="prop-ED.mediaType">ED.mediaType</termref>, HL7 makes
						suggestions about <emph>scheme</emph> values classifying them as
						<emph>required</emph>, <emph>recommended</emph>, <emph>other</emph>,
						and <emph>deprecated</emph>. Any scheme not mentioned has status
						<emph>other</emph>.
					</p><table id="domain-URLScheme"><caption>Domain URLScheme</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><td>fax</td><td>Fax</td><td>A telephone number served by a fax device [http://www.ietf.org/rfc/rfc3966.txt and http://www.ietf.org/rfc/rfc2806.txt].</td></tr><tr valign="top"><td>file</td><td>File</td><td>Host-specific local file names [RCF 1738].  Note that the file scheme works only for local files.  There is little use for exchanging local file names between systems, since the receiving system likely will not be able to access the file.</td></tr><tr valign="top"><td>ftp</td><td>FTP</td><td>The File Transfer Protocol (FTP) [http://www.ietf.org/rfc/rfc1738.txt].</td></tr><tr valign="top"><td>http</td><td>HTTP</td><td>Hypertext Transfer Protocol [http://www.ietf.org/rfc/rfc2368.txt].</td></tr><tr valign="top"><td>mailto</td><td>Mailto</td><td>Electronic mail address [http://www.ietf.org/rfc/rfc2368.txt].</td></tr><tr valign="top"><td>mllp</td><td>MLLP</td><td>								The traditional HL7 Minimal Lower Layer Protocol.
								The URL has the form of a common IP URL e.g.,
								mllp://&lt;host&gt;:&lt;port&gt;/ with &lt;host&gt; being the IP address or DNS hostname
								and &lt;port&gt; being a port number on which the MLLP protocol is
								served.
</td></tr><tr valign="top"><td>modem</td><td>Modem</td><td>A telephone number served by a modem device  [http://www.ietf.org/rfc/rfc3966.txt and http://www.ietf.org/rfc/rfc2806.txt].</td></tr><tr valign="top"><td>nfs</td><td>NFS</td><td>Network File System protocol [http://www.ietf.org/rfc/rfc2224.txt].  Some sites use NFS servers to share data files.</td></tr><tr valign="top"><td>tel</td><td>Telephone</td><td>A voice telephone number [http://www.ietf.org/rfc/rfc3966.txt and http://www.ietf.org/rfc/rfc2806.txt].</td></tr><tr valign="top"><td>telnet</td><td>Telnet</td><td>Reference to interactive sessions [http://www.ietf.org/rfc/rfc1738.txt].  Some sites, (e.g., laboratories) have TTY based remote query sessions that can be accessed through telnet.</td></tr></table><!--
						<entry code="tel" status="required"/>
						<entry code="fax" status="required"/>
						<entry code="mailto" status="required"/>
						<entry code="http" status="required"/>
						<entry code="ftp" status="required"/>
						<entry code="mllp" status="required" override="graft" printName="HL7 Minimal Lower Layer Protocol">
							<definition>
								The traditional HL7 Minimal Lower Layer Protocol.
								The URL has the form of a common IP URL e.g.,
								mllp://&lt;host>:&lt;port>/ with &lt;host> being the IP address or DNS hostname
								and &lt;port> being a port number on which the MLLP protocol is
								served.
							</definition>
						</entry>
						<entry code="file" status="deprecated"/>
						<entry code="nfs" status="other"/>
						<entry code="telnet" status="other"/>
						<entry code="modem" status="other"/>
					</domain>
--><p>
						Note that this specification explicitly limits itself to URLs.
						Universal Resource Names (URN) are not covered by this specification. URNs are a
						kind of identifier scheme for other than accessible resources. This specification,
						however, is only concerned with accessible resources, which belong into the
						<termref ref="dt-URL">URL</termref> category.
					</p></div3><div3 id="prop-URL.address"><head>Address : <termref ref="dt-ST">ST</termref></head><p><emph role="strong">Definition:</emph>
						The address is a character string whose format is entirely defined by
						the <termref ref="prop-URL.scheme">scheme</termref>.
					</p></div3><div3 id="prop-URL.literal"><head>Literal Form</head><p>
						While conceptually URL has the properties scheme and address,
						the common appearance of a URL is as a string literal formed according
						to the Internet standard. The general syntax of the URL literal is:
					</p><exhibit role="dtdl" id="dtdl-URL.literal"><anchor id="dtdl-URL.literal"/><caption/><pre>
URL.literal ST {
   URL : /[a-z0-9+.-]+/ ":" ST   { $.scheme.equal($1);
                                   $.address.equal($3); }
};</pre></exhibit><descriptive name="Telephone and FAX Numbers"/><p>
						Note that there is no special data type for telephone numbers,
						telephone numbers are <termref ref="dt-TEL">TEL</termref>s and are specified as <emph>URL</emph>s.
					</p><p>
						The telephone number <emph>URL</emph> is defined in Internet RFC 2806
						[<loc href="http://www.ietf.org/rfc/rfc2806.txt" xlink-form="simple" show="embed" actuate="auto"/>]. Its definition is
						summarized in this subsection. This summary does not override or
						change any of the Internet specification's rulings.
					</p><p>
						The voice telephone <emph>URL</emph>s begin with "tel:" and fax URLs begin with
						"fax:"
					</p><p>
						The <termref ref="prop-URL.address">address</termref> is the telephone number in
						accordance with ITU-T E.123 <emph>Telephone Network and ISDN
						Operation, Numbering, Routing and Mobile Service: Notation for
						National and International Telephone Numbers (1993)</emph>. While HL7
						does not add or withdraw from the URL specification, the preferred
						subset of the <termref ref="prop-URL.address">address</termref> address syntax is
						given as follows:
					</p><exhibit role="dtdl"><caption/><pre>
proctected type TelephoneURL specializes URL {
   literal ST {
      URL                 : /(tel)|(fax)/ ":" address   { $.scheme.equal($1);
                                                          $.address.equal($3); };
      ST address          : "+" phoneDigits
      ST phoneDigits      : digitOrSeparator phoneDigits
                          | digitOrSeparator
      ST digitOrSeparator : digit
                          | separator;
      ST digit            : /[0..9]/;
      ST separator        : /[().-]/;
      };
};</pre></exhibit><p>
						The global absolute telephone numbers starting with the "+" and
						country code are preferred. Separator characters serve as decoration
						but have no bearing on the meaning of the telephone number. For
						example: "tel:+13176307960" and "tel:+1(317)630-7960" are both the
						same telephone number; "fax:+49308101724" and "fax:+49(30)8101-724"
						are both the same fax number.
					</p></div3></div2><div2 id="dt-TEL"><anchor id="TEL"/><head>Telecommunication Address (TEL) specializes <termref ref="dt-URL">URL</termref></head><p><emph role="strong">Definition:</emph>
					A telephone number (voice or fax), e-mail address, or other locator
					for a resource mediated by telecommunication equipment. The address is
					specified as a Universal Resource Locator (URL) qualified by time
					specification and use codes that help in deciding which address to use
					for a given time and purpose.
				</p><table id="dt-TEL-prop-summary"><caption>Property Summary of
      Telecommunication Address</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-TEL.useablePeriod">useablePeriod</termref></td><td><termref ref="dt-GTS">GTS</termref></td><td>
						Specifies the periods of time during which the telecommunication
						address can be used.  For a telephone number, this can indicate the
						time of day in which the party can be reached on that telephone.  For
						a web address, it may specify a time range in which the web content is
						promised to be available under the given address.
					</td></tr><tr><td><termref ref="prop-TEL.use">use</termref></td><td><termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</td><td>
						One or more codes advising a system or user which telecommunication
						address in a set of like addresses to select for a given
						telecommunication need.
					</td></tr></tbody></table><p>
					The semantics of a telecommunication address is that a communicating
					entity (the responder) listens and responds to that address, and
					therefore can be contacted by an other communicating entity (the
					initiator.)
				</p><p>
					The responder of a telecommunication address may be an automatic
					service that can respond with information (e.g., FTP or HTTP
					services.)  In such case a telecommunication address is a reference to
					that information accessible through that address. A telecommunication
					address value can thus be resolved to some information (in the form of
					encapsulated data, <termref ref="dt-ED">ED</termref>.)
				</p><exhibit role="dtdl" id="dtdl-TEL"><anchor id="dtdl-TEL"/><caption/><pre>
type TelecommunicationAddress alias TEL specializes URL {
   GTS      useablePeriod;
   SET&lt;CS&gt;  use;
   BL       equal(ANY x);
};</pre></exhibit><p>
					The telecommunication address is an extension of the Universal
					Resource Locator (<termref ref="dt-URL">URL</termref>) specified according to Internet
					standard RFC 2396 [<loc href="http://www.ietf.org/rfc/rfc2396.txt" xlink-form="simple" show="embed" actuate="auto"/>].
					The <termref ref="dt-URL">URL</termref> specifies the protocol and the contact point
					defined by that protocol for the resource. Notable use cases for the
					telecommunication address data type are for telephone and fax numbers,
					e-mail addresses, Hypertext references, FTP references, etc.
				</p><div3 id="prop-TEL.useablePeriod"><head>Useable Period : <termref ref="dt-GTS">GTS</termref></head><p><emph role="strong">Definition:</emph>
						Specifies the periods of time during which the telecommunication
						address can be used.  For a telephone number, this can indicate the
						time of day in which the party can be reached on that telephone.  For
						a web address, it may specify a time range in which the web content is
						promised to be available under the given address.
					</p></div3><div3 id="prop-TEL.use"><head>Use Code : <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</head><p><emph role="strong">Definition:</emph>
						One or more codes advising a system or user which telecommunication
						address in a set of like addresses to select for a given
						telecommunication need.
					</p><!-- fixme: this domain starts with an abstract code. how to include it? --><!--
	pvb: 20050804: this list for the domain is OLD
					<domain table="TelecommunicationAddressUse"/>
							<entry code="H" printName="home">
								<entry code="HP"/>
								<entry code="HV"/>
							</entry>
							<entry code="WP"/>
							<entry code="AS"/>
							<entry code="EC"/>
							<entry code="PG"/>
							<entry code="MC"/>
						</domain>
  --><table id="domain-TelecommunicationAddressUse"><caption>Domain TelecommunicationAddressUse</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><th colspan="3"/></tr><tr valign="top"><td>H</td><td>home address</td><td>A communication address at a home, attempted contacts for business purposes might intrude privacy and chances are one will contact family or other household members instead of the person one wishes to call.  Typically used with urgent cases, or if no other contacts are available.</td></tr><tr valign="top"><td>HP</td><td>primary home</td><td>The primary home, to reach a person after business hours.</td></tr><tr valign="top"><td>HV</td><td>vacation home</td><td>A vacation home, to reach a person while on vacation.</td></tr><tr valign="top"><td>WP</td><td>work place</td><td>An office address.  First choice for business related contacts during business hours.</td></tr><tr valign="top"><td>DIR</td><td>Direct</td><td>Indicates a work place address or telecommunication address that reaches the individual or organization directly without intermediaries.  For phones, often referred to as a 'private line'.</td></tr><tr valign="top"><td>PUB</td><td>Public</td><td>Indicates a work place address or telecommunication address that is a 'standard' address which may reach a reception service, mail-room, or other intermediary prior to the target entity.</td></tr><tr valign="top"><td>BAD</td><td>bad address</td><td>A flag indicating that the address is bad, in fact, useless.</td></tr><tr valign="top"><td>TMP</td><td>temporary address</td><td>A temporary address, may be good for visit or mailing.  Note that an address history can provide more detailed information.</td></tr><tr valign="top"><td>AS</td><td>answering service</td><td>An automated answering machine used for less urgent cases and if the main purpose of contact is to leave a message or access an automated announcement.</td></tr><tr valign="top"><td>EC</td><td>emergency contact</td><td>A contact specifically designated to be used for emergencies.  This is the first choice in emergencies, independent of any other use codes.</td></tr><tr valign="top"><td>MC</td><td>mobile contact</td><td>A telecommunication device that moves and stays with its owner.  May have characteristics of all other use codes, suitable for urgent matters, not the first choice for routine business.</td></tr><tr valign="top"><td>PG</td><td>pager</td><td>A paging device suitable to solicit a callback or to leave a very short message.</td></tr></table><!--
	pvb: 20050804: this is how this domain appears in the XML ITS
							<entry code="H">
								<entry code="HP"/>
								<entry code="HV"/>
							</entry>
							<entry code="WP">
								<entry code="DIR"/>
								<entry code="PUB"/>
							</entry>
							<entry code="BAD"/>
							<entry code="EC"/>
							<entry code="TMP"/>
							<entry code="AS"/>
							<entry code="PG"/>
							<entry code="MC"/>
						</domain>
  --><p>
							The telecommunication use code is not a complete classification for
							equipment types or locations. Its main purpose is to suggest or
							discourage the use of a particular telecommunication address. There
							are no easily defined rules that govern the selection of a
							telecommunication address.
						</p></div3><div3 id="prop-TEL.equal"><head>Equality : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref></head><p>
							Two telecommunication address values are considered equal if both
							their <termref ref="dt-URL">URL</termref>s are equal. Use code and valid time are
							excluded from the equality test.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(TEL x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(((URL)x).equal((URL)y));
};</pre></exhibit></div3></div2><graphic source="graphics/dtUML-Names.gif" alt="&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Data types for Postal Address and Entity Names (Person,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Organization, and Trivial Names) are all based on extensions of&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;a character string.&#xA;&#x9;&#x9;&#x9;&#x9;"/><div2 id="dt-ADXP"><anchor id="ADXP"/><head>Address Part (ADXP) specializes <termref ref="dt-ST">ST</termref></head><p><emph role="strong">Definition:</emph>
					A character string that may have a type-tag signifying its role in the
					address. Typical parts that exist in about every address are street,
					house number, or post box, postal code, city, country but other roles
					may be defined regionally, nationally, or on an enterprise level
					(e.g. in military addresses). Addresses are usually broken up into
					lines, which are indicated by special line-breaking delimiter elements
					(e.g., DEL).
				</p><table id="dt-ADXP-prop-summary"><caption>Property Summary of
      Address Part</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-ADXP.partType">partType</termref></td><td><termref ref="dt-CS">CS</termref></td><td>
						Specifies whether an address part names the street, city, country,
						postal code, post box, etc. If the type is NULL the address part is
						unclassified and would simply appear on an address label as is.
					</td></tr></tbody></table><exhibit role="dtdl" id="dtdl-ADXP"><anchor id="dtdl-ADXP"/><caption/><pre>
protected type AddressPart alias ADXP specializes ST {
   CS  type;
};</pre></exhibit><div3 id="prop-ADXP.partType"><head>Address Part Type : <termref ref="dt-CS">CS</termref></head><p><emph role="strong">Definition:</emph>
						Specifies whether an address part names the street, city, country,
						postal code, post box, etc. If the type is NULL the address part is
						unclassified and would simply appear on an address label as is.
					</p><table id="domain-AddressPartType"><caption>Domain AddressPartType</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><td>ADL</td><td>additional locator</td><td>This can be a unit designator, such as apartment number, suite number, or floor. There may be several unit designators in an address (e.g., "3rd floor, Appt. 342"). This can also be a designator pointing away from the location, rather than specifying a smaller location within some larger one (e.g., Dutch "t.o." means "opposite to" for house boats located across the street facing houses).</td></tr><tr valign="top"><td>UNID</td><td>unit identifier</td><td>The number or name of a specific unit contained within a building or complex, as assigned by that building or complex.</td></tr><tr valign="top"><td>UNIT</td><td>unit designator</td><td>Indicates the type of specific unit contained within a building or complex.  E.g. Appartment, Floor</td></tr><tr valign="top"><td>DAL</td><td>delivery address line</td><td>A delivery address line is frequently used instead of breaking out delivery mode, delivery installation, etc.  An address generally has only a delivery address line or a street address line, but not both.</td></tr><tr valign="top"><td>DINST</td><td>delivery installation type</td><td>Indicates the type of delivery installation (the facility to which the mail will be delivered prior to final shipping via the delivery mode.) Example: post office, letter carrier depot, community mail center, station, etc.</td></tr><tr valign="top"><td>DINSTA</td><td>delivery installation area</td><td>The location of the delivery installation, usually a town or city, and is only required if the area is different from the municipality. Area to which mail delivery service is provided from any postal facility or service such as an individual letter carrier, rural route, or postal route.</td></tr><tr valign="top"><td>DINSTQ</td><td>delivery installation qualifier</td><td>A number, letter or name identifying a delivery installation.  E.g., for Station A, the delivery installation qualifier would be 'A'.</td></tr><tr valign="top"><td>DMOD</td><td>delivery mode</td><td>Indicates the type of service offered, method of delivery.  For example: post office box, rural route, general delivery, etc.</td></tr><tr valign="top"><td>DMODID</td><td>delivery mode identifier</td><td>Represents the routing information such as a letter carrier route number.  It is the identifying number of the designator (the box number or rural route number).</td></tr><tr valign="top"><td>SAL</td><td>street address line</td><td/></tr><tr valign="top"><td>BNR</td><td>building number</td><td>The number of a building, house or lot alongside the street.  Also known as "primary street number".  This does not number the street but rather the building.</td></tr><tr valign="top"><td>BNN</td><td>building number numeric</td><td>The numeric portion of a building number</td></tr><tr valign="top"><td>BNS</td><td>building number suffix</td><td>Any alphabetic character, fraction or other text that may appear after the numeric portion of a building number</td></tr><tr valign="top"><td>STR</td><td>street name</td><td/></tr><tr valign="top"><td>STB</td><td>street name base</td><td>The base name of a roadway or artery recognized by a municipality (excluding street type and direction)</td></tr><tr valign="top"><td>STTYP</td><td>street type</td><td>The designation given to the street.  (e.g. Street, Avenue, Crescent, etc.)</td></tr><tr valign="top"><td>DIR</td><td>direction</td><td>Direction (e.g., N, S, W, E)</td></tr><tr valign="top"><td>CAR</td><td>care of</td><td>The name of the party who will take receipt at the specified address, and will take on responsibility for ensuring delivery to the target recipient</td></tr><tr valign="top"><td>CEN</td><td>census tract</td><td>A geographic sub-unit delineated for demographic purposes.</td></tr><tr valign="top"><td>CNT</td><td>country</td><td>Country</td></tr><tr valign="top"><td>CPA</td><td>county or parish</td><td>A sub-unit of a state or province. (49 of the United States of America use the term "county;" Louisiana uses the term "parish".)</td></tr><tr valign="top"><td>CTY</td><td>municipality</td><td>The name of the city, town, village, or other community or delivery center</td></tr><tr valign="top"><td>DEL</td><td>delimiter</td><td>Delimiters are printed without framing white space.  If no value component is provided, the delimiter appears as a line break.</td></tr><tr valign="top"><td>POB</td><td>post box</td><td>A numbered box located in a post station.</td></tr><tr valign="top"><td>PRE</td><td>precinct</td><td>A subsection of a municipality</td></tr><tr valign="top"><td>STA</td><td>state or province</td><td>A sub-unit of a country with limited sovereignty in a federally organized country.</td></tr><tr valign="top"><td>ZIP</td><td>postal code</td><td>A postal code designating a region defined by the postal service.</td></tr></table><!--
	pvb: 20050804: just get the entries from the vocab
						<entry code="DEL"/>
						<entry code="CNT"/>
						<entry code="STA"/>
						<entry code="CPA"/>
						<entry code="CTY"/>
						<entry code="ZIP"/>
						<entry code="SAL">
							<entry code="BNR">
								<entry code="BNN"/>
							</entry>
							<entry code="DIR"/>
							<entry code="STR">
								<entry code="STB"/>
								<entry code="STTYP"/>
							</entry>
						</entry>
						<entry code="ADL">
							<entry code="UNID"/>
							<entry code="UNIT"/>
						</entry>
						<entry code="CAR"/>
						<entry code="CEN"/>
					</domain>
  --></div3></div2><div2 id="dt-AD"><anchor id="AD"/><head>Postal Address (AD) specializes <termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-ADXP">ADXP</termref>&gt;</head><p><emph role="strong">Definition:</emph>
					Mailing and home or office addresses. A sequence of address parts,
					such as street or post office Box, city, postal code, country, etc.
				</p><p><emph>AD</emph> is primarily used to communicate data that will allow
					printing mail labels, that will allow a person to physically visit
					that address. The postal address data type is not supposed to be a
					container for additional information that might be useful for finding
					geographic locations (e.g., GPS coordinates) or for performing
					epidemiological studies. Such additional information is captured by
					other, more appropriate HL7 elements.
				</p><table id="dt-AD-prop-summary"><caption>Property Summary of
      Postal Address</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-AD.use">use</termref></td><td><termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</td><td>
						A set of codes advising a system or user which address in a set of
						like addresses to select for a given purpose.
					</td></tr><tr><td><termref ref="prop-AD.useablePeriod">useablePeriod</termref></td><td><termref ref="dt-GTS">GTS</termref></td><td>
						A General Timing Specification (GTS) specifying the periods of time
						during which the address can be used.  This is used to specify
						different addresses for different times of the week or year.
					</td></tr><tr><td><termref ref="prop-AD.isNotOrdered">isNotOrdered</termref></td><td><termref ref="dt-BL">BL</termref></td><td>
						A boolean value specifying whether the order of the address parts is known
						or not. While the address parts are always a Sequence, the order in which
						they are presented may or may not be known. Where this matters, the
						isNotOrdered property can be used to convey this information.
					</td></tr><tr><td><termref ref="prop-AD.formatted">formatted</termref></td><td><termref ref="dt-ST">ST</termref></td><td>
						A character string value with the address formatted in lines and with
						proper spacing. This is only a semantic property to define the
						function of some of the address part types.<footnote><p>
								Remember that semantic properties are bare of all control flow
								semantics. The <termref ref="prop-AD.formatted">formatted</termref> could be implemented
								as a "procedure" that would "return" the formatted address, but it
								would not usually be a variable to which one could assign a formatted
								address. However, HL7 does not define applications but only the
								semantics of exchanged data values. Hence, the semantic model
								abstracts from concepts like "procedure", "return", and "assignment"
								but speaks only of property and value.
							</p></footnote></td></tr></tbody></table><p>
					Addresses are conceptualized as text with added logical mark-up. The
					mark-up may break the address into lines and may describe in detail
					the role of each address part if it is known. Address parts occur in
					the address in the order in which they would be printed on a mailing
					label. The approach is similar to HTML or XML markup of text (but it
					is not technically limited to XML representations.)
				</p><p>
					Addresses are essentially sequences of address parts, but add a "use"
					code and a valid time range for information about if and when the
					address can be used for a given purpose.
				</p><exhibit role="dtdl" id="dtdl-AD"><anchor id="dtdl-AD"/><caption/><pre>
type PostalAddress alias AD specializes LIST&lt;ADXP&gt; {
   SET&lt;CS&gt;  use;
   GTS      useablePeriod;
   BL       isNotOrdered;
   BL       equal(ANY x);
   ST       formatted;
};</pre></exhibit><div3 id="prop-AD.use"><head>Use Code : <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</head><p><emph role="strong">Definition:</emph>
						A set of codes advising a system or user which address in a set of
						like addresses to select for a given purpose.
					</p><table id="domain-PostalAddressUse"><caption>Domain PostalAddressUse</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><th colspan="3"/></tr><tr valign="top"><td>H</td><td>home address</td><td>A communication address at a home, attempted contacts for business purposes might intrude privacy and chances are one will contact family or other household members instead of the person one wishes to call.  Typically used with urgent cases, or if no other contacts are available.</td></tr><tr valign="top"><td>HP</td><td>primary home</td><td>The primary home, to reach a person after business hours.</td></tr><tr valign="top"><td>HV</td><td>vacation home</td><td>A vacation home, to reach a person while on vacation.</td></tr><tr valign="top"><td>WP</td><td>work place</td><td>An office address.  First choice for business related contacts during business hours.</td></tr><tr valign="top"><td>DIR</td><td>Direct</td><td>Indicates a work place address or telecommunication address that reaches the individual or organization directly without intermediaries.  For phones, often referred to as a 'private line'.</td></tr><tr valign="top"><td>PUB</td><td>Public</td><td>Indicates a work place address or telecommunication address that is a 'standard' address which may reach a reception service, mail-room, or other intermediary prior to the target entity.</td></tr><tr valign="top"><td>BAD</td><td>bad address</td><td>A flag indicating that the address is bad, in fact, useless.</td></tr><tr valign="top"><td>TMP</td><td>temporary address</td><td>A temporary address, may be good for visit or mailing.  Note that an address history can provide more detailed information.</td></tr><tr valign="top"><th colspan="3">Identifies the different representations of a name.  The representation may affect how the name is used.  (E.g. use of Ideographic for formal communications.)</th></tr><tr valign="top"><td>ABC</td><td>Alphabetic</td><td>Alphabetic transcription of name (Japanese: romaji)</td></tr><tr valign="top"><td>IDE</td><td>Ideographic</td><td>Ideographic representation of name (e.g., Japanese kanji, Chinese characters)</td></tr><tr valign="top"><td>SYL</td><td>Syllabic</td><td>Syllabic transcription of name (e.g., Japanese kana, Korean hangul)</td></tr><tr valign="top"><td>PHYS</td><td>physical visit address</td><td>Used primarily to visit an address.</td></tr><tr valign="top"><td>PST</td><td>postal address</td><td>Used to send mail.</td></tr></table><p>
						An address without specific use code might be a default address useful
						for any purpose, but an address with a specific use code would be
						preferred for that respective purpose.
					</p></div3><div3 id="prop-AD.useablePeriod"><head>Useable Period : <termref ref="dt-GTS">GTS</termref></head><p><emph role="strong">Definition:</emph>
						A General Timing Specification (GTS) specifying the periods of time
						during which the address can be used.  This is used to specify
						different addresses for different times of the week or year.
					</p></div3><div3 id="prop-AD.isNotOrdered"><head>Is Not Ordered : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph>
						A boolean value specifying whether the order of the address parts is known
						or not. While the address parts are always a Sequence, the order in which
						they are presented may or may not be known. Where this matters, the
						isNotOrdered property can be used to convey this information.
					</p></div3><div3 id="prop-AD.equal"><head>Equality : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref></head><p>
						Two address values are considered equal if both contain the same
						address parts, independent of ordering. Use code and valid time are
						excluded from the equality test.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(AD x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal((
      forall(ADXP p) where x.contains(p) {
	     y.contains(p);
	     }).and.(
            forall(ADXP p) where x.contains(p) {
	           y.contains(p);
	           }));
};</pre></exhibit></div3><div3 id="prop-AD.formatted"><head>Formatting Address : <termref ref="dt-ST">ST</termref></head><p><emph role="strong">Definition:</emph>
						A character string value with the address formatted in lines and with
						proper spacing. This is only a semantic property to define the
						function of some of the address part types.<footnote><p>
								Remember that semantic properties are bare of all control flow
								semantics. The <termref ref="prop-AD.formatted">formatted</termref> could be implemented
								as a "procedure" that would "return" the formatted address, but it
								would not usually be a variable to which one could assign a formatted
								address. However, HL7 does not define applications but only the
								semantics of exchanged data values. Hence, the semantic model
								abstracts from concepts like "procedure", "return", and "assignment"
								but speaks only of property and value.
							</p></footnote></p><p>
						The <emph>AD</emph> data type's main purpose is to capture postal addresses,
						such that one can visit that address or send mail to it. Humans will
						look at addresses in printed form, such as on a mailing label. The
						<emph>AD</emph> data type defines precise rules of how its data is
						formatted.<footnote><p>
								These rules for formatting addresses are part of the semantics of
								addresses because addresses are primarily defined as text displayed or
								printed and consumed by humans. Other uses (e.g., epidemiology) are
								secondary &#8212; although not forbidden, the AD
								data type might not serve these other use cases very well, and HL7
								defines better ways to handle these use cases. Note that these
								formatting rules are not ITS issues, since this formatting applies
								to presentations for humans whereas ITS specifications are
								presentations for computer interchange.
							</p></footnote></p><p>
						Addresses are ordered lists of address parts. Each address part is
						printed in the order of the list from left to right and top to bottom
						(or in any other language-specific reading direction, which to
						determine is outside the scope of this specification.)  Every address
						part value is printed. Most address parts are framed by white
						space. The following six rules govern the setting of whitespace.
					</p><list role="ordered"><item>
							Whitespace never accumulates, i.e. two subsequent spaces are the same
							as one. Subsequent line breaks can be reduced to one. Whitespace
							around a line break is not significant.
						</item><item>
							Literals may contain explicit whitespace, subject to the same white
							space reduction rules. There is no notion of a literal line break
							within the text of a single address part.
						</item><item>
							Leading and trailing explicit whitespace is insignificant in all
							address parts, except for delimiter (DEL) address parts.
						</item><item>
							By default, an address part is surrounded by implicit whitespace.
						</item><item>
							Delimiter (DEL) address parts are not surrounded by any implicit white
							space.
						</item><item>
							Leading and trailing explicit whitespace is significant in delimiter
							(DEL) address parts.
						</item></list><p>
						This means that all address parts are generally surrounded by white
						space, but whitespace does never accumulate. Delimiters are never
						surrounded by implicit whitespace and every whitespace contributed
						by preceding or succeeding address parts is discarded, whether it was
						implicit or explicit.
					</p><p>
						The following shows examples of addresses in the XML ITS form.
					</p><quote><p>
							1050 W Wishard Blvd,<br/>
							RG 5th floor,<br/>
							Indianapolis, IN 46240.
						</p></quote><p>
						Can be encoded in any of the following forms:<footnote><p>
								The XML encoding shown here is according to the XML ITS only in order
								to avoid introducing another instance notation. This does not imply
								that the function would only work in XML, nor even that XML is the
								preferred representation.
							</p></footnote></p><p>
						The first form would result from a system that only stores addresses
						as free text or in a list of fields line1, line2, etc.:
					</p><exhibit role="example" verbatim="yes">
&lt;addr use="WP"&gt;
   1050 W Wishard Blvd,
   RG 5th floor,
   Indianapolis, IN 46240
&lt;/addr&gt;</exhibit><p>
						The second form is more specific about the role of the address parts
						than the first one:
					</p><exhibit role="example" verbatim="yes">
&lt;addr use="WP"&gt;
   &lt;streetAddressLine&gt;1050 W Wishard Blvd&lt;/streetAddressLine&gt;,
   &lt;streetAddressLine&gt;RG 5th floor&lt;/streetAddressLine&gt;,
   &lt;city&gt;Indianapolis&lt;/city&gt;,
   &lt;state&gt;IN&lt;/state&gt;
   &lt;postalCode&gt;46240&lt;/postalCode&gt;
&lt;/addr&gt;</exhibit><p>
						This form is the typical form seen in the U.S., where street address
						is sometimes separated, and city, state and ZIP code are always
						separated.
					</p><p>
						The third is even more specific:
					</p><exhibit role="example" verbatim="yes">
&lt;addr use="WP"&gt;
   &lt;houseNumber&gt;1050&lt;/houseNumber&gt;
   &lt;direction&gt;W&lt;/direction&gt;
   &lt;streetName&gt;Wishard Blvd&lt;/streetName&gt;,
   &lt;additionalLocator&gt;RG 5th floor&lt;/additionalLocator&gt;,
   &lt;city&gt;Indianapolis&lt;/city&gt;,
   &lt;state&gt;IN&lt;/state&gt;
   &lt;postalCode&gt;46240&lt;/postalCode&gt;
&lt;/addr&gt;</exhibit><p>
						The latter form above is not used in the USA. However, it is useful
						in Germany, where many systems keep house number as a distinct
						field. For example, the German address:
					</p><quote>
						Windsteiner Weg 54a,<br/>
						D-14165 Berlin
					</quote><p>
						would most likely be encoded as follows<footnote>:
							<p>
								This example shows the strength of the mark-up approach to
								addresses. A typical German system that stores house number and street
								name in separate fields would print the address with street name first
								followed by the house number. For U.S. addresses, this would be wrong
								as the house number in the U.S. is written before the street name. The
								marked-up address allows keeping the natural order of address parts
								and still understanding their role.
							</p></footnote></p><exhibit role="example" verbatim="yes">
&lt;addr use="HP"&gt;
   &lt;streetName&gt;Windsteiner Weg&lt;/streetName&gt;
   &lt;houseNumber&gt;54a&lt;/houseNumber&gt;,
   &lt;country&gt;D&lt;/country&gt;-
   &lt;postalCode&gt;14165&lt;/postalCode&gt;
   &lt;city&gt;Berlin&lt;/city&gt;
&lt;/addr&gt;</exhibit></div3></div2><div2 id="dt-ENXP"><anchor id="ENXP"/><head>Entity Name Part (ENXP) specializes <termref ref="dt-ST">ST</termref></head><p><emph role="strong">Definition:</emph>
					A character string token representing a part of a name. May have a
					type code signifying the role of the part in the whole entity name,
					and a qualifier code for more detail about the name part type.
					Typical name parts for person names are given names, and family names,
					titles, etc.
				</p><table id="dt-ENXP-prop-summary"><caption>Property Summary of
      Entity Name Part</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-ENXP.partType">partType</termref></td><td><termref ref="dt-CS">CS</termref></td><td>
						Indicates whether the name part is a given name, family name, prefix,
						suffix, etc.
					</td></tr><tr><td><termref ref="prop-ENXP.qualifier">qualifier</termref></td><td><termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</td><td>
						The qualifier is a set of codes each of which specifies a certain
						subcategory of the name part in addition to the main name part type.
						For example, a given name may be flagged as a nickname, a family name
						may be a pseudonym or a name of public records.
					</td></tr></tbody></table><exhibit role="dtdl" id="dtdl-ENXP"><anchor id="dtdl-ENXP"/><caption/><pre>
protected type EntityNamePart alias ENXP specializes ST {
   CS       type;
   SET&lt;CS&gt;  qualifier;
};</pre></exhibit><div3 id="prop-ENXP.partType"><head>Name Part Type : <termref ref="dt-CS">CS</termref></head><p><emph role="strong">Definition:</emph>
						Indicates whether the name part is a given name, family name, prefix,
						suffix, etc.
					</p><table id="domain-EntityNamePartType"><caption>Domain EntityNamePartType</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><td>FAM</td><td>family</td><td>Family name, this is the name that links to the genealogy. In some cultures (e.g. Eritrea) the family name of a son is the first name of his father.</td></tr><tr valign="top"><td>GIV</td><td>given</td><td>Given name (don't call it "first name" since this given names do not always come first)</td></tr><tr valign="top"><td>PFX</td><td>prefix</td><td>A prefix has a strong association to the immediately following name part. A prefix has no implicit trailing white space (it has implicit leading white space though). Note that prefixes can be inverted.</td></tr><tr valign="top"><td>SFX</td><td>suffix</td><td>A suffix has a strong association to the immediately preceding name part. A prefix has no implicit leading white space (it has implicit trailing white space though). Suffices can not be inverted.</td></tr><tr valign="top"><td>DEL</td><td>delimiter</td><td>A delimiter has no meaning other than being literally printed in this name representation.  A delimiter has no implicit leading and trailing white space.</td></tr></table><p>
						Not every name part must have a type code, if the type code is
						unknown, not applicable, or simply undefined this is expressed by a
						NULL value (type.isNull). For example, a name may be "Rogan Sulma" and
						it may not be clear which one is a given name or which is a last name,
						or whether Rogan may be a title.
					</p><p>
						Entity names are conceptualized as text with added mark-up. The
						mark-up may describe in detail the role of each name part if it is
						known. Name parts occur in the order in which they would be printed on
						a mailing label. The model is similar to HTML or XML markup of text.
					</p><!--
	removed GDG - ballot disposition Nov 2003. The trouble with this is that
	prefix and suffix may be associated with adjacent parts, and therefore
	some degree of ordering is required. So we remove this (note that we don't
	say that order is required). Though it doesn't really solve anything, just
	sweeps things under the carpet. I guess this will come up again..
					<p>
						Applications are not required to preserve the ordering of the name
						parts.
					</p>
  --></div3><div3 id="prop-ENXP.qualifier"><head>Qualifier : <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</head><p><emph role="strong">Definition:</emph>
						The qualifier is a set of codes each of which specifies a certain
						subcategory of the name part in addition to the main name part type.
						For example, a given name may be flagged as a nickname, a family name
						may be a pseudonym or a name of public records.
					</p><table id="domain-EntityNamePartQualifier"><caption>Domain EntityNamePartQualifier</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><th colspan="3"/></tr><tr valign="top"><td>LS</td><td>Legal status</td><td>For organizations a suffix indicating the legal status, e.g., "Inc.", "Co.", "AG", "GmbH", "B.V." "S.A.",  "Ltd." etc.</td></tr><tr valign="top"><th colspan="3"/></tr><tr valign="top"><th colspan="3"></th></tr><tr valign="top"><td>AC</td><td>academic</td><td>Indicates that a prefix like "Dr." or a suffix like "M.D." or "Ph.D." is an academic title.</td></tr><tr valign="top"><td>NB</td><td>nobility</td><td>In Europe and Asia, there are still people with nobility titles (aristocrats).  German "von" is generally a nobility title, not a mere voorvoegsel.  Others are "Earl of" or "His Majesty King of..." etc.  Rarely used nowadays, but some systems do keep track of this.</td></tr><tr valign="top"><td>PR</td><td>professional</td><td>Primarily in the British Imperial culture people tend to have an abbreviation of their professional organization as part of their credential suffices.</td></tr><tr valign="top"><td>VV</td><td>voorvoegsel</td><td>A Dutch "voorvoegsel" is something like "van" or "de" that might have indicated nobility in the past but no longer so. Similar prefixes exist in other languages such as Spanish, French or Portugese.</td></tr><tr valign="top"><th colspan="3"></th></tr><tr valign="top"><td>AD</td><td>adopted</td><td>The name the person was given at the time of adoption.</td></tr><tr valign="top"><td>BR</td><td>birth</td><td>A name that a person had shortly after being born. Usually for family names but may be used to mark given names at birth that may have changed later.</td></tr><tr valign="top"><td>SP</td><td>spouse</td><td>The name assumed from the partner in a marital relationship (hence the "M"). Usually the spouse's family name. Note that no inference about gender can be made from the existence of spouse names.</td></tr><tr valign="top"><th colspan="3"></th></tr><tr valign="top"><td>CL</td><td>callme</td><td>A callme name is (usually a given name) that is preferred when a person is directly addressed.</td></tr><tr valign="top"><td>IN</td><td>initial</td><td>Indicates that a name part is just an initial. Initials do not imply a trailing period since this would not work with non-Latin scripts.  Initials may consist of more than one letter, e.g., "Ph." could stand for "Philippe" or "Th." for "Thomas".</td></tr><tr valign="top"><td>TITLE</td><td>title</td><td>Indicates that a prefix or a suffix is a title that applies to the whole name, not just the adjacent name part.</td></tr></table><!--
						<entry code="BR"/>
						<entry code="SP"/>
						<entry code="VV"/>
						<entry code="AC"/>
						<entry code="PR"/>
						<entry code="NB"/>
						<entry code="LS"/>
						<entry code="CL"/>
						<entry code="IN" override="graft" printName="initial">
							<definition>
								Indicates that a name part is just an initial.
								Trailing periods should be specified where appropriate since initials do
								not imply a trailing period since this would not work with
								non-Latin scripts.  Initials may consist of more than one letter,
								e.g., "Ph." could stand for "Philippe" or "Th." for "Thomas".
							</definition>
						</entry>
						<entry code="TITLE" override="graft" printName="title">
							<definition>
								Indicates that a prefix or a suffix is a title that applies to the whole
								name, not just the adjacent name part
							</definition>
						</entry>
					</domain>
  --></div3></div2><div2 id="dt-EN"><anchor id="EN"/><head>Entity Name (EN) specializes <termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-ENXP">ENXP</termref>&gt;</head><p><emph role="strong">Definition:</emph>
					A name for a person, organization, place or thing. A sequence of name
					parts, such as given name or family name, prefix, suffix, etc.
					Examples for entity name values are "Jim Bob Walton, Jr.", "Health
					Level Seven, Inc.", "Lake Tahoe", etc. An entity name may be as simple
					as a character string or may consist of several entity name parts,
					such as, "Jim", "Bob", "Walton", and "Jr.", "Health Level Seven" and
					"Inc.", "Lake" and "Tahoe".
				</p><table id="dt-EN-prop-summary"><caption>Property Summary of
      Entity Name</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-EN.use">use</termref></td><td><termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</td><td>
						A set of codes advising a system or user which name in a set of
						names to select for a given purpose.
					</td></tr><tr><td><termref ref="prop-EN.validTime">validTime</termref></td><td><termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;</td><td>
						An interval of time specifying the time during which the name is or
						was used for the entity. This accomodates the fact that people change
						names for people, places and things.
					</td></tr><tr><td><termref ref="prop-EN.formatted">formatted</termref></td><td><termref ref="dt-ST">ST</termref></td><td>
						A character string value with the entity name formatted with
						proper spacing. This is only a semantic property to define the
						function of some of the name part types.<footnote><p>
								Remember that semantic properties are bare of all control flow
								semantics. The <termref ref="prop-EN.formatted">formatted</termref> could be implemented
								as a "procedure" that would "return" the formatted name, but it would
								not usually be a variable to which one could assign a formatted
								name. However, HL7 does not define applications but only the semantics
								of exchanged data values. Hence, the semantic model abstracts from
								concepts like "procedure", "return", and "assignment" but speaks only
								of property and value.
							</p></footnote></td></tr></tbody></table><p>
					Entity names are conceptualized as text with added logical mark-up.
					Name parts occur in a natural order in which they would be displayed,
					as opposed to in a order detemined by name part. The ordeing of the
					name parts is significant a feature that replaces the need for a
					separate "display name" property. Applications may change that
					ordering of name parts to account for their user's customary ordering
					of name parts. The approach is similar to HTML or XML markup of text
					(but it is not technically limited to XML representations.)
				</p><p>
					Entity names are essentially sequences of entity name parts, but add a
					"use" code and a valid time range for information about when the name
					was used and how to choose between multiple aliases that may be valid
					at the same point in time.
				</p><exhibit role="dtdl" id="dtdl-EN"><anchor id="dtdl-EN"/><caption/><pre>
type EntityName alias EN specializes LIST&lt;ENXP&gt; {
   SET&lt;CS&gt;  use;
   IVL&lt;TS&gt;  validTime;
   BL       equal(ANY x);
   ST       formatted;
};</pre></exhibit><div3 id="prop-EN.use"><head>Use Code : <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</head><p><emph role="strong">Definition:</emph>
						A set of codes advising a system or user which name in a set of
						names to select for a given purpose.
					</p><table id="domain-EntityNameUse"><caption>Domain EntityNameUse</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><td>C</td><td>License</td><td>As recorded on a license, record, certificate, etc. (only if different from legal name)</td></tr><tr valign="top"><td>I</td><td>Indigenous/Tribal</td><td>e.g. Chief Red Cloud</td></tr><tr valign="top"><td>L</td><td>Legal</td><td>Known as/conventional/the one you use</td></tr><tr valign="top"><td>P</td><td>pseudonym</td><td>A self asserted name that the person is using or has used.</td></tr><tr valign="top"><td>A</td><td>Artist/Stage</td><td>Includes writer's pseudonym, stage name, etc</td></tr><tr valign="top"><td>R</td><td>Religious</td><td>e.g. Sister Mary Francis, Brother John</td></tr><tr valign="top"><td>SRCH</td><td>search</td><td>A name intended for use in searching or matching.</td></tr><tr valign="top"><td>PHON</td><td>phonetic</td><td>A name spelled phonetically.</td></tr><tr valign="top"><td>SNDX</td><td>Soundex</td><td>A name spelled according to the SoundEx algorithm.</td></tr><tr valign="top"><td>ABC</td><td>Alphabetic</td><td>Alphabetic transcription of name (Japanese: romaji)</td></tr><tr valign="top"><td>SYL</td><td>Syllabic</td><td>Syllabic transcription of name (e.g., Japanese kana, Korean hangul)</td></tr><tr valign="top"><td>IDE</td><td>Ideographic</td><td>Ideographic representation of name (e.g., Japanese kanji, Chinese characters)</td></tr></table><p>
						A name without specific use code might be a default name useful for
						any purpose, but a name with a specific use code would be preferred
						for that respective purpose.
					</p></div3><div3 id="prop-EN.validTime"><head>Valid Time : <termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;</head><p><emph role="strong">Definition:</emph>
						An interval of time specifying the time during which the name is or
						was used for the entity. This accomodates the fact that people change
						names for people, places and things.
					</p><p><emph>EN</emph> conforms to the history item data type extension (<termref ref="dt-HXIT">HXIT</termref>).
					</p></div3><div3 id="prop-EN.equal"><head>Equality : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref></head><p>
						Two name values are considered equal if both conatain the same name
						parts, independent of ordering. Use code and valid time are excluded
						from the equality test.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(EN x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal((
      forall(ENXP p) where x.contains(p) {
	     y.contains(p);
	     }).and.(
            forall(ENXP p) where x.contains(p) {
	           y.contains(p);
	           }));</pre></exhibit></div3><div3 id="prop-EN.formatted"><head>Formatting Entity Names : <termref ref="dt-ST">ST</termref></head><p><emph role="strong">Definition:</emph>
						A character string value with the entity name formatted with
						proper spacing. This is only a semantic property to define the
						function of some of the name part types.<footnote><p>
								Remember that semantic properties are bare of all control flow
								semantics. The <termref ref="prop-EN.formatted">formatted</termref> could be implemented
								as a "procedure" that would "return" the formatted name, but it would
								not usually be a variable to which one could assign a formatted
								name. However, HL7 does not define applications but only the semantics
								of exchanged data values. Hence, the semantic model abstracts from
								concepts like "procedure", "return", and "assignment" but speaks only
								of property and value.
							</p></footnote></p><p>
						The <emph>EN</emph> data type's main purpose is to capture names of people,
						places, and things (entities), so that one can address and refer to
						these entities in speech and writing. Humans will look at names in
						printed form, such as on a mailing label. The <emph>EN</emph> data type
						therefore defines precise rules of how its data is
						formatted.<footnote><p>
								These rules for formatting names are part of the semantics of names
								because the name parts have been designed with the important use case
								of displaying and rendering on labels. Note that these formatting
								rules are not ITS issues, since this formatting applies to
								presentations for humans whereas ITS specifications are presentations
								for computer interchange.
							</p></footnote></p><p>
						Entity names are ordered lists of entity name parts. Each entity name
						part is printed in the order of the list from left to right (or in any
						other language-specific reading direction.)  Every entity name part
						(except for those marked "invisible") is printed. Most entity name
						parts are framed by whitespace. The following six rules govern the
						setting of whitespace.
					</p><list role="ordered"><item>
							Whitespace never accumulates, i.e. two subsequent spaces are the same
							as one.
						</item><item>
							Literals may contain explicit whitespace subject to the same white
							space reduction rules.
						</item><item>
							Except for <emph>prefix</emph>, <emph>suffix</emph> and
							<emph>delimiter</emph> name parts, every name part is surrounded by
							implicit whitespace. Leading and trailing explicit whitespace is
							insignificant in all those name parts.
						</item><item>
							Delimiter name parts are not surrounded by any implicit white
							space. Leading and trailing explicit whitespace is significant in
							delimiter name parts.
						</item><item>
							Prefix name parts only have implicit leading whitespace but no
							implicit trailing whitespace. Trailing explicit whitespace is
							significant in prefix name parts.
						</item><item>
							Suffix name parts only have implicit trailing whitespace but no
							implicit leading whitespace. Leading explicit whitespace is
							significant in suffix name parts.
						</item><item>
							This means that all entity name parts are generally surrounded by
							whitespace, but whitespace does never accumulate. Delimiters are never
							surrounded by implicit whitespace, prefixes are not followed by
							implicit whitespace and suffixes are not preceded by implicit white
							space. Every whitespace contributed by preceding or succeeding name
							parts around those special name parts is discarded, whether it was
							implicit or explicit.
						</item></list></div3><!--
	pvb: text not necessary
				<p>
					Three restrictions to Entity Name are defined in order to allow making
					specific constraints for certain kinds of entities, trivial name
					(<dtref ref="dt-TN"/>), person name (<dtref ref="dt-PN"/>), and
					organization name (<dtref ref="dt-ON"/>).
				</p>
  --><div3><head>Examples</head><p>
						A very simple encoding of  "Adam A. Everyman" would be:
					</p><exhibit role="example" verbatim="yes">
&lt;name&gt;
   &lt;given&gt;Adam&lt;/given&gt;
   &lt;given&gt;A.&lt;/given&gt;
   &lt;family&gt;Everyman&lt;/family&gt;
&lt;/name&gt;</exhibit><p>
						None of the special qualifiers need to be mentioned if they are
						unknown or irrelevant. The next example shows extensive use of
						multiple given names, prefixes, suffixes, for academic degrees,
						nobility titles, <emph>vorvoegsels</emph> ("van"), and professional
						designations.
					</p><exhibit role="example" verbatim="yes">
&lt;name&gt;
   &lt;prefix qualifier="AC"&gt;Dr. phil. &lt;/prefix&gt;
   &lt;given&gt;Regina&lt;/given&gt;
   &lt;given&gt;Johanna&lt;/given&gt;
   &lt;given&gt;Maria&lt;/given&gt;
   &lt;prefix qualifier="NB"&gt;Gr&amp;auml;fin &lt;/prefix&gt;
   &lt;family qualifier="BR"&gt;Hochheim&lt;/family&gt;-&lt;family qualifier="SP"&gt;Weilenfels&lt;/family&gt;
   &lt;suffix qualifier="PR"&gt;NCFSA&lt;/suffix&gt;
&lt;/name&gt;</exhibit><p>
						The next example is an organization name, "Health Level Seven, Inc."
						in simple string form:
					</p><exhibit role="example" verbatim="yes">&lt;name&gt;Health Level Seven, Inc.&lt;/name&gt;</exhibit><p>
						and as a fully parsed name
					</p><exhibit role="example" verbatim="yes">&lt;name&gt;Health Level Seven, &lt;suffix qualifier="LS"&gt;Inc.&lt;/suffix&gt;&lt;/name&gt;</exhibit><p>
						The following example shows a Japanese name in the three forms:
						ideographic (Kanji), syllabic (Hiragana), and alphabetic (Romaji).
					</p><exhibit role="example" verbatim="yes">
&lt;name use="IDE"&gt;
   &lt;family&gt;&#26408;&#26449;&lt;/family&gt;
   &lt;given&gt;&#36890;&#30007;&lt;/given&gt;
&lt;/name&gt;
&lt;name use="SYL"&gt;
   &lt;family&gt;&#12365;&#12416;&#12425;&lt;/family&gt;
   &lt;given&gt;&#12415;&#12385;&#12362;&lt;/given&gt;
&lt;/name&gt;
&lt;name use="ABC"&gt;
   &lt;family&gt;KIMURA&lt;/family&gt;
   &lt;given&gt;MICHIO&lt;/given&gt;
&lt;/name&gt;</exhibit></div3></div2><div2 id="dt-TN"><anchor id="TN"/><head>Trivial Name (TN) specializes <termref ref="dt-EN">EN</termref></head><p><emph role="strong">Definition:</emph>
					A restriction of entity name that is effectively a simple string used
					for a simple name for things and places.
				</p><p><emph>TN</emph> is an <termref ref="dt-EN">EN</termref> that consists of only one name
					part without any name part type or qualifier. The <emph>TN</emph>, and its
					single name part are therefore equivalent to a simple character
					string. This equivalence is expressed by a defined demotion to
					<termref ref="dt-ST">ST</termref> and promotion from <termref ref="dt-ST">ST</termref>.
				</p><exhibit role="dtdl" id="dtdl-TN"><anchor id="dtdl-TN"/><caption/><pre>
type TrivialName alias TN specializes EN {
   demotion   ST;
   promotion  TN (ST x);
};

invariant(TN x) where x.nonNull {
   x.head.nonNull;
   x.tail.isEmpty;
   x.formatted.equal(x.head);
};

invariant(ST x) {
   ((TN)x).head.equal(x);
};</pre></exhibit><p>
					Trivial names are typically used for places and things, such as
					<emph>Lake Erie</emph> or <emph>Washington-Reagan National Airport</emph>:
				</p><exhibit role="example" verbatim="yes">
&lt;name&gt;Lake Erie&lt;/name&gt;
&lt;name&gt;Washington-Reagan National Airport&lt;/name&gt;</exhibit></div2><div2 id="dt-PN"><anchor id="PN"/><head>Person Name (PN) specializes <termref ref="dt-EN">EN</termref></head><p><emph role="strong">Definition:</emph>
					An <termref ref="dt-EN">EN</termref> used when the named Entity
					is a Person. A sequence of name parts, such as given name or
					family name, prefix, suffix, etc. A name part is a restriction of
					entity name part that only allows those entity name parts qualifiers
					applicable to person names. Since the structure of entity name is
					mostly determined by the requirements of person name, the restriction
					is very minor.
				</p><p>
					Since most of the functionality of entity name is in support of person
					names, the person name (PN) is only a very minor
					restriction on the entity name part qualifier.
				</p><exhibit role="dtdl" id="dtdl-PN"><anchor id="dtdl-PN"/><caption/><pre>
type PersonName alias PN specializes EN;

invariant(PN this) {
   forall(ENXP part)
         where this.contains(part) {
      part.qualifier.contains("LS").not;
      }
};</pre></exhibit></div2><div2 id="dt-ON"><anchor id="ON"/><head>Organization Name (ON) specializes <termref ref="dt-EN">EN</termref></head><p><emph role="strong">Definition:</emph>
					An <termref ref="dt-EN">EN</termref> used when the named Entity
					is an Organization. A sequence of name parts.
				</p><p>
					A name for an organization, such as "Health Level Seven, Inc."  An
					organization name consists only of untyped name parts, prefixes,
					suffixes, and delimiters.
				</p><exhibit role="dtdl" id="dtdl-ON"><anchor id="dtdl-ON"/><caption/><pre>
type OrganizationName alias ON specializes EN;

invariant(ON this) {
   forall(ENXP part)
         where this.contains(part) {
      part.type.implies("FAM").not;
      part.type.implies("GIV").not;
      }
};</pre></exhibit><div3 id="PN-examples"><head>Examples</head><p>
						The following is the organization name, "Health Level Seven, Inc." in
						a simple string form:
					</p><exhibit role="example" verbatim="yes">&lt;name&gt;Health Level Seven, Inc.&lt;/name&gt;</exhibit><p>
						And with the legal status "Inc." as a distinguished name part:
					</p><exhibit role="example" verbatim="yes">&lt;name&gt;Health Level Seven, &lt;suffix qualifier="LS"&gt;Inc.&lt;/suffix&gt;&lt;/name&gt;</exhibit></div3></div2><graphic source="graphics/dtUML-Quantities.gif" alt="Quantity Data Types"/><div2 id="dt-QTY"><anchor id="QTY"/><head>Abstract Type Quantity (QTY) specializes <termref ref="dt-ANY">ANY</termref></head><p><emph role="strong">Definition:</emph>
					The quantity data type is an abstract generalization for all data
					types (1) whose value set has an order relation (less-or-equal) and
					(2) where difference is defined in all of the data type's totally
					ordered value subsets.  The quantity type abstraction is needed in
					defining certain other types, such as the interval and the probability
					distribution.
				</p><exhibit role="dtdl" id="dtdl-QTY"><anchor id="dtdl-QTY"/><caption/><pre>
abstract type Quantity alias QTY specializes ANY {
   BL    lessOrEqual(QTY x);
   BL    compares(QTY x);
   TYPE  diffType;
   QTY   minus(QTY x);
   QTY   plus(QTY x);
   BL    isZero;
   BL    lessThan(QTY x);
   BL    greaterOrEqual(QTY x);
   BL    greaterThan(QTY x);
};</pre></exhibit><div3 id="prop-QTY.lessOrEqual"><head>Ordering: less-or-equal : <termref ref="dt-BL">BL</termref></head><argument name="x" type="QTY"/><p><emph role="strong">Definition:</emph>
						A predicate expressing an order relation that is reflexive, asymmetric
						and transitive, between this quantity and another quantity.
					</p><p>
						The <emph>lessOrEqual</emph> relation is defined on any totally ordered partition
						of the quantity data type. A totally ordered partition is a subset of
						the data types's defined values where all elements have a defined
						order (e.g., the integer and real numbers are totally ordered.)
					</p><p>
						By contrast, a partially ordered set is a set where some, but not all
						pairs of elements are comparable through the order relation (e.g., a
						tree structure or the set of physical quantities is a partially
						ordered set.)  Two data values <emph>x</emph> and <emph>y</emph> of an
						ordered type are comparable (<emph>x</emph>.compares(<emph>y</emph>))
						if the less-or-equal relation holds in either way (<emph>x</emph>
						&#8804; <emph>y</emph> or <emph>y</emph> &#8804; <emph>x</emph>).
					</p><p>
						A partial order relation generates totally ordered subsets whose union
						is the entire set (e.g., the set of all length is a totally ordered
						subset of the set of all physical quantities.)
					</p><p>
						For example, a tree structure is partially ordered, where the root is
						considered less or equal to a leaf, but there may not be an order
						among the leafs. Also, physical quantities are partially ordered,
						since an order exists only among quantities of the same dimension
						(e.g., between two lengths, but not between a length and a time.)  A
						totally ordered subset of a tree is a path that transitively connects
						a leaf to the root. The physical dimension of time is a totally
						ordered subset of physical quantities.
					</p><exhibit role="dtdl"><caption/><pre>
invariant (QTY x, y, z)
   where x.nonNull.and(y.nonNull).and(z.nonNull) {
      x.lessOrEqual(x);                                  /* reflexive */
      x.lessOrEqual(y).implies(y.lessOrEqual(x)).not;    /* asymmetric */
      x.lessOrEqual(y).and(y.lessOrEqual(z))
       .implies(x.lessOrEqual(z))                        /* transitive */
};</pre></exhibit></div3><div3 id="prop-QTY.equal"><head>Equality : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref></head><argument name="x" type="ANY"/><p><emph role="strong">Definition:</emph>
						Equality is a reflexive, symmetric, and transitive relation between
						any two data values. Only proper values can be equal, null values
						never are equal (even if they have the same null flavor.)
			        </p><exhibit role="dtdl"><caption/><pre>
invariant(ANY x, y, z)
      where x.nonNull.and(y.nonNull).and(z.nonNull) {
   x.equal(x);                                         /* reflexivity */
   x.equal(y).equal(y.equal(x));                       /* symmetry */
   x.equal(y).and(y.equal(z)).implies(x.equal(z))      /* transitivity */
   x.equal(y).implies(x.dataType.equal(y.dataType);
};</pre></exhibit><p>
						How equality is determined must be defined for each data type. If
						nothing else is specified, two data values are equal if they are
						indistinguishable, that is, if they differ in none of their semantic
						properties. A data type can "override" this general definition of
						equality, by specifying its own equal relationship. This overriding
						of the equality relation can be used to exclude semantic properties
						from the equality test. If a data type excludes semantic properties
						from its definition of equality, this implies that certain properties
						(or aspects of properties) that are not part of the equality test are
						not essential to the meaning of the value.
					</p><p>
						For example the physical quantity has the two semantic properties (1)
						a real number and (2) a coded unit of measure. The equality test,
						however, must account for the fact that, e.g., 1 meter equals 100
						centimeters; independent equality of the two semantic properties is
						too strong a criterion for the equality test. Therefore, physical
						quantity must override the equality definition.
					</p></div3><div3 id="prop-QTY.compares"><head>Comparability : <termref ref="dt-BL">BL</termref></head><argument name="x" type="QTY"/><p><emph role="strong">Definition:</emph>
						A predicate indicating if this value and the operand can be compared
						as to which is greater than the other.
					</p><p>
						Two quantities are comparable if they are both elements of a common
						totally ordered partition of their data types' value space. The
						definition is based on <termref ref="prop-QTY.lessOrEqual">lessOrEqual</termref>.
					</p><exhibit role="dtdl"><caption/><pre>
invariant (QTY x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.compares(y).equal(x.lessOrEqual(y).or(y.lessOrEqual(x)));
};</pre></exhibit></div3><div3 id="prop-QTY.diffType"><head>DifferenceDataType : <termref ref="dt-TYPE">TYPE</termref></head><p><emph role="strong">Definition:</emph>
						The type of the difference between 2 values of a specific QTY data type.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(QTY x) {
   x.diffType.implies(QTY)
};</pre></exhibit><p>
						The type will be some data type that further specializes QTY
					</p></div3><div3 id="prop-QTY.minus"><head>Difference : <termref ref="dt-QTY">QTY</termref></head><argument name="x" type="QTY"/><p><emph role="strong">Definition:</emph>
						A quantity expressing the "distance" of this quantity from the operand
						quantity, that must be comparable. The data type of the difference
						quantity is related to the operand quantities but need not be the
						same.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(QTY x, y) {
   x.minus(y).implies(x.diffType);
};</pre></exhibit><p>
						The result of minus has the data type returned by the
						diffType property of the instance.
					</p><p>
						A difference is defined in an ordered set if it is semantically
						meaningful to state that &#916; is the difference between the values
						<emph>x</emph> and <emph>y</emph>. This difference &#916; must be
						meaningful independently from the values <emph>x</emph> and
						<emph>y</emph>. This independence exists if for all values
						<emph>u</emph> one can meaningfully derive a value <emph>v</emph> such
						that &#916; would also be the difference between <emph>u</emph> and
						<emph>v</emph>. The judgment for what is <emph>meaningful</emph>
						cannot be defined formally.<footnote><p>
								The quantity data type abstraction corresponds to the notion of
								difference scales in contrast to ordinal scales and ratio scales
								(Guttman and Stevens). A data type with only the order requirement but
								not the difference requirement would be an ordinal. Ordinals are not
								currently defined with a special data type. Instead, ordinals are
								usually coded values, where the underlying code system specifies
								ordinal semantics. This ordinal semantics, however, is not reflected
								in the HL7 data type semantics at this time.
							</p></footnote></p><p><emph>minus</emph> has a data type that can express the difference between
						two values for which the ordering relation is defined (i.e., two
						elements of a common totally ordered subset.)  For example, the
						difference data type of integer number is integer number, but the
						difference type of point in time is a physical quantity in the
						dimension of time. A difference data type is a totally ordered data
						type.
					</p><p>
						The difference between two values <emph>x</emph> minus <emph>y</emph>
						must be defined for all <emph>x</emph> and <emph>y</emph> in a common
						totally ordered subset of the data type's value set. Zero is the
						difference between a value and itself.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(QTY x, y)
      where x.compares(y) {
   x.minus(y).nonNull;
   x.minus(x).isZero;
};</pre></exhibit><p>
						If x and y are not comparable, then the difference will be Null
					</p><exhibit role="dtdl"><caption/><pre>
invariant(QTY x, y)
      where x.compares(y).Not {
   x.minus(y).notApplicable;
};</pre></exhibit></div3><div3 id="prop-QTY.plus"><head>Addition : <termref ref="dt-QTY">QTY</termref></head><argument name="x" type="QTY"/><p><emph role="strong">Definition:</emph>
						The sum of this quantity and its operand. The operand must be of a
						data type that can express the difference between two values of this
						quantity's data type.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(QTY x, y)
      where x.compares(y) {
   x.plus(y.minus(x)).equal(y);
   y.dataType.implies(x.diffType);
};</pre></exhibit><p>
						Q: what is the relationship between
						  {y.dataType.implies(x.diffType)}
						and
						  {x.compares(y)}?
					</p><p>
						If <emph>y</emph> is not a valid type for the difference between two
						values of the type of <emph>x</emph>, the the result of the operation
						will be NULL.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(QTY x, y)
      where y.dataType.implies(x.diffType).not {
   x.plus(y).notApplicable;
};</pre></exhibit></div3><div3 id="prop-QTY.isZero"><head>The Zero-Quantity : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph>
						The neutral element in the difference and addition operations, i.e.,
						if a quantity is zero, addition to, or subtraction from any other
						comparable quantity will result in that other quantity.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(QTY x) {
   x.minus(x).isZero;
};</pre></exhibit></div3><div3 id="prop-QTY.lessThan"><head>Ordering: less-than : <termref ref="dt-BL">BL</termref></head><argument name="x" type="QTY"/><p><emph role="strong">Definition:</emph>
						A predicate expressing an order relation that is asymmetric and
						transitive, between this quantity and another quantity. The ordering
						is the same as <termref ref="prop-QTY.lessOrEqual">lessOrEqual</termref>, but irreflexive.
					</p><exhibit role="dtdl"><caption/><pre>
invariant (QTY x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.lessThan(y).equal(x.lessOrEqual(y)
                .and(x.equal(y).not));
};</pre></exhibit></div3><div3 id="prop-QTY.greaterOrEqual"><head>Ordering: greater-or-equal : <termref ref="dt-BL">BL</termref></head><argument name="x" type="QTY"/><p><emph role="strong">Definition:</emph>
						A predicate expressing an order relation that is reflexive, asymmetric
						and transitive, between this quantity and another quantity. This is
						the inverse order of <termref ref="prop-QTY.lessOrEqual">lessOrEqual</termref>.
					</p><exhibit role="dtdl"><caption/><pre>
invariant (QTY x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.greaterOrEqual(y).equal(y.lessOrEqual(x));
};</pre></exhibit></div3><div3 id="prop-QTY.greaterThan"><head>Ordering: greater-than : <termref ref="dt-BL">BL</termref></head><argument name="x" type="QTY"/><p><emph role="strong">Definition:</emph>
						A predicate expressing an order relation that is asymmetric and
						transitive, between this quantity and another quantity. This
						is the invese of <termref ref="prop-QTY.lessThan">lessThan</termref>.
					</p><exhibit role="dtdl"><caption/><pre>
invariant (QTY x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.greaterThan(y).equal(y.lessThan(x));
};</pre></exhibit></div3></div2><div2 id="dt-INT"><anchor id="INT"/><head>Integer Number (INT) specializes <termref ref="dt-QTY">QTY</termref></head><p><emph role="strong">Definition:</emph>
					Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise numbers
					that are results of counting and enumerating. Integer numbers are
					discrete, the set of integers is infinite but countable.  No arbitrary
					limit is imposed on the range of integer numbers. Two NULL flavors are
					defined for the positive and negative infinity.
				</p><exhibit role="dtdl" id="dtdl-INT"><anchor id="dtdl-INT"/><caption/><pre>
type IntegerNumber alias INT specializes QTY {
           INT  successor;
           INT  times(INT x);
           INT  predecessor;
           INT  negated;
           BL   isNegative;
           BL   nonNegative;
           INT  dividedBy(INT x);
           INT  remainder(INT x);
           BL   isOne;
  literal  ST;
};</pre></exhibit><p>
					Since the integer number data type includes all of the semantics of
					the mathematical integer number concept, the basic operations plus
					(addition) and times (multiplication) are defined. These operations
					are defined here as characterizing operations in the sense of ISO
					11404, and because these operations are needed in other parts of this
					specification, namely the semantics of the literal form.
				</p><p>
					The traditional recursive definitions of addition and multiplication
					are due to Grassmann, and use the notion of <termref ref="prop-INT.successor">successor</termref>.<footnote><p>
							H. Grassman. <emph>Lehrbuch der Arithmetik.</emph> 1861. We prefer
							Grassman's original axioms to the Peano axioms, because Grassman's
							axioms work for all integers, not just for natural numbers. Also, "it
							is rather well-known, through Peano's own acknowledgment, that Peano
							borrowed his axioms from Dedekind and made extensive use of
							Grassmann's work in his development of the axioms." (Hao Wang. The
							Axiomatization of Arithmetic. J. Symb. Logic; 1957:22(2); p. 145.)
						</p></footnote></p><exhibit role="dtdl"><caption/><pre>
invariant(INT x, o, i)
      where x.nonNull.and(o.isZero) {
   x.lessThan(x.successor);
   x.plus(o).equal(x);
   x.plus(y.successor).equal(x.plus(y).successor);
   x.times(o).equal(o);
   x.times(y.successor).equal(x.times(y)).plus(x);
};</pre></exhibit><div3 id="prop-INT.successor"><head>Successor : <termref ref="dt-INT">INT</termref></head><p><emph role="strong">Definition:</emph>
						The <emph>INT</emph> value that is greater than this <emph>INT</emph> value but
						where no <emph>INT</emph> value exists between this value and its successor.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(INT x, y)
      where x.successor(y) {
   x.lessThan(y).and.not(exists(INT z) {
      x.lessThan(z);
      z.lessThan(y);
      });
};</pre></exhibit></div3><div3 id="prop-INT.diffType"><head>DifferenceDataType : <termref ref="dt-TYPE">TYPE</termref>, inherited from <termref ref="dt-QTY">QTY</termref></head><exhibit role="dtdl"><caption/><pre>
invariant(INT x) {
   x.diffType.implies(INT);
};</pre></exhibit><p>
						The difference between two <emph>INT</emph> values is also a <emph>INT</emph> value.
					</p></div3><div3 id="prop-INT.plus"><head>Addition : <termref ref="dt-INT">INT</termref>, inherited from <termref ref="dt-QTY">QTY</termref></head><argument name="x" type="QTY"/><exhibit role="dtdl"><caption/><pre>
invariant(INT x, y, o)
      where x.nonNull.and(y.nonNull).and(o.isZero) {
   x.plus(o).equal(x);
   x.plus(y.successor).equal(x.plus(y).successor);
};</pre></exhibit></div3><div3 id="prop-INT.times"><head>Multiplication : <termref ref="dt-INT">INT</termref></head><argument name="x" type="INT"/><p><emph role="strong">Definition:</emph>
						The result of multiplying this integer with the operand, equivalent to
						repeated additions of this integer.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(INT x, y, i, o)
      where x.compares(y).and(o.isZero).and(i.isOne) {
   x.times(o).equal(o);
   x.times(i).equal(x);
   x.times(y.successor).equal(x.times(y)).plus(x);
};</pre></exhibit></div3><div3 id="prop-INT.predecessor"><head>Predecessor : <termref ref="dt-INT">INT</termref></head><p><emph role="strong">Definition:</emph>
						The inverse of <termref ref="prop-INT.successor">successor</termref>.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(INT x, y)
      where x.successor(y) {
   x.successor.predecessor.equal(x);
};</pre></exhibit></div3><div3 id="prop-INT.negated"><head>Negation : <termref ref="dt-INT">INT</termref></head><p><emph role="strong">Definition:</emph>
						The inverse element of the <emph>INT</emph> value, another <emph>INT</emph> value,
						which, when added to that value yields zero (the neutral element.)
					</p><exhibit role="dtdl"><caption/><pre>
invariant(INT x)
      where x.nonNull {
   x.plus(x.negated).isZero;
};</pre></exhibit></div3><div3 id="prop-INT.nonNegative"><head>Non-Negative : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph>
						A predicate indicating whether the <emph>INT</emph> zero (neutral element) is
						less or equal to this <emph>INT</emph>.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(INT x, o)
      where x.nonNull.and(o.isZero) {
   x.nonNegative.equal(o.lessOrEqual(x));
};</pre></exhibit></div3><div3 id="prop-INT.isNegative"><head>Negative : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph>
						A predicate indicating whether this <emph>INT</emph> is less than zero (not
						non-negative.)
					</p><exhibit role="dtdl"><caption/><pre>
invariant(INT x)
      where x.nonNull {
   x.isNegative.equal(x.nonNegative.not);
};</pre></exhibit></div3><div3 id="prop-INT.dividedBy"><head>Integer Division : <termref ref="dt-INT">INT</termref></head><argument type="INT" name="x"/><p><emph role="strong">Definition:</emph>
						The integer division operation of this integer (dividend) with another
						integer (divisor) is the integer number of times the divisor fits into
						the dividend.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(INT dividend, divisor, o, i)
      where divisor.isZero.not.and(o.isZero) {
   dividend.isZero.implies(dividend.dividedBy(divisor).equal(o));
   dividend.isZero.not.implies(dividend.dividedBy(divisor).equal(
      absolute(dividend).minus(absolute(divisor)).dividedBy(absolute(divisor))
                        .successor.times(sign(dividend)
                        .times(sign(divisor)))));
};</pre></exhibit></div3><!--
	I thought I'd need sign and absolute for anything having to
	do with remainder SLIST and GLIST, but it turns out that they are
	not used, and we still want to be parsimonious here.
				<prop id="prop-INT.sign" shortname="sign" longname="Sign" type="INT">
					<definition>
						The integer 1 for non negative integers and -1 for negative integers.
					</definition>
					<dtdl xml:space="preserve">
invariant(INT x)
      where x.nonNegative {
   x.sign.isOne;
};
invariant(INT x)
   where x.isNegative {
      x.sign.isOne.negative;
};</dtdl>
				</prop>
				<prop id="prop-INT.absolute" shortname="absolute" longname="Absolute" type="INT">
					<definition>
						The absolute value of the integer, i.e. the
						<propref ref="prop-INT.nonNegative">non-negative</propref> integer that multiplied
						with this integer value's <propref ref="prop-INT.sign"/> yields
						this integer.
					</definition>
					<dtdl xml:space="preserve">
invariant(INT x)
      where x.nonNull {
   x.absolute.times(x.sign).equal(x);
};</dtdl>
				</prop>
  --><div3 id="prop-INT.remainder"><head>Remainder : <termref ref="dt-INT">INT</termref></head><argument type="INT" name="x"/><p><emph role="strong">Definition:</emph>
						The remainder of the integer division.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(INT x, y)
      where x.nonNull.and(y.nonNull) {
   x.reminder(y).equal(x.minus(x.dividedBy(z).times(y)));
};</pre></exhibit><p>
						This definition of the remainder matches the C and Java programming
						languages.
					</p></div3><div3 id="prop-INT.isOne"><head>Neutral Element of Multiplication : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph>
						A predicate indicating if this value is the number one, i.e., the
						neutral element of multiplication. There is exactly one integer
						that has this property.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(INT x, y)
      where x.nonNull.and(y.nonNull) {
   x.isOne.and(y.isOne).implies(x.equal(y));
   x.isOne.and(y.isZero).implies(x.equal(y).not);
};</pre></exhibit></div3><div3 id="prop-INT.literal"><head>Literal Form</head><p>
						The literal form of an integer is a simple decimal number, i.e. a
						string of decimal digits.
					</p><exhibit role="dtdl"><caption/><pre>
INT.literal ST {
   INT digit : "0"         { $.isZero; }
             | "1"         { $.equal(0.successor); }
             | "2"         { $.equal(1.successor); }
             | "3"         { $.equal(2.successor); }
             | "4"         { $.equal(3.successor); }
             | "5"         { $.equal(4.successor); }
             | "6"         { $.equal(5.successor); }
             | "7"         { $.equal(6.successor); }
             | "8"         { $.equal(7.successor); }
             | "9"         { $.equal(8.successor); };

  INT uint   : digit       { $.equal($1); }
             | uint digit  { $.equal($1.times(9.successor).plus($2)); };

  INT        : uint        { $.equal($1); }
             | "+" uint    { $.equal($2); }
             | "-" uint    { $.equal($2.negated); };
};</pre></exhibit></div3></div2><div2 id="dt-REAL"><anchor id="REAL"/><head>Real Number (REAL) specializes <termref ref="dt-QTY">QTY</termref></head><p><emph role="strong">Definition:</emph>
					Fractional numbers. Typically used whenever quantities are measured,
					estimated, or computed from other real numbers.  The typical
					representation is decimal, where the number of significant decimal
					digits is known as the precision.
				</p><p>
					The term "Real number" in this specification is used to mean that
					fractional values are covered without necessarily implying the full
					set of the mathematical real numbers that would include irrational
					numbers such as &#961;<!--?-->, Euler's number, etc.<footnote><p>
							The term "Real" for a fractional number data type originates and is
							well established in the Algol, Pascal tradition of programming
							languages.
						</p></footnote></p><note><p>
						This specification defines the real number data type in the broadest
						sense possible. However, it does not imply that any conforming ITS or
						implementation must be able to represent the full range of Real
						numbers, which would not be possible in any finite
						implementation. HL7's current use cases for the Real number data type
						are measured and estimated quantities and monetary amounts. These use
						cases can be handled with a restricted Real value space, rational
						numbers, and even just very limited decimals (scaled integers.)
						However, we declare the representations of the real value space as
						floating point, rational, scaled integer, or digit string, and their
						various limitations to be out of the scope of this specification.
					</p></note><p>
					This specification offers two choices for a number data type. The
					choice is made as follows: Any number attribute is a real if it is not
					known for sure that it is an integer. A number is an integer if it is
					<emph>always</emph> counted, typically representing an ordinal
					number. If there are conceivable use cases where such a number would
					be estimated or averaged, it is not always an integer and thus should
					use the Real data type.
				</p><exhibit role="dtdl" id="dtdl-REAL"><anchor id="dtdl-REAL"/><caption/><pre>
type RealNumber alias REAL specializes QTY {
             REAL  negated;
             REAL  times(REAL x);
             REAL  inverted;
             BL    isOne;
             REAL  power(REAL x);
  literal    ST;
             INT   precision;
  demotion   INT;
  promotion  REAL  (INT x);
  promotion  PQ;
  promotion  RTO;
};</pre></exhibit><p>
					The algebraic operations are specified here as characterizing
					operations in the sense of ISO 11404, and because these operations are
					needed in other parts of this specification.
				</p><p>
					Unlike the integer numbers, the real numbers semantics are not
					inductively constructed but only intuitively described by their axioms
					of their algebraic properties. The completeness axioms are
					intentionally left out so as to make no statement about irrational
					numbers.
				</p><div3 id="prop-REAL.compares"><head>Comparability : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-QTY">QTY</termref></head><p>
						The value set of <emph>REAL</emph> is totally ordered.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(REAL x, y)
      where x.nonNull.and(y.nonNull) {
   x.compares(y);
};</pre></exhibit></div3><div3 id="prop-REAL.diffType"><head>DifferenceDataType : <termref ref="dt-TYPE">TYPE</termref>, inherited from <termref ref="dt-QTY">QTY</termref></head><exhibit role="dtdl"><caption/><pre>
invariant(REAL x) {
   x.diffType.implies(REAL);
};</pre></exhibit><p>
						The difference between two <emph>REAL</emph> values is also a <emph>REAL</emph> value.
					</p></div3><div3 id="prop-REAL.plus"><head>Addition : <termref ref="dt-QTY">QTY</termref>, inherited from <termref ref="dt-QTY">QTY</termref></head><exhibit role="dtdl"><caption/><pre>
invariant(REAL x, y, z, o)
      where x.nonNull.and(y.nonNull).and(z.nonNull).and(o.isZero) {
   x.plus(o).equal(x);                             /* neutral element */
   x.plus(y).plus(z).equal(x.plus(y.plus(z)));     /* associative */
   x.plus(y).equal(y.plus(x));                     /* commutative */
   z.lessOrEqual(x).and(z.lessOrEqual(y)
                   .implies(z.lessOrEqual(x.plus(y));
   x.lessOrEqual(y).implies(x.plus(z)
                   .lessOrEqual(y.plus(z)));
};</pre></exhibit></div3><div3 id="prop-REAL.negated"><head>Negation (Inverse Element of Addition) : <termref ref="dt-REAL">REAL</termref></head><p><emph role="strong">Definition:</emph>
						A <emph>REAL</emph> value, which, when added to another <emph>REAL</emph> value yields
						zero (the neutral element of addition.)
					</p><exhibit role="dtdl"><caption/><pre>
invariant(REAL x)
      where x.nonNull {
   x.plus(x.negated).isZero;
};</pre></exhibit></div3><div3 id="prop-REAL.isOne"><head>Neutral Element of Multiplication : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph>
						A predicate indicating if this value is the number one, i.e., the
						neutral element of multiplication. There is exactly one real number
						that has this property.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(REAL x, y)
      where x.nonNull.and(y.nonNull) {
   x.isOne.and(y.isOne).implies(x.equal(y));
   x.isOne.and(y.isZero).implies(x.equal(y).not);
};</pre></exhibit></div3><div3 id="prop-REAL.times"><head>Multiplication : <termref ref="dt-REAL">REAL</termref></head><argument name="x" type="REAL"/><p><emph role="strong">Definition:</emph>
						An operation in <emph>REAL</emph> that forms an abelian group and is related
						to addition by the law of distribution.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(REAL x, y, z, i, o)
      where x.nonNull.and(y.nonNull).and(z.nonNull)
             .and(i.isOne).and(o.isZero) {
   x.times(o).equal(o);
   x.times(i).equal(x);                                      /* neutral element */
   x.times(y).times(z).equal(x.times(y.times(z)));           /* associative */
   x.times(y).equal(y.times(x));                             /* commutative */
   x.times(y.plus(z)).equal(x.times(y).plus(x.times(z));     /* distributive */
   o.lessOrEqual(x).and(o.lessOrEqual(y).implies(o.lessOrEqual(x.times(y));
};</pre></exhibit></div3><div3 id="prop-REAL.inverted"><head>Inverse Element of Multiplication : <termref ref="dt-REAL">REAL</termref></head><p><emph role="strong">Definition:</emph>
						A <emph>REAL</emph> value, which, when muliplied with another <emph>REAL</emph> value
						yields one (the neutral element of multiplication). Zero (the neutral
						element of addition) has no inverse element.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(REAL x, i)
      where x.isZero.not.and(i.isOne) {
   x.times(x.inverted).equal(i);
};</pre></exhibit></div3><!-- Homomorphism INT -> REAL --><div3 id="prop-REAL.INT"><head>Homomorphism of INT into REAL : <termref ref="dt-INT">INT</termref></head><p>
						The <termref ref="dt-INT">INT</termref> and <emph>REAL</emph> data types are related by a
						homomorphism that maps every value in <termref ref="dt-INT">INT</termref> to a value
						in <emph>REAL</emph> whereby the algebraic properties of <termref ref="dt-INT">INT</termref>
						are preserved. This means, an integer can be promoted to a real and a
						real can be demoted to an integer by means of rounding off the
						fractional part.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(INT n, m)
      where n.nonNull.and(m.nonNull) {
   ((REAL)n.plus(m)).equal(((REAL)n).plus((REAL)m));
   ((REAL)n.times(m)).equal(((REAL)n).times((REAL)m));
};</pre></exhibit></div3><div3 id="prop-REAL.power"><head>Exponentiation : <termref ref="dt-REAL">REAL</termref></head><argument type="REAL" name="x"/><p><emph role="strong">Definition:</emph>
						The basis of exponentiation is the iterative multiplication of a 
						real number, and extended to rational exponents as the inverse
						operation.
					</p><p>
						We only list certain common properties of exponentiation.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(REAL x, y, z, o, i)
      where x.nonNull.and(y.nonNull).and(z.nonNull)
             .and(o.isZero).and.(i.isOne) {
   forall(INT n)
         where n.nonNull {
      n.greaterThan(o).implies(
         x.power(n).equal(x.times(x.power(n.predecessor))));
      n.lessThan(o).implies(
         x.power(n).equal(x.power(n.negated).inverted);
      }
      x.power(o).equal(i);
      x.power(i).equal(x);
      x.power(y).power(z).equal(x.power(y.times(z)));
      x.power(y).times(x.power(z)).equal(x.power(y.plus(z)));
      x.power(y).inverted.equal(x.power(y.negated));
      x.power(y).power(y.inverted).equal(x);
};</pre></exhibit></div3><div3 id="prop-REAL.literal"><head>Literal Form</head><p>
						The literal form of an real is a string of decimal digits with
						optional leading "+" or "-" sign, and optional decimal point, and
						optional exponential notation using a case insensitive "e" between the
						mantissa and the exponent. The number of significant digits must
						conform to the precision property.
					</p><exhibit role="dtdl"><caption/><pre>
REAL.literal ST {
   REAL            : mantissa                   { $.equal($1); }
                   | mantissa /[eE]/ INT        { $.equal($1.times(10.power($3)); };

   REAL mantissa   : /0*/ 0                     { $.isZero;
                                                  $.precision.equal(1); }
                   | /0*/ "." /0*/              { $.isZero;
                                                  $.precision.equal($3.length.successor); }
                   | /0*/ "." /0*/ fractional   { $.equal($4);
                                                  $.precision.equal($4.precision); }
                   | integer                    { $.equal($1); }
                   | integer "." fractional     { $.equal($1.plus($2));
                                                  $.precision.equal(
                                                  $1.precision.plus($3.precision)); };

   REAL integer    : uintval                    { $.equal($2); }
                   | "+" uintval                { $.equal($1.times($2)); }
                   | "-" uintval                { $.equal($1.times($2).negated); };

   REAL uintval    : /0*/ uint                  { $.equal($2); };

   REAL uint       : digit                      { $.equal($1);
                                                  $.precision.equal(1); }
                   | uint digit                 { $.equal($1.times(10).plus($2));
                                                  $.precision.equal(
                                                     $1.precision.successor); };

   REAL fractional : digit                      { $.equal($1.times(10.inverted));
                                                  $.precision.equal(1); }
                   | digit fractional           { $.equal(
                                                  $1.plus($2.times(10.inverted));
                                                  $.precision.equal(
                                                     $1.precision.successor); };

   INT digit       : /[0-9]/                    { $.equal($1); }
};</pre></exhibit><p>
						Examples of real literals for two thousand are 2000, 2000., 2e3,
						2.0e+3, +2.0e+3.
					</p><p>
						Note that the literal form does not carry type information. For
						example, "2000" is a valid representation of both a real number and an
						integer number. No trailing decimal point is used to disambiguate from
						integer numbers. An ITS that uses this literal form must recover the
						type information from other sources.
					</p></div3><div3 id="prop-REAL.precision"><head>Precision of the Decimal Form : <termref ref="dt-INT">INT</termref></head><p><emph role="strong">Definition:</emph>
						The number of significant digits of the decimal representation.
					</p><p>
						Precision is formally defined based on the <termref ref="prop-REAL.literal">literal</termref></p><p>
						The precision attribute is only the precision of a decimal digit
						representation, <emph>not the accuracy of the real number
						value</emph>.
					</p><p>
						The purpose of the precision property for the real number data type is
						to faithfully capture the whole information presented to humans in a
						number. The amount of decimal digits shown conveys information about
						the uncertainty (i.e., precision and accuracy) of a measured value.
					</p><note><p> 
							The precision of the representation is independent from uncertainty
							(precision accuracy) of a measurement result. If the uncertainty of a
							measurement result is important, one should specify uncertain values 
							as <termref ref="dt-PPD">PPD</termref>.
						</p></note><p>
						The rules for what digits are significant are as follows:
					</p><list role="ordered"><item>
							All non-zero digits are significant.
						</item><item>
							All zeroes to the right of a significant digit are significant.
						</item><item>
							When all digits in the number are zero the zero-digit immediately left
							to the decimal point is significant (and because of rule 2, all
							following zeroes are thus significant too.)
						</item></list><note><p>
							These rules of significance differ slightly from the more casual rules
							taught in school. Notably trailing zeroes before the decimal point are
							consistently regarded significant here. Elsewhere, e.g., 2000 is
							ambiguous as to whether the zeroes are significant. This deviation
							from the common custom is warranted for the purpose of unambiguous
							communication.
						</p></note><table id="table-REAL.precision.examples"><caption>Examples for the Precision of Real Number Literals.</caption><thead><tr><th rowspan="1" colspan="1">Literal</th><th rowspan="1" colspan="1">Number of Significant Digits</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">2000</td><td rowspan="1" colspan="1">has 4 significant digits.</td></tr><tr><td rowspan="1" colspan="1">2e3</td><td rowspan="1" colspan="1">
									has 1 significant digit, used if one would naturally say 
									"2000" but precision is only 1.
								</td></tr><tr><td rowspan="1" colspan="1">0.001</td><td rowspan="1" colspan="1">has 1 significant digit.</td></tr><tr><td rowspan="1" colspan="1">1e-3</td><td rowspan="1" colspan="1">
									has 1 significant digit, use this if one would naturally
									say "0.001" but precision is only 1.
								</td></tr><tr><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">has 1 significant digit.</td></tr><tr><td rowspan="1" colspan="1">0.0</td><td rowspan="1" colspan="1">has 2 significant digits.</td></tr><tr><td rowspan="1" colspan="1">000.0</td><td rowspan="1" colspan="1">has 2 significant digits.</td></tr><tr><td rowspan="1" colspan="1">0.00</td><td rowspan="1" colspan="1">has 3 significant digits.</td></tr><tr><td rowspan="1" colspan="1">4.10</td><td rowspan="1" colspan="1">has 3 significant digits.</td></tr><tr><td rowspan="1" colspan="1">4.09</td><td rowspan="1" colspan="1"> has 3 significant digits.</td></tr><tr><td rowspan="1" colspan="1">4.1</td><td rowspan="1" colspan="1">has 2 significant digits.</td></tr></tbody></table><p>
						The precision of the representation <emph>should</emph> match the
						uncertainty of the value. However, precision of the representation and
						uncertainty of the value are separate independent concepts. Refer to
						<termref ref="dt-PPD_REAL">PPD&lt;REAL&gt;</termref> for details about uncertain real numbers.
					</p><p>
						For example "0.123" has 3 significant digits <emph>in the
						representation</emph>, but the <emph>uncertainty of the value</emph>
						may be in any digit shown or not shown, i.e., the uncertainty may be
						0.1230.0005, 0.1230.005 or
						0.1230.00005, etc. Note that ITS representations
						<emph>should</emph> adjust their representational precision with the
						uncertainty of the value. However, since the precision in the digit
						string is granular to 0.5 the least significant digit, while
						uncertainty may be anywhere between these "grid lines",
						0.1230.005 would also be an adequate representation for the
						value between 0.118 and 0.128.
					</p><note role="its"><p>
							On a character based Implementation Technology the ITS need not
							represent the precision as an explicit attribute if numbers are
							represented as decimal digit strings. In that case, the ITS must abide
							by the rules of an unambiguous determination of significant digits. A
							number representation must not produce more or less significant digits
							than were originally in that number. Conformance can be tested through
							round-trip encoding &#8212; decoding &#8212; encoding.
						</p></note></div3><!-- FIXME: I shall delete this stuff here, because:

- this special definition of equality of REAL introduces a complexity into
  all places that use REAL, even in the definitions of REAL itself. I 
  would not vouche for the group axioms for example to not contain
  paradoxes given this definition of equality.

  So, I am proposing this: keep equality of numbers (and calendar expressions)
  free of all "convenience" rounding. Instead of equality test one should 
  usually perform boundary comparisons (e.g., interval.contains(value)).

  We could define a parameterized equality test where a parameter epsilon
  would specify:

BL QTY.equal(QTY that, QTY epsilon);

template<QTY T>
invariant(T this, T that, T.diffType epsilon, IVL<T> interval) 
   where epsilon.nonNegative
    .and(interval.low.equal(this.minus(epsilon))
    .and(interval.high.equal(this.plus(epsilon))
{
  this.equal(that, epsilon).equal(interval.contains(that));
}

or something like it. But in fact this is just a convenience that isn't
needed in the data type specification (we didn't initially think that 
the operations defined here were to be used at all, that has changed
with the Java SIG tho, and certainly applies to the XPath 2.0 discussion
we're having.)

<delete>
    <prop id="prop-REAL.equal" base="prop-ANY.equal">
            <p>
Equality of real numbers is determined based on the value and
precision. The value with a higher precision is rounded to the
precision of the other value and then the comparison made.
      </p>
            <table id="table-REAL.equal.example">
              <caption>Examples for equality and inequalities of REAL
        values.</caption>
              <col width="0.74" span="1"/>
              <col width="0.70" span="1"/>
              <col width="0.54" span="1"/>
              <col width="0.67" span="1"/>
              <col width="0.68" span="1"/>
              <thead>
                <tr>
                  <th>value</th>
                  <th>precision</th>
                  <th>equal</th>
                  <th>value</th>
                  <th>precision</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>3.14</td>
                  <td>3</td>
                  <td>true</td>
                  <td>3.14</td>
                  <td>3</td>
                </tr>
                <tr>
                  <td>3.140000</td>
                  <td>7</td>
                  <td>true</td>
                  <td>3.14</td>
                  <td>3</td>
                </tr>
                <tr>
                  <td>3.1415</td>
                  <td>5</td>
                  <td>true</td>
                  <td>3.14</td>
                  <td>3</td>
                </tr>
                <tr>
                  <td>3.1415</td>
                  <td>5</td>
                  <td>false</td>
                  <td>3.1400</td>
                  <td>5</td>
                </tr>
                <tr>
                  <td>4</td>
                  <td>1</td>
                  <td>false</td>
                  <td>3</td>
                  <td>1</td>
                </tr>
              </tbody>
            </table>
            <note>
              <p>
a raw equality test on real numbers is unreasonable for most practical
purposes, since infinitesimal equality is rarely meaningful in
practice but may lead to false negatives. This definition of equality
is designed to be reasonably useful for simple cases. For more
sophisticated cases it is recommended to compare decimal numbers based
on intervals, that is, to test whether a real value falls within a
certain range (interval).
        </p>
            </note>
          </prop>

</delete --></div2><div2 id="dt-RTO"><anchor id="RTO"/><head>Ratio (RTO) specializes <termref ref="dt-QTY">QTY</termref></head><parameter name="N" type="QTY"/><parameter name="D" type="QTY"/><p><emph role="strong">Definition:</emph>
					A quantity constructed as the quotient of a numerator quantity divided
					by a denominator quantity. Common factors in the numerator and
					denominator are not automatically cancelled out.  The <emph>RTO</emph> data
					type supports titers (e.g., "1:128") and other quantities produced by
					laboratories that truly represent ratios. Ratios are not simply
					"structured numerics", particularly blood pressure measurements
					(e.g. "120/60") are not ratios. In many cases the <termref ref="dt-REAL">REAL</termref>
					should be used instead of the <emph>RTO</emph>.
				</p><p>
					Ratios are different from rational numbers, i.e., in ratios common
					factors in the numerator and denominator never cancel out.  A ratio of
					two real or integer numbers is not automatically reduced to a real
					number.
				</p><table id="dt-RTO-prop-summary"><caption>Property Summary of
      Ratio</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-RTO.numerator">numerator</termref></td><td><termref ref="dt-N">N</termref></td><td>
						The quantity that is being divided in the ratio.  The default is the
						integer number 1 (one.)
					</td></tr><tr><td><termref ref="prop-RTO.denominator">denominator</termref></td><td><termref ref="dt-D">D</termref></td><td>
						The quantity that devides the numerator in the ratio.  The default is
						the integer number 1 (one.)  The denominator must not be zero.
					</td></tr></tbody></table><note><p> 
						This data type is not defined to generally represent rational
						numbers. It is used only if common factors in numerator and
						denominator are not supposed to cancel out. This is only rarely the
						case. For observation values, ratios occur almost exclusively with
						titers.
					</p></note><exhibit role="dtdl" id="dtdl-RTO"><anchor id="dtdl-RTO"/><caption/><pre>
type Ratio&lt;QTY N, QTY D&gt; alias RTO specializes QTY {
   N         numerator;
   D         denominator;
   demotion  REAL;
   demotion  PQ;
};</pre></exhibit><p>
					The default value for both numerator and denominator is the integer
					number 1 (one.) The denominator may not be zero.
				</p><note><p> 
						This data type is defined as a generic data type (see
						<specref ref="generics"/>) but discussed in the context of the other
						quantity-related data types. The reason for defining <emph>RTO</emph> as a
						generic data type is so that it can be constrained precisely as to
						what the numerator and denominator types should be.
					</p></note><div3 id="prop-RTO.numerator"><head>Numerator : <termref ref="dt-N">N</termref></head><p><emph role="strong">Definition:</emph>
						The quantity that is being divided in the ratio.  The default is the
						integer number 1 (one.)
					</p></div3><div3 id="prop-RTO.denominator"><head>Denominator : <termref ref="dt-D">D</termref></head><p><emph role="strong">Definition:</emph>
						The quantity that devides the numerator in the ratio.  The default is
						the integer number 1 (one.)  The denominator must not be zero.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(RTO x)
      where x.nonNull {
   x.denominator.isZero.not;
};</pre></exhibit></div3><div3 id="prop-RTO.literal"><head>Literal Form</head><p>
						A ratio literal form exists for all ratios where both numerator and
						denominators have literal forms. A ratio is simply the numerator
						literal a colon as separator followed by the denominator literal. When
						the colon and denominator are missing, the integer number 1 is assumed
						as the denominator.
					</p><exhibit role="dtdl"><caption/><pre>
RTO.literal ST {
   RTO : QTY          { $.numerator.equal($1);
                        $.denominator.equal((INT)1); };
       | QTY ":" QTY  { $.numerator.equal($1);
                        $.denominator.equal($3); };
};</pre></exhibit><p>
						For example, the rubella virus antibody titer value 1:64 could be
						represented using the literal "1:64".
					</p></div3></div2><div2 id="dt-PQ"><anchor id="PQ"/><head>Physical Quantity (PQ) specializes <termref ref="dt-QTY">QTY</termref></head><p><emph role="strong">Definition:</emph>
					A dimensioned quantity expressing the result of measuring.
				</p><table id="dt-PQ-prop-summary"><caption>Property Summary of
      Physical Quantity</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-PQ.value">value</termref></td><td><termref ref="dt-REAL">REAL</termref></td><td>
						The magnitude of the quantity measured in terms of the unit.
					</td></tr><tr><td><termref ref="prop-PQ.unit">unit</termref></td><td><termref ref="dt-CS">CS</termref></td><td>
						The unit of measure specified in the Unified Code for Units of Measure
						(UCUM) [<loc href="http://aurora.rg.iupui.edu/UCUM" xlink-form="simple" show="embed" actuate="auto"/>].
					</td></tr><tr><td><termref ref="prop-PQ.translation">translation</termref></td><td><termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-PQR">PQR</termref>&gt;</td><td>
						An alternative representation of the same physical quantity expressed
						in a different unit, of a different unit code system and possibly with
						a different value.
					</td></tr><tr><td><termref ref="prop-PQ.canonical">canonical</termref></td><td><termref ref="dt-PQ">PQ</termref></td><td>
						A physical quantity expressed in a canonical unit. In any given unit
						system has every physical dimension can be assigned one canonical unit
						Defining the canonical unit is not subject of this specification, only
						asserting that such a canonical unit exists (and can be arbitrarily
						chosen) for every physical quantity. An abstract physical quantity is
						equal to its canonical form.
					</td></tr><tr><td><termref ref="prop-PQ.diffType">diffType</termref></td><td><termref ref="dt-TYPE">TYPE</termref></td><td>
						The type of the difference between 2 values of a specific QTY data type.
					</td></tr><tr><td><termref ref="prop-REAL.PQ">toPQ</termref></td><td><termref ref="dt-REAL">REAL</termref></td><td/></tr></tbody></table><exhibit role="dtdl" id="dtdl-PQ"><anchor id="dtdl-PQ"/><caption/><pre>
type PhysicalQuantity alias PQ specializes QTY {
            REAL      value;
            CS        unit;
            BL        equal(ANY x)
            BL        lessOrEqual(PQ x);
            BL        compares(PQ x);
            PQ        canonical;
            SET&lt;PQR&gt;  translation;

            PQ        negated;
            PQ        times(REAL x);
            PQ        times(PQ x);
            PQ        inverted;
            PQ        power(INT x);
            BL        isOne;

  literal   ST;
  demotion  REAL;

            REAL      originalValue;
            CV        originalUnit;
};</pre></exhibit><div3 id="prop-PQ.value"><head>Maginitude Value : <termref ref="dt-REAL">REAL</termref></head><p><emph role="strong">Definition:</emph>
						The magnitude of the quantity measured in terms of the unit.
					</p></div3><div3 id="prop-PQ.unit"><head>Unit of Measure : <termref ref="dt-CS">CS</termref></head><p><emph role="strong">Definition:</emph>
						The unit of measure specified in the Unified Code for Units of Measure
						(UCUM) [<loc href="http://aurora.rg.iupui.edu/UCUM" xlink-form="simple" show="embed" actuate="auto"/>].
					</p><!--
					<hide>
						<p>--><!-- FIXME: this is deferred. I need to move UCUM
     maintenance to XML and then we can generate all this --><!-- More detail on the Unified Code for Units of Measure, and example
     tables of units commonly seen in practice with HL7 will be provided in
     an informative Appendix to this specification.
						</p>
					</hide>--><note><p>
							Equality of physical quantities does not require the values and units
							to be equal independently. Value and unit is only how we represent
							physical quantities. For example, 1 m equals 100 cm. Although the
							units are different and the values are different, the physical
							quantities are equal!  Therefore one should never expect a particular
							unit for a physical quantity but instead provide automated conversion
							between different comparable units.
						</p></note></div3><div3 id="prop-PQ.translation"><head>Translation : <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-PQR">PQR</termref>&gt;</head><p><emph role="strong">Definition:</emph>
						An alternative representation of the same physical quantity expressed
						in a different unit, of a different unit code system and possibly with
						a different value.
					</p></div3><p>
					Physical quantities semantically are the results of measurement
					acts. Although physical quantities are represented as pairs of value
					and unit, semantically, a physical quantity is more than that. To find
					out whether two physical quantities are equal, it is not enough to
					compare equality of their two values and units independently. For
					example, 100 cm equals 1 m although neither values nor units are
					equal. To define equality we introduce the notion of a canonical form.
				</p><div3 id="prop-PQ.canonical"><head>Canonical Form : <termref ref="dt-PQ">PQ</termref></head><p><emph role="strong">Definition:</emph>
						A physical quantity expressed in a canonical unit. In any given unit
						system has every physical dimension can be assigned one canonical unit
						Defining the canonical unit is not subject of this specification, only
						asserting that such a canonical unit exists (and can be arbitrarily
						chosen) for every physical quantity. An abstract physical quantity is
						equal to its canonical form.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(PQ x, y)
      where x.nonNull.and(y.nonNull) {
   x.canonical.equal(x);
};</pre></exhibit><p>
						For example, for a unit system based on the Systme
						International (SI) one can define the canonical form as (a) the
						product of only the base units; (b) without prefixes; where (c) only
						multiplication and exponents are used (no division operation); and (d)
						where the seven base units appear in a defined ordering (e.g., m, s,
						g...) Thus, 1 mm Hg would be expressed as 133322 m<emph role="sup">-1</emph>
						s<emph role="sup">-2</emph>. As can be seen, the rules how to build the canonical
						form of units may be quite complex. However, for the semantic
						specification it doesn't matter how the canonical form is built, nor
						what specific canonical form is chosen, only that <emph>some</emph>
						canonical form <emph>could</emph> be defined.
					</p></div3><div3 id="prop-PQ.equal"><head>Equality : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref></head><p>
						Two physical quantities are equal if each their values and their units
						of their canonical forms are equal.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(PQ x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.canonical.value
             .equal(y.canonical.value).and(
                x.canonical.unit.equal(y.canonical.unit)));
};</pre></exhibit></div3><div3 id="prop-PQ.compares"><head>Comparability : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-QTY">QTY</termref></head><p>
						Two physical quantities compare each other (and have an ordering and
						difference) if the units of their canonical forms are equal.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(PQ x, y)
      where x.nonNull.and(y.nonNull) {
   x.compares(y).equal(x.canonical.unit.equal(y.canonical.unit));
};</pre></exhibit></div3><div3 id="prop-PQ.diffType"><head>DifferenceDataType : <termref ref="dt-TYPE">TYPE</termref>, inherited from <termref ref="dt-QTY">QTY</termref></head><exhibit role="dtdl"><caption/><pre>
invariant(PQ x) {
   x.diffType.implies(PQ);
};</pre></exhibit><p>
						The difference between 2 Physical Quantities is another Physical Quantity with
						the same units
					</p><exhibit role="dtdl"><caption/><pre>
invariant(PQ x, y)
      where x.compares(y) {
   x.minus(y).canonical.unit.implies(x.canonical.unit);
};</pre></exhibit></div3><div3 id="prop-PQ.isOne"><head>Neutral Element of Multiplication : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph>
						A predicate indicating if this value is the number one, i.e., the
						neutral element of multiplication. There is exactly one physical
						quantity that has this property and is called <emph>the unity</emph>.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(PQ x, y)
      where x.nonNull.and(y.nonNull) {
   x.isOne.and(y.isOne).implies(x.equal(y));
   x.isOne.and(y.isZero).implies(x.equal(y).not);
};</pre></exhibit></div3><!--
	 this text is not necessary
				<p>
					Algebraic operations are defined for physical quantities because they
					are characterizing operations in the sense of ISO 11404 and because
					this specification makes use of them when defining the literal form.
				</p>
  --><div3 id="prop-PQ.times"><head>Multiplication : <termref ref="dt-PQ">PQ</termref></head><argument name="x" type="PQ"/><p><emph role="strong">Definition:</emph>
						The product of two physical quantities is the product of their values
						times the product of their units.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(PQ x, y, z, i, o)
      where x.nonNull.and(y.nonNull).and(z.nonNull)
             .and(o.isZero).and(i.isOne) {
   x.times(o).equal(o);
   x.times(i).equal(x);             /* neutral element */
   x.times(y).times(z).equal(
            x.times(y.times(z)));   /* associative */
   x.times(y).equal(y.times(x));    /* commutative */
   o.lessOrEqual(x).and(o.lessOrEqual(y).implies(o.lessOrEqual(x.times(y));
};</pre></exhibit></div3><div3 id="prop-PQ.inverted"><head>Inverse Element of Multiplication : <termref ref="dt-PQ">PQ</termref></head><p><emph role="strong">Definition:</emph>
						A <emph>PQ</emph> value, which, when muliplied with another <emph>PQ</emph> value
						yields one (the neutral element of multiplication). Zero (the neutral
						element of addition) has no inverse element.  The quotient of two
						comparable quantities is comparable to the unity (the unit 1).
					</p><exhibit role="dtdl"><caption/><pre>
invariant(PQ this, that, one)
      where this.nonNull.and(that.nonNull).and(one.isOne) {
   this.times(this.inverted).equal(one);
   this.compares(that).implies(this.times(that.inverted).equal(one));
};</pre></exhibit></div3><div3 id="prop-PQ.timesREAL"><head>Real Multiplication : <termref ref="dt-PQ">PQ</termref></head><argument name="x" type="REAL"/><p><emph role="strong">Definition:</emph>
						Multiplication with a real number forms a scaled quantity. A scaled
						quantity is comparable to its original quantity.
					</p><p>
						If two quantities <emph>Q</emph><emph role="sub">1</emph> and
						<emph>Q</emph><emph role="sub">2</emph> compare each other, there
						exists a real number <emph>r</emph> such that <emph>r</emph><emph role="strong">1</emph> = <emph>Q</emph><emph role="sub">1</emph> / <emph>Q</emph><emph role="sub">2</emph>.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(PQ x; REAL r)
      where x.nonNull.and(r.nonNull) {
   x.times(r).value.equal(x.value.times(r));
   x.times(r).compares(x);
};</pre></exhibit></div3><!-- Homomorphism REAL -> PQ --><div3 id="prop-REAL.PQ"><head>Homomorphism of REAL into PQ : <termref ref="dt-REAL">REAL</termref></head><p>
						A <termref ref="dt-REAL">REAL</termref> value can be converted to a <emph>PQ</emph> value
						with the unity, i.e. the unit <emph role="strong">1</emph> (one).
						Likewise, a physical quantity that compares the unity can be converted
						to a real number.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(PQ x, unity) 
      where x.nonNull.and.unity.isOne.and(x.compares(unity)) {
   unity.times((REAL)x).equal(x);
};</pre></exhibit></div3><div3 id="prop-PQ.power"><head>Exponentiation : <termref ref="dt-PQ">PQ</termref></head><argument type="INT" name="x"/><p><emph role="strong">Definition:</emph>
						A physical quantity can be raised to an integer power.
					</p><exhibit role="dtdl"><caption/><pre>
invariant (PQ x, i; INT n, o) 
      where x.nonNull.and(i.isOne).and(n.nonNull.and(o.isZero) {
   x.power(o).equal(i);
   n.greaterThan(o).implies(
      x.power(n).equal(x.times(x.power(n.predecessor))));
   n.lessThan(o).implies(
      x.power(n).equal(x.power(n.negated).inverted);
};</pre></exhibit></div3><div3 id="prop-PQ.plus"><head>Addition : <termref ref="dt-PQ">PQ</termref></head><argument name="x" type="QTY"/><p><emph role="strong">Definition:</emph>
						Two physical quantities that compare each other can be added.
					</p><exhibit role="dtdl"><caption/><pre>
invariant (PQ x, y)
      where x.compares(y) {
   x.canonical.plus(y.canonical).value.equal(
      x.canonical.value.plus(y.canonical.value));
};</pre></exhibit></div3><div3 id="prop-PQ.literal"><head>Literal Form</head><p>
						The literal form for a physical quantity is a real number literal
						followed by optional whitespace and a character string representing a
						valid code in the Unified Code for Units of Measure (UCUM)
						[<loc href="http://aurora.rg.iupui.edu/UCUM" xlink-form="simple" show="embed" actuate="auto"/>].
					</p><exhibit role="dtdl"><caption/><pre>
PQ.literal ST {
   PQ       : REAL unit    { $.value.equal($1);
                             $.unit.equal($2); }
   CS  unit : ST           { $.value.equal($1);
                             $.codeSystem.equal(2.16.840.1.113883.6.8); };
};</pre></exhibit><p>
						For example, 20 minutes is "20 min".
					</p></div3></div2><div2 id="dt-PQR"><anchor id="PQR"/><head>Physical Quantity Representation (PQR) specializes <termref ref="dt-CV">CV</termref></head><p><emph role="strong">Definition:</emph>
					An extension of the coded value data type representating a physical
					quantity using a unit from any code system. Used to show alternative
					representation for a physical quantity.
				</p><table id="dt-PQR-prop-summary"><caption>Property Summary of
      Physical Quantity Representation</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-PQR.value">value</termref></td><td><termref ref="dt-REAL">REAL</termref></td><td>
						The magnitude of the measurement value in terms of the unit
						specified by this code.
					</td></tr><tr><td><termref ref="prop-PQR.code">code</termref></td><td><termref ref="dt-ST">ST</termref></td><td>
						The plain code symbol defined by the code system. For example,
						"784.0" is the code symbol of the ICD-9 code "784.0" for headache.
					</td></tr><tr><td><termref ref="prop-PQR.codeSystem">codeSystem</termref></td><td><termref ref="dt-UID">UID</termref></td><td>
						Specifies the code system that defines the code.
					</td></tr><tr><td><termref ref="prop-PQR.codeSystemName">codeSystemName</termref></td><td><termref ref="dt-ST">ST</termref></td><td>
						The common name of the coding system.
					</td></tr><tr><td><termref ref="prop-PQR.codeSystemVersion">codeSystemVersion</termref></td><td><termref ref="dt-ST">ST</termref></td><td>
						If applicable, a version descriptor defined specifically for the given
						code system.
					</td></tr><tr><td><termref ref="prop-PQR.displayName">displayName</termref></td><td><termref ref="dt-ST">ST</termref></td><td>
						A name or title for the code, under which the sending system shows the
						code value to its users.
					</td></tr><tr><td><termref ref="prop-PQR.originalText">originalText</termref></td><td><termref ref="dt-ED">ED</termref></td><td>
						The text or phrase used as the basis for the coding.
					</td></tr></tbody></table><exhibit role="dtdl"><caption/><pre>
type PhysicalQuantityRepresentation alias PQR specializes CV {
   REAL  value;
};</pre></exhibit><div3 id="prop-PQR.value"><head>Value : <termref ref="dt-REAL">REAL</termref></head><p><emph role="strong">Definition:</emph>
						The magnitude of the measurement value in terms of the unit
						specified by this code.
					</p></div3><div3 id="prop-PQR.code"><head>Code : <termref ref="dt-ST">ST</termref>, inherited from <termref ref="dt-CV">CV</termref></head><p><emph role="strong">Definition:</emph>
						The plain code symbol defined by the code system. For example,
						"784.0" is the code symbol of the ICD-9 code "784.0" for headache.
					</p><p>
						A non-exceptional <emph/> value has a non-NULL <emph>code</emph> property
						whose value is a character string that is a symbol defined by the
						coding system identified by <termref ref="prop-CD.codeSystem">codeSystem</termref>. Conversely, a
						<emph/> value without a value for the code property, or with
						a value that is not from the cited coding system is an exceptional
						value (NULL of flavor <emph>other</emph>).
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x)
      where x.nonNull {
   x.code.nonNull;
};</pre></exhibit><p><emph role="strong">Definition:</emph>
						The plain code symbol defined by the code system. For example,
						"784.0" is the code symbol of the ICD-9 code "784.0" for headache.
					</p><p>
						A non-exceptional <emph/> value has a non-NULL <emph>code</emph> property
						whose value is a character string that is a symbol defined by the
						coding system identified by <termref ref="prop-CD.codeSystem">codeSystem</termref>. Conversely, a
						<emph/> value without a value for the code property, or with
						a value that is not from the cited coding system is an exceptional
						value (NULL of flavor <emph>other</emph>).
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x)
      where x.nonNull {
   x.code.nonNull;
};</pre></exhibit></div3><div3 id="prop-PQR.codeSystem"><head>Code System : <termref ref="dt-UID">UID</termref>, inherited from <termref ref="dt-CV">CV</termref></head><p><emph role="strong">Definition:</emph>
						Specifies the code system that defines the code.
					</p><p>
						Code systems shall be referred to by a <termref ref="dt-UID">UID</termref>, which allows unambiguous 
						reference to standard HL7 codes, other standard code systems, as well as local
						codes. HL7 shall assign a <termref ref="dt-UID">UID</termref> to each of its code
						tables as well as to external standard coding systems that are being
						used with HL7. Local sites must use their ISO Object Identifier
						(<termref ref="dt-OID">OID</termref>) to construct a globally unique local coding
						system identifier.
					</p><!-- FIXME: is this still correct? --><p>
						Under HL7's branch, 2.16.840.1.113883, the sub-branches 5 and 6
						contain HL7 standard and external code system identifiers
						respectively. The HL7 Vocabulary Technical Committee maintains these
						two branches.
					</p><p>
						A non-exceptional <emph/> value (i.e. a <emph/>
						value that has a non-null code property) has a non-NULL <emph>codeSystem</emph>
						specifying the system of concepts that defines the code. In other
						words whenever there is a code there is also a code system.
					</p><note role="its"><p>
							Although every non-NULL <emph/> value has a defined code
							system, in some circumstances, the ITS representation for the
							<emph/> value needs not explicitly mention the code
							system. For example, when the context mandates one and only one code
							system to be used specifying the code system explicitly would be
							redundant. However, in that case the <emph>codeSystem</emph> takes on that
							context-specific default value and is not NULL.
						</p></note><exhibit role="dtdl"><caption/><pre>
invariant(CD x)
      where x.code.nonNull {
   x.codeSystem.nonNull;
};</pre></exhibit><p>
						An exceptional <emph/> of NULL-flavor <emph>other</emph> indicates that
						a concept could not be coded in the coding system specified. Thus, for
						these coding exceptions, the code system that did not contain the
						appropriate concept must be provided in <emph>codeSystem</emph>.
					</p><p>
						Some code domains are qualified such that they include the portion of
						any pertinent local coding system that does not simply paraphrase the
						standard coding system (<emph>coded with extensibility</emph>, CWE.)
						If a CWE qualified field actually contains such a local code, the
						coding system must specify the local coding system from which the
						local code was taken. However, for CWE domains the local code is a
						valid member of the domain, so that local codes in CWE domains
						constitute neither an error nor an exceptional (NULL/other) value in
						the sense of this specification.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x)
      where x.other {
   x.code.other;
   x.codeSystem.nonNull;
};</pre></exhibit><p><emph role="strong">Definition:</emph>
						Specifies the code system that defines the code.
					</p><p>
						Code systems shall be referred to by a <termref ref="dt-UID">UID</termref>, which allows unambiguous 
						reference to standard HL7 codes, other standard code systems, as well as local
						codes. HL7 shall assign a <termref ref="dt-UID">UID</termref> to each of its code
						tables as well as to external standard coding systems that are being
						used with HL7. Local sites must use their ISO Object Identifier
						(<termref ref="dt-OID">OID</termref>) to construct a globally unique local coding
						system identifier.
					</p><p>
						Under HL7's branch, 2.16.840.1.113883, the sub-branches 5 and 6
						contain HL7 standard and external code system identifiers
						respectively. The HL7 Vocabulary Technical Committee maintains these
						two branches.
					</p><p>
						A non-exceptional <emph/> value (i.e. a <emph/>
						value that has a non-null code property) has a non-NULL <emph>codeSystem</emph>
						specifying the system of concepts that defines the code. In other
						words whenever there is a code there is also a code system.
					</p><note role="its"><p>
							Although every non-NULL <emph/> value has a defined code
							system, in some circumstances, the ITS representation for the
							<emph/> value needs not explicitly mention the code
							system. For example, when the context mandates one and only one code
							system to be used specifying the code system explicitly would be
							redundant. However, in that case the <emph>codeSystem</emph> takes on that
							context-specific default value and is not NULL.
						</p></note><exhibit role="dtdl"><caption/><pre>
invariant(CD x)
      where x.code.nonNull {
   x.codeSystem.nonNull;
};</pre></exhibit><p>
						An exceptional <emph/> of NULL-flavor <emph>other</emph> indicates that
						a concept could not be coded in the coding system specified. Thus, for
						these coding exceptions, the code system that did not contain the
						appropriate concept must be provided in <emph>codeSystem</emph>.
					</p><p>
						Some code domains are qualified such that they include the portion of
						any pertinent local coding system that does not simply paraphrase the
						standard coding system (<emph>coded with extensibility</emph>, CWE.)
						If a CWE qualified field actually contains such a local code, the
						coding system must specify the local coding system from which the
						local code was taken. However, for CWE domains the local code is a
						valid member of the domain, so that local codes in CWE domains
						constitute neither an error nor an exceptional (NULL/other) value in
						the sense of this specification.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x)
      where x.other {
   x.code.other;
   x.codeSystem.nonNull;
};</pre></exhibit></div3><div3 id="prop-PQR.codeSystemName"><head>Code System Name : <termref ref="dt-ST">ST</termref>, inherited from <termref ref="dt-CV">CV</termref></head><p><emph role="strong">Definition:</emph>
						The common name of the coding system.
					</p><p>
						The code system name has no computational value. The purpose of a code
						system name is to assist an unaided human interpreter of a code value to
						interpret <termref ref="prop-CD.codeSystem">codeSystem</termref>.
						It is suggested &#8212; though
						not absolutely required &#8212; that ITS provide for <emph>codeSystemName</emph> in
						order to annotate the <termref ref="dt-UID">UID</termref> for human comprehension.
					</p><p>
						HL7 systems must not functionally rely on <emph>codeSystemName</emph>. <emph>codeSystemName</emph> can
						never modify the meaning of <termref ref="prop-CD.codeSystem">codeSystem</termref> and
						cannot exist without <termref ref="prop-CD.codeSystem">codeSystem</termref>.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x) {
   x.codeSystemName.nonNull.implies(x.codeSystem.nonNull);
};</pre></exhibit><p><emph role="strong">Definition:</emph>
						The common name of the coding system.
					</p><p>
						The code system name has no computational value. The purpose of a code
						system name is to assist an unaided human interpreter of a code value to
						interpret <termref ref="prop-CD.codeSystem">codeSystem</termref>.
						It is suggested &#8212; though
						not absolutely required &#8212; that ITS provide for <emph>codeSystemName</emph> in
						order to annotate the <termref ref="dt-UID">UID</termref> for human comprehension.
					</p><p>
						HL7 systems must not functionally rely on <emph>codeSystemName</emph>. <emph>codeSystemName</emph> can
						never modify the meaning of <termref ref="prop-CD.codeSystem">codeSystem</termref> and
						cannot exist without <termref ref="prop-CD.codeSystem">codeSystem</termref>.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x) {
   x.codeSystemName.nonNull.implies(x.codeSystem.nonNull);
};</pre></exhibit></div3><div3 id="prop-PQR.codeSystemVersion"><head>Code System Version : <termref ref="dt-ST">ST</termref>, inherited from <termref ref="dt-CV">CV</termref></head><p><emph role="strong">Definition:</emph>
						If applicable, a version descriptor defined specifically for the given
						code system.
					</p><p>
						HL7 shall specify how these version strings are formed for each
						external code system. If HL7 has not specified how version strings are
						formed for a particular coding system, version designations have no
						defined meaning for such coding system.
					</p><p>
						Different versions of one code system must be compatible. Whenever a
						code system changes in an incompatible way, it will constitute a new
						code system, not simply a different version, regardless of how the
						vocabulary publisher calls it.
					</p><p>
						For example, the publisher of ICD-9 and ICD-10 calls these code
						systems, "revision 9" and "revision 10" respectively. However, ICD-10
						is a complete redesign of the ICD code, not a backward compatible
						version. Therefore, for the purpose of this data type specification,
						ICD-9 and ICD-10 are different code systems, not just different
						versions. By contrast, when LOINC updates from revision "1.0j" to
						"1.0k", HL7 would consider this to be just another version of LOINC,
						since LOINC revisions are backwards compatible.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x) {
   x.codeSystemVersion.nonNull.implies(x.codeSystem.nonNull);
};</pre></exhibit><p><emph role="strong">Definition:</emph>
						If applicable, a version descriptor defined specifically for the given
						code system.
					</p><p>
						HL7 shall specify how these version strings are formed for each
						external code system. If HL7 has not specified how version strings are
						formed for a particular coding system, version designations have no
						defined meaning for such coding system.
					</p><p>
						Different versions of one code system must be compatible. Whenever a
						code system changes in an incompatible way, it will constitute a new
						code system, not simply a different version, regardless of how the
						vocabulary publisher calls it.
					</p><p>
						For example, the publisher of ICD-9 and ICD-10 calls these code
						systems, "revision 9" and "revision 10" respectively. However, ICD-10
						is a complete redesign of the ICD code, not a backward compatible
						version. Therefore, for the purpose of this data type specification,
						ICD-9 and ICD-10 are different code systems, not just different
						versions. By contrast, when LOINC updates from revision "1.0j" to
						"1.0k", HL7 would consider this to be just another version of LOINC,
						since LOINC revisions are backwards compatible.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x) {
   x.codeSystemVersion.nonNull.implies(x.codeSystem.nonNull);
};</pre></exhibit></div3><div3 id="prop-PQR.displayName"><head>Display Name : <termref ref="dt-ST">ST</termref>, inherited from <termref ref="dt-CV">CV</termref></head><p><emph role="strong">Definition:</emph>
						A name or title for the code, under which the sending system shows the
						code value to its users.
					</p><p><emph>displayName</emph> is included both as a courtesy to an unaided human
						interpreter of a code value and as a documentation of the name used to
						display the concept to the user. The display name has no functional
						meaning; it can never exist without a code; <!-- FIXME: This isn't
						true! The CWE allows it to exist w/o a code --> and it can never
						modify the meaning of <termref ref="prop-CD.code">code</termref>.
					</p><note><p>
							HL7 offers a "print name" in it's predefined vocabulary domains. These
							values are suitable for use in the displayName.
						</p></note><note><p>
							Display names may not alter the meaning of the code value. Therefore,
							display names should not be presented to the user on a receiving
							application system without ascertaining that the display name
							adequately represents the concept referred to by the code
							value. Communication must not simply rely on the display name. The
							display name's main purpose is to support debugging of HL7 protocol
							data units (e.g., messages.)
						</p></note><exhibit role="dtdl"><caption/><pre>
invariant(CD x) {
   x.displayName.nonNull.implies(x.code.nonNull);
};</pre></exhibit><p><emph role="strong">Definition:</emph>
						A name or title for the code, under which the sending system shows the
						code value to its users.
					</p><p><emph>displayName</emph> is included both as a courtesy to an unaided human
						interpreter of a code value and as a documentation of the name used to
						display the concept to the user. The display name has no functional
						meaning; it can never exist without a code; <!-- FIXME: This isn't
						true! The CWE allows it to exist w/o a code --> and it can never
						modify the meaning of <termref ref="prop-CD.code">code</termref>.
					</p><note><p>
							HL7 offers a "print name" in it's predefined vocabulary domains. These
							values are suitable for use in the displayName.
						</p></note><note><p>
							Display names may not alter the meaning of the code value. Therefore,
							display names should not be presented to the user on a receiving
							application system without ascertaining that the display name
							adequately represents the concept referred to by the code
							value. Communication must not simply rely on the display name. The
							display name's main purpose is to support debugging of HL7 protocol
							data units (e.g., messages.)
						</p></note><exhibit role="dtdl"><caption/><pre>
invariant(CD x) {
   x.displayName.nonNull.implies(x.code.nonNull);
};</pre></exhibit></div3><div3 id="prop-PQR.originalText"><head>Original Text : <termref ref="dt-ED">ED</termref>, inherited from <termref ref="dt-CV">CV</termref></head><p><emph role="strong">Definition:</emph>
						The text or phrase used as the basis for the coding.
					</p><p>
						The original text exists in a scenario where an originator of the
						information does not assign a code, but where the code is assigned
						later by a coder (post-coding.)  In the production of a concept
						descriptor, original text may thus exist without a code.
					</p><note><p>
							Although post-coding is often performed from free text information,
							such as documents, scanned images or dictation, multi-media data is
							explicitly not permitted as original text. Also, the original text
							property is not meant to be a link into the entire source
							document. The link between different artifacts of medical information
							(e.g., document and coded result) is outside the scope of this
							specification and is maintained elsewhere in the HL7 standards. The
							original text is an excerpt of the relevant information in the
							original sources, rather than a pointer or exact reproduction. Thus
							the original text is to be represented in plain text form.
   <!-- FIXME: why are we so specific? --></p></note><p>
						Values of type <emph/> may have a non-NULL original text
						property despite having a NULL <termref ref="prop-CD.code">code</termref>. Any <emph/> value
						with <termref ref="prop-CD.code">code</termref> of NULL signifies a coding exception. In this case,
						<emph>originalText</emph> is a name or description of the concept that was
						not coded. Such exceptional <emph/> values may also contain <termref ref="prop-CD.translation">translation</termref>s.
						Such translations directly encode the concept described in <emph>originalText</emph>.
					</p><p>
						A <emph/> can be demoted into an <termref ref="dt-ST">ST</termref>
						value representing only the <emph>originalText</emph> of the <emph/> value.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x)
      where x.originalText.nonNull {
   ((ST)x).equal(x.originalText);
};</pre></exhibit><p><emph role="strong">Definition:</emph>
						The text or phrase used as the basis for the coding.
					</p><p>
						The original text exists in a scenario where an originator of the
						information does not assign a code, but where the code is assigned
						later by a coder (post-coding.)  In the production of a concept
						descriptor, original text may thus exist without a code.
					</p><note><p>
							Although post-coding is often performed from free text information,
							such as documents, scanned images or dictation, multi-media data is
							explicitly not permitted as original text. Also, the original text
							property is not meant to be a link into the entire source
							document. The link between different artifacts of medical information
							(e.g., document and coded result) is outside the scope of this
							specification and is maintained elsewhere in the HL7 standards. The
							original text is an excerpt of the relevant information in the
							original sources, rather than a pointer or exact reproduction. Thus
							the original text is to be represented in plain text form.
   <!-- FIXME: why are we so specific? --></p></note><p>
						Values of type <emph/> may have a non-NULL original text
						property despite having a NULL <termref ref="prop-CD.code">code</termref>. Any <emph/> value
						with <termref ref="prop-CD.code">code</termref> of NULL signifies a coding exception. In this case,
						<emph>originalText</emph> is a name or description of the concept that was
						not coded. Such exceptional <emph/> values may also contain <termref ref="prop-CD.translation">translation</termref>s.
						Such translations directly encode the concept described in <emph>originalText</emph>.
					</p><p>
						A <emph/> can be demoted into an <termref ref="dt-ST">ST</termref>
						value representing only the <emph>originalText</emph> of the <emph/> value.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(CD x)
      where x.originalText.nonNull {
   ((ST)x).equal(x.originalText);
};</pre></exhibit></div3></div2><div2 id="dt-MO"><anchor id="MO"/><head>Monetary Amount (MO) specializes <termref ref="dt-QTY">QTY</termref></head><p><emph role="strong">Definition:</emph>
					An <emph>MO</emph> is a quantity expressing the amount of money in some
					currency. Currencies are the units in which monetary amounts are
					denominated in different economic regions. While the monetary amount
					is a single kind of quantity (money) the exchange rates between the
					different units are variable.  This is the principle difference
					between <termref ref="dt-PQ">PQ</termref> and <emph>MO</emph>, and the reason why
					currency units are not physical units.
				</p><table id="dt-MO-prop-summary"><caption>Property Summary of
      Monetary Amount</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-MO.value">value</termref></td><td><termref ref="dt-REAL">REAL</termref></td><td>
							The magnitude of the <emph>MO</emph> in terms of <termref ref="prop-MO.currency">currency</termref>.
						</td></tr><tr><td><termref ref="prop-MO.currency">currency</termref></td><td><termref ref="dt-CS">CS</termref></td><td>
							The currency unit as defined in ISO 4217.
						</td></tr><tr><td><termref ref="prop-MO.diffType">diffType</termref></td><td><termref ref="dt-TYPE">TYPE</termref></td><td>
						The type of the difference between 2 values of a specific QTY data type.
					</td></tr></tbody></table><exhibit role="dtdl" id="dtdl-MO"><anchor id="dtdl-MO"/><caption/><pre>
type MonetaryAmount alias MO specializes QTY {
           REAL  value;
           CS    currency;
           MO    negated;
           MO    times(REAL x);
   literal ST;
};</pre></exhibit><div3 id="prop-MO.value"><head>Value : <termref ref="dt-REAL">REAL</termref></head><p><emph role="strong">Definition:</emph>
							The magnitude of the <emph>MO</emph> in terms of <termref ref="prop-MO.currency">currency</termref>.
						</p><note><p><emph>MO</emph> values are usually precise to 0.01 (one cent, penny, paisa,
								etc.)  For large amounts, it is important not to store <emph>MO</emph> values
								in floating point registers, since this may lose
								precision. However, this specification does not define the internal
								storage of <termref ref="dt-REAL">REAL</termref> as fixed or floating point numbers.
							</p></note><p><termref ref="prop-REAL.precision">REAL.precision</termref> is the precision of
							the decimal representation, not the precision of the value. <termref ref="dt-REAL">REAL</termref>
							has no notion of uncertainty or accuracy. For example,
							"1.99 USD" (precision 3) times 7 is "13.93 USD" (precision 4) and
							should not be rounded to "13.9" to keep the precision constant.
						</p></div3><div3 id="prop-MO.currency"><head>Currency : <termref ref="dt-CS">CS</termref></head><p><emph role="strong">Definition:</emph>
							The currency unit as defined in ISO 4217.
						</p><table id="domain-Currency"><caption>Domain Currency</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><td>ARS</td><td>Argentine Peso</td><td>Argentine Peso, monetary currency of Argentina</td></tr><tr valign="top"><td>AUD</td><td>Australian Dollar</td><td>Australian Dollar, monetary currency of Australia</td></tr><tr valign="top"><td>BRL</td><td>Brazilian Real</td><td>Brazilian Real, monetary currency of Brazil</td></tr><tr valign="top"><td>CAD</td><td>Canadian Dollar</td><td>Canadian Dollar, monetary currency of Canada</td></tr><tr valign="top"><td>CHF</td><td>Swiss Franc</td><td>Swiss Franc, monetary currency of Switzerland</td></tr><tr valign="top"><td>CLF</td><td>Unidades de Formento</td><td>Unidades de Formento, monetary currency of Chile</td></tr><tr valign="top"><td>CNY</td><td>Yuan Renminbi</td><td>Yuan Renminbi, monetary currency of China</td></tr><tr valign="top"><td>DEM</td><td>Deutsche Mark</td><td>Deutsche Mark, monetary currency of Germany</td></tr><tr valign="top"><td>ESP</td><td>Spanish Peseta</td><td>Spanish Peseta, monetary currency of Spain</td></tr><tr valign="top"><td>EUR</td><td>Euro</td><td>Euro, monetary currency of European Union</td></tr><tr valign="top"><td>FIM</td><td>Markka</td><td>Markka, monetary currency of Finland</td></tr><tr valign="top"><td>FRF</td><td>French Franc</td><td>French Franc, monetary currency of France</td></tr><tr valign="top"><td>GBP</td><td>Pound Sterling</td><td>Pound Sterling, monetary currency of United Kingdom</td></tr><tr valign="top"><td>ILS</td><td>Shekel</td><td>Shekel, monetary currency of Israel</td></tr><tr valign="top"><td>INR</td><td>Indian Rupee</td><td>Indian Rupee, monetary currency of India</td></tr><tr valign="top"><td>JPY</td><td>Yen</td><td>Yen, monetary currency of Japan</td></tr><tr valign="top"><td>KRW</td><td>Won</td><td>Won, monetary currency of Korea (South)</td></tr><tr valign="top"><td>MXN</td><td>Mexican Nuevo Peso</td><td>Mexican Nuevo Peso, monetary currency of Mexico</td></tr><tr valign="top"><td>NLG</td><td>Netherlands Guilder</td><td>Netherlands Guilder, monetary currency of Netherlands</td></tr><tr valign="top"><td>NZD</td><td>New Zealand Dollar</td><td>New Zealand Dollar, monetary currency of New Zealand</td></tr><tr valign="top"><td>PHP</td><td>Philippine Peso</td><td>Philippine Peso, monetary currency of Philippines</td></tr><tr valign="top"><td>RUR</td><td>Russian Ruble</td><td>Russian Ruble, monetary currency of Russian Federation</td></tr><tr valign="top"><td>THB</td><td>Baht</td><td>Baht, monetary currency of Thailand</td></tr><tr valign="top"><td>TRL</td><td>Lira</td><td>Lira, monetary currency of Turkey</td></tr><tr valign="top"><td>TWD</td><td>Taiwan Dollar</td><td>Taiwan Dollar, monetary currency of Taiwan</td></tr><tr valign="top"><td>USD</td><td>US Dollar</td><td>US Dollar, monetary currency of United States</td></tr><tr valign="top"><td>ZAR</td><td>Rand</td><td>Rand, monetary currency of South Africa</td></tr></table><p>
							This table only shows a representative subset of the 
							codes defined by ISO 4217. All codes from ISO 4127 are 
							valid for this attribute
						</p></div3><div3 id="prop-MO.equal"><head>Equality : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref></head><p>
							Two <emph>MO</emph> values are equal if both <termref ref="prop-MO.value">value</termref> and
							<termref ref="prop-MO.currency">currency</termref> are equal.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(MO x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.value.equal(y.value)
             .and(x.unit.equal(y.unit)));
};</pre></exhibit></div3><div3 id="prop-MO.compares"><head>Comparability : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-QTY">QTY</termref></head><p>
							Two <emph>MO</emph> values can be compared to each other (and have an ordering and
							difference) if their <termref ref="prop-MO.currency">currency</termref>s are equal.
						</p><p>
							If their <termref ref="prop-MO.currency">currency</termref>s are not identical,
							the <termref ref="prop-MO.values">values</termref> cannot be
							compared. Conversion between currencies is outside the scope of
							this specification. In practice, foreign exchange rates are highly
							variable not only over long and short amounts of time, but also
							depending on location and access to currency trade markets.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(MO x, y)
      where x.nonNull.and(y.nonNull) {
   x.compares.equal(x.currency.equal(y.currency));
};</pre></exhibit></div3><div3 id="prop-MO.diffType"><head>DifferenceDataType : <termref ref="dt-TYPE">TYPE</termref>, inherited from <termref ref="dt-QTY">QTY</termref></head><exhibit role="dtdl"><caption/><pre>
invariant(INT x) {
   x.diffType.implies(MO);
};</pre></exhibit><p>
							The difference between 2 <emph>MO</emph>s is another <emph>MO</emph>.
						</p></div3><div3 id="prop-MO.plus"><head>Addition : <termref ref="dt-MO">MO</termref></head><argument name="x" type="MO"/><p><emph role="strong">Definition:</emph>
							Two <emph>MO</emph>s can be added if their
							<termref ref="prop-MO.currency">currency</termref>s are equal.
						</p><exhibit role="dtdl"><caption/><pre>
invariant (MO x, y)
      where x.currency.equal(y.currency) {
   x.plus(y).currency.equal(x.currency);
   x.plus(y).value.equal(x.value.plus(y.value));
};</pre></exhibit></div3><div3 id="prop-MO.timesREAL"><head>Real Multiplication : <termref ref="dt-MO">MO</termref></head><argument name="x" type="REAL"/><p><emph role="strong">Definition:</emph>
							Multiplication with a <termref ref="dt-REAL">REAL</termref> forms a scaled quantity. A scaled
							quantity is comparable to its original quantity.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(MO x; REAL r)
      where x.nonNull.and(r.nonNull) {
   x.times(r).value.equal(x.value.times(r));
   x.times(r).currency.equal(x.currency);
};</pre></exhibit></div3><div3 id="prop-MO.literal"><head>Literal Form</head><p>
							The literal form for an <emph>MO</emph> consists of a currency code string,
							optional whitespace, and a <termref ref="dt-REAL">REAL</termref> literal amount.
						</p><exhibit role="dtdl"><caption/><pre>
MO.literal ST {
   MO           : currency value  { $.currency.equal($1); }
                                    $.value.equal($2);
   CS  currency : ST              { $.currency.value.equal($1);
                                    $.currency.codeSystem
                                    .equal(2.16.840.1.113883.6.9); }
   REAL value   : REAL           { $.value.equal($1); }
};</pre></exhibit><p>
							For example, "USD189.95" is the literal for 189.95 U.S. Dollar.
						</p></div3></div2><div2 id="dt-CAL"><anchor id="CAL"/><head>Calendar (CAL) specializes <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-CLCY">CLCY</termref>&gt;</head><p><emph role="strong">Definition:</emph>
					A calendar is a concept of measuring time in various cycles. Such
					cycles are years, months, days, hours, minutes, seconds, and
					weeks. Some of these cycles are synchronized and some are not (e.g.,
					weeks and months are not synchronized.)
				</p><p>
					After "rolling the time axis" into these cycles
					a calendar expresses a point in time as a sequence
					of integer counts of cycles, e.g., for year, month, day, hour,
					etc. The calendar is rooted in some conventional start point, called
					the "epoch."
				</p><graphic source="graphics/datyp2fig9.jpg" alt=""/><p>
					A calendar "rolls" the time axis into a complex convolute according to
					the calendar periods year (blue), month (yellow), day (green), hour
					(red), etc. The cycles need not be aligned, for example, the week (not
					shown) is not aligned to the month.<footnote><p>
							Imagine a special clock that measures those cycles, where the pointers
							are not all stacked on a common axis but each pointer is attached to
							the end of the pointer measuring the next larger cycle.
						</p></footnote></p><p>
					Calendar is defined as a set of calendar cycles, and has a name and a
					code. The head of the Calendar is the largest CalendarCycle appearing
					right most in the calendar expression. The epoch is the beginning of
					that calendar, i.e., the point in time where all calendar cycles are
					zero.
				</p><exhibit role="dtdl"><caption/><pre>
private type Calendar alias CAL specializes SET&lt;CLCY&gt;  {
   CS    name;
   CLCY  head;
   TS    epoch;
};

invariant(CAL c)
      where c.nonNull {
   c.name.nonNull;
   c.contains(c.head);
};</pre></exhibit><p>
					The calendar definition can be shown as in <tabref ref="domain-CalendarCycle"/>
					for the modern Gregorian calendar. The calendar definition table lists a
					calendar cycle in each row. The calendar units are dependent on each other and
					defined in the value column. The sequence column shows the relationship through
					the next property. The other columns are as in the formal calendar cycle
					definition.<footnote><p> 
							At present, the CalendarCycle properties sum and value are not
							formally defined. The computation of calendar digits involves some
							complex computation which to specify here would be hard to understand
							and evaluate for correctness. Unfortunately, no standard exists that
							would formally define the relationship between calendar expressions
							and elapsed time since an epoch. ASN.1, the XML Schema Data Type
							specification and SQL92 all refer to ISO 8601, however, ISO 8601 does
							only specify the syntax of Gregorian calendar expressions, but not
							their semantics. In this standard, we define the syntax and semantics
							formally, however, we presume the semantics of the sum-, and
							value-properties to be defined elsewhere.  
						</p></footnote></p><table id="domain-CalendarCycle"><caption>Domain CalendarCycle</caption><thead><tr valign="bottom"><th>name</th><th>code 1</th><th>code 2</th><th>counter</th><th>digits</th><th>start</th><th>condition</th></tr></thead><tbody><tr valign="top"><td>year</td><td>Y</td><td>CY</td><td>1</td><td>4</td><td>0</td><td></td></tr><tr valign="top"><td>month of the year</td><td>M</td><td>MY</td><td>2</td><td>2</td><td>1</td><td></td></tr><tr valign="top"><td>month (continuous)</td><td></td><td>CM</td><td></td><td></td><td>0</td><td></td></tr><tr valign="top"><td>week (continuous)</td><td>W</td><td>CW</td><td></td><td></td><td>0</td><td></td></tr><tr valign="top"><td>week of the year</td><td></td><td>WY</td><td></td><td>2</td><td>1</td><td></td></tr><tr valign="top"><td>day of the month</td><td>D</td><td>DM</td><td>3</td><td>2</td><td>1</td><td></td></tr><tr valign="top"><td>day (continuous)</td><td></td><td>CD</td><td></td><td></td><td>0</td><td></td></tr><tr valign="top"><td>day of the year</td><td></td><td>DY</td><td></td><td>3</td><td>1</td><td></td></tr><tr valign="top"><td>day of the week (begins with Monday)</td><td>J</td><td>DW</td><td></td><td>1</td><td>1</td><td></td></tr><tr valign="top"><td>hour of the day</td><td>H</td><td>HD</td><td>4</td><td>2</td><td>0</td><td></td></tr><tr valign="top"><td>hour (continuous)</td><td></td><td>CH</td><td></td><td></td><td>0</td><td></td></tr><tr valign="top"><td>minute of the hour</td><td>N</td><td>NH</td><td>5</td><td>2</td><td>0</td><td></td></tr><tr valign="top"><td>minute (continuous)</td><td></td><td>CN</td><td></td><td></td><td>0</td><td></td></tr><tr valign="top"><td>second of the minute</td><td>S</td><td>SN</td><td>6</td><td>2</td><td>0</td><td></td></tr><tr valign="top"><td>second (continuous)</td><td></td><td>CS</td><td></td><td></td><td>0</td><td></td></tr></tbody></table></div2><div2 id="dt-CLCY"><anchor id="CLCY"/><head>Calendar Cycle (CLCY) specializes <termref ref="dt-ANY">ANY</termref></head><p><emph role="strong">Definition:</emph>    
					A calendar cycle defines one group of decimal digits in the calendar
					expression. Examples for calendar cycles are year, month, day, hour,
					minute, second, and week.
				</p><p>
					A calendar cycle has a name and two codes, a one-letter code and a
					two-letter code. The property <emph>ndigits</emph> is the number of
					decimal digits occupied in the calendar expression. The property
					<emph>start</emph> specifies where counting starts (i.e., at 0 or 1.)
					The <emph>next</emph> property is the next lower cycle in the order of
					the calendar expression. The max(<emph>t</emph>) property is the
					maximum number of cycles at time <emph>t</emph> (max depends on the
					time <emph>t</emph> to account for leap years and leap seconds.)  The
					property value(<emph>t</emph>) is the integer number of cycles shown
					in the calendar expression of time <emph>t</emph>. The property
					sum(<emph>t</emph>, <emph>n</emph>) is the sum of <emph>n</emph>
					calendar cycles added to the time <emph>t</emph>.
				</p><exhibit role="dtdl"><caption/><pre>
private type CalendarCycle alias CALCY specializes ANY {
   CE     name;
   INT    ndigits;
   INT    start;
   CALCY  next;
   INT    max(TS);
   TS     sum(TS t, REAL r);
   INT    value(TS t);
};

invariant(CALCY c)
      where c.nonNull {
   c.name.nonNull;
   c.start.equal(0).or(c.start.equal(1));
   c.digits.greaterThan(0);
};</pre></exhibit></div2><div2 id="dt-TS"><anchor id="TS"/><head>Point in Time (TS) specializes <termref ref="dt-QTY">QTY</termref></head><p><emph role="strong">Definition:</emph>
					A quantity specifying a point on the axis of natural time. A point
					in time is most often represented as a calendar expression.
				</p><p>
					Semantically, however, time is independent from calendars and best
					described by its relationship to elapsed time (measured as a physical
					quantity in the dimension of time).  A <emph>TS</emph> plus an elapsed
					time yields another <emph>TS</emph>.  Inversely, a <emph>TS</emph> minus
					another <emph>TS</emph> yields an elapsed time.
				</p><p>
					As nobody knows when time began, a <emph>TS</emph> is conceptualized as
					the amount of time that has elapsed from some arbitrary zero-point,
					called an epoch.  Because there is no absolute zero-point on the time
					axis; natural time is a difference-scale quantity, where only
					differences are defined but no ratios. (For example, no <emph>TS</emph>
					is &#8212; absolutely speaking &#8212; "twice as late" as another
					<emph>TS</emph>.)
				</p><p>
					Given some arbitrary zero-point, one can express any point in time as
					an elapsed time measured from that offset. Such an arbitrary
					zero-point is called an epoch. This epoch-offset form is used as a
					semantic representation here, without implying that any system would
					have to implement <emph>TS</emph> in that way. Systems that do not
					need to compute distances between <emph>TS</emph>s will not need any
					other representation than a calendar expression literal.
				</p><exhibit role="dtdl" id="dtdl-TS"><anchor id="dtdl-TS"/><caption/><pre>
type PointInTime alias TS specializes QTY {
           PQ   offset;
           CS   calendar;
           INT  precision;
           PQ   timezone;
           BL   equal(ANY x);
  literal  ST;
};</pre></exhibit><div3 id="prop-TS.offset"><head>Offset from Epoch : <termref ref="dt-PQ">PQ</termref></head><p><emph role="strong">Definition:</emph>
							The elapsed time since any constant epoch, measured as a physical
							quantity in the dimension of time (i.e., comparable to one second.)
						</p><exhibit role="dtdl"><caption/><pre>
invariant(TS x)
      where x.nonNull {
   x.offset.compares(1 s);
};</pre></exhibit><p>
							It is not necessary for this specification to define a canonical
							epoch; the semantics is the same for any epoch, as long as the epoch
							is constant.
						</p><note role="its"><p><emph>offset</emph> may be treated as a purely semantic property that
								is not represented in any way other than the calendar literal
								expression. However, an ITS may just as well choose to define a
								constant epoch and represent <emph>TS</emph> values as elapsed time
								offsets relative to that epoch. However, an ITS using an epoch-offset
								representation would still need to communicate the calendar code and
								the precision of a calendar representation once other calendars are
								supported.
							</p></note></div3><div3 id="prop-TS.equal"><head>Equality : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-QTY">QTY</termref></head><p>
							Two <emph>TS</emph> values are equal if and only if their
							<termref ref="prop-TS.offset">offset</termref>s
							(relative to the same epoch) are equal.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(TS x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.offset.equal(y.offset));
};</pre></exhibit></div3><div3 id="prop-TS.calendar"><head>Calendar : <termref ref="dt-CS">CS</termref></head><p><emph role="strong">Definition:</emph>
							A code specifying the calendar used in the literal representation of
							this <emph>TS</emph>.<footnote><p>
									At this time, no other calendars than the Gregorian calendar are
									defined. However, the notion of a calendar as an arbitrary convention
									to specify absolute time is important to properly define the semantics
									of time and time-related data types. Furthermore, other calendars
									might be supported when needed to facilitate HL7's use in other
									cultures.
								</p></footnote></p><table id="domain-Calendar"><caption>Domain Calendar</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><td>GREG</td><td>Gregorian</td><td>The Gregorian calendar is the calendar in effect in most countries of Christian influence since approximately 1582. This calendar superceded the Julian calendar.</td></tr></table><p>
							The purpose of this property is mainly to faithfully convey what has
							been entered or seen by a user in a system originating such a
							<emph>TS</emph> value. <emph>calendar</emph> also advises any system
							rendering a <emph>TS</emph> value into a literal form of which calendar
							to use. However, this is only advice; any system that renders
							<emph>TS</emph> values to users may choose to use the calendar and
							literal form demanded by its users rather than the calendar mentioned
							in <emph>calendar</emph>. Hence, <emph>calendar</emph> is not constant
							in communication between systems, the calendar is not part of the
							equality test.
						</p><p>
							For the purpose of defining the relationship between calendar
							expression and epoch/offset form, two private data types,
							<termref ref="dt-CAL">CAL</termref> and <termref ref="dt-CLCY">CLCY</termref>
							are defined. These calendar data types
							exist only for defining this specification. These private data types
							may not be used at all outside this specification.
						</p></div3><div3 id="prop-TS.precision"><head>Precision of the Calendar Literal Form : <termref ref="dt-INT">INT</termref></head><p><emph role="strong">Definition:</emph>
							The number of significant digits of the calendar expression
							representation.
						</p><p><emph>precision</emph> is formally defined based on the <termref ref="prop-TS.literal">literal</termref>.
						</p><p><emph>precision</emph> is only the precision of a decimal digit
							representation, <emph>not the accuracy of the <emph>TS</emph>
							value</emph>.
						</p><p>
							The purpose of <emph>precision</emph>
							is to faithfully capture the whole information presented to humans in
							a calendar expression. The number of digits shown conveys information
							about the uncertainty (i.e., precision and accuracy) of a measured
							<emph>TS</emph>.
						</p><note><p>
								The precision of the representation is independent from uncertainty
								(precision accuracy) of a measurement result. If the uncertainty of a
								measurement result is important, one should specify uncertain values
								as <termref ref="dt-PPD">PPD</termref></p></note><p><emph>precision</emph> is dependent on <termref ref="prop-TS.calendar">calendar</termref>.
							A given <emph>precision</emph> relative to one calendar does not mean the same in another
							calendar with different periods.
						</p><p>
							For example "20000403" has 8 significant digits <emph>in the
							representation</emph>, but the <emph>uncertainty of the value</emph>
							may be in any digit shown or not shown, i.e., the uncertainty may be
							to the day, to the week, or to the hour. Note that external
							representations <emph>should</emph> adjust their representational
							precision with the uncertainty of the value. However, since the
							precision in the digit string depends on the calendar and is granular
							to the calendar periods, uncertainty may not fall into that grid
							(e.g., 2000040317 is an adequate representation for the value between
							2000040305 and 2000040405.)
						</p><note role="its"><p>
								A character based ITS need not
								represent <emph>precision</emph> as an explicit attribute if <emph>TS</emph>
								values are represented as literal calendar expressions. A <emph>TS</emph>
								representation must not produce more or less significant digits
								than were originally in that value. Conformance can be tested through
								round-trip encoding - decoding - encoding.
							</p></note></div3><div3 id="prop-TS.timezone"><head>Timezone Offset : <termref ref="dt-PQ">PQ</termref></head><p><emph role="strong">Definition:</emph>
							The difference between the local time in that time zone and Universal
							Coordinated Time (UTC, formerly called Greenwich Mean Time, GMT). The
							time zone is a <termref ref="dt-PQ">PQ</termref> in the dimension of time (i.e.,
							comparable to one second.)  A zero time zone value specifies UTC. The
							time zone value does not permit conclusions about the geographical
							longitude or a conventional time zone name.
						</p><p>
							For example, 200005121800-0500 may be eastern standard time (EST) in
							Indianapolis, IN, or central daylight savings time (CDT) in Decatur,
							IL. Furthermore in other countries having other latitude the time
							zones may be named differently.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(TS x, y)
      where x.nonNull.and(y.nonNull) {
   x.timezone.compares(1 s);
};</pre></exhibit><p>
							When <emph>timezone</emph> is NULL (unknown), "local time" is
							assumed. However, "local time" is always local to some place, and
							without knowledge of that place, the time zone is unknown. Hence, a
							local time cannot be converted into UTC. <emph>timezone</emph> should be
							specified for all <emph>TS</emph> values in order to avoid a significant
							loss of precision when <emph>TS</emph>s are compared. The difference of
							two local times where the locality is unknown has an error of
							12 hours.
						</p><p>
							In administrative data context, some time values do not carry a time
							zone. For a date of birth in administrative data, for example, it
							would be incorrect to specify <emph>timezone</emph>, since this may effectively
							change the date of birth when converted into other time zones. For
							such administrative data the time zone is NULL (not applicable.)
						</p></div3><div3 id="prop-TS.diffType"><head>DifferenceDataType : <termref ref="dt-TYPE">TYPE</termref>, inherited from <termref ref="dt-QTY">QTY</termref></head><exhibit role="dtdl"><caption/><pre>
invariant(TS x) {
   x.diffType.implies(PQ);
};</pre></exhibit><p>
							The difference between 2 <emph>TS</emph>s is a <termref ref="dt-PQ">PQ</termref> in
							the dimension of time.
						</p></div3><div3 id="prop-TS.plus"><head>Addition : <termref ref="dt-TS">TS</termref>, inherited from <termref ref="dt-QTY">QTY</termref></head><argument name="x" type="QTY"/><p><emph role="strong">Definition:</emph>
							A <emph>TS</emph> plus an elapsed time (i.e., <termref ref="dt-PQ">PQ</termref> in the
							dimension of time) is a <emph>TS</emph>.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(TS x, PQ t)
      where x.nonNull.and(t.compares(1 s)) {
   x.plus(t).offset.equal(x.offset.plus(t));
};</pre></exhibit></div3><div3 id="prop-TS.minus"><head>Difference : <termref ref="dt-QTY">QTY</termref>, inherited from <termref ref="dt-QTY">QTY</termref></head><argument name="x" type="TS"/><p><emph role="strong">Definition:</emph>
							The difference between two <emph>TS</emph>s is an elapsed time.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(TS x)
      where x.nonNull {
   x.minus(y).offset.equal(
      x.offset.plus(y.offset.negated));
};</pre></exhibit></div3><div3 id="prop-TS.literal"><head>Literal Form</head><p><emph>TS</emph> literals are simple calendar expressions, as defined by
							the calendar definition table. By default, the western (Gregorian)
							calendar shall be used (<tabref ref="domain-CalendarCycle"/>).
						</p><p>
							For the default Gregorian calendar the calendar expression literals of
							this specification conform to the constrained ISO 8601 that is defined
							in ISO 8824 (ASN.1) under clause 32 (generalized time) and to the HL7
							Version 2 TS data type.
						</p><p>
							Calendar expression literals are sequences of integer numbers ordered
							according to the "counter" column of <tabref ref="domain-CalendarCycle"/>.
							Periods with lower order numbers stand to the left of periods with higher order
							numbers. Periods with no assigned order number cannot occur in the calendar
							expression for <emph>TS</emph>.
						</p><p>
							The "digits" column of <tabref ref="domain-CalendarCycle"/>
							specifies the exact number of digits for the counter number for any
							period.
						</p><p>
							Thus, <tabref ref="domain-CalendarCycle"/> specifies that western
							calendar expressions begin with the 4-digit year (beginning counting
							at zero); followed by the 2-digit month of the year (beginning
							counting at one); followed by the 2-digit day of the month (beginning
							with one); followed by the 2-digit hour of the day (beginning with
							zero); and so forth. For example, "200004010315" is a valid expression
							for April 1, 2000, 3:15 am.
						</p><p>
							A calendar expression can be of variable precision, omitting parts
							from the right.
						</p><p>
							For example, "20000401" is precise only to the day of the month.
						</p><p>
							The least defined calendar period (i.e. the second) may be written as
							a <termref ref="dt-REAL">REAL</termref>, with the number of integer digits specified, followed
							by the decimal point and any number of fractional digits.
						</p><p>
							For example, "20000401031520.34" means April 1, 2000, 3:15 and 20.34
							seconds.
						</p><p>
							When other calendars are used in the future, a prefix "GREG:" can
							be placed before the western (Gregorian) calendar expression to
							disambiguate from other calendars. Each calendar shall have its own
							prefix. However, the western calendar is the default if no prefix is
							present.
						</p><p>
							In the modern Gregorian calendar (and all calendars where time of day
							is based on UTC), the calendar expression may contain a time zone
							suffix. The time zone suffix begins with a plus (+) or minus (-)
							followed by digits for the hour and minute cycles. UTC is designated
							as offset "+00" or "-00"; the ISO 8601 and ISO 8824 suffix "Z" for UTC
							is not permitted.
						</p><exhibit role="dtdl"><caption/><pre>
TS.literal ST {
   TS   : cal timestamp($1)                  { $.equal($2); }
        | timestamp(GREG)                    { $.equal($1); };

   TS timestamp(Calendar C)
        : cycles(C.head, C.epoch) zone(C)    { $.equal($1.minus($2)); }
                                               $.timezone.equal($2); }
        | cycles(C.head, C.epoch)            { $.equal($1);
                                               $.timezone.unknown; };
   Calendar cal
        : /[a-zA-Z_][a-zA-Z0-9_]*:/          { $.equal($1); };

   TS cycles(CalendarCycle c, TS t)
        : cycle(c, t) cycles(c.next, $1)     { $.equal($2); }
        | cycle(c, t) "." REAL.fractional    { $.equal(c.sum($1, $3));
                                               $.precision.equal(
                                                  t.precision.plus($3.precision)); }
        | cycle(c, t)                        { $.equal($1); };

   TS cycle(CalendarCycle c, TS t)
        : /[0-9]{c.ndigits}/                 { $.equal(c.sum(t, $1));
                                                $.precision.equal(
                                                   t.precision.plus(c.ndigits)); };

   PQ zone(Calendar C)
        : "+" cycles(C.zonehead, C.epoch)    { $.equal($2.minus(C.epoch)); }
        | "-" cycles(C.zonehead, C.epoch)    { $.equal(C.epoch.minus($2)); };
};</pre></exhibit></div3></div2></div1>
<div1 id="datyp2gencol"  ballotStatus="NormativeStandard"><head>Generic Collections</head><graphic source="graphics/dtUML-GenericCollections.gif" alt="Generic Collection Data Types"/><p>
				This section defines data types that can "collect" other data values,
				Set, Sequence, Bag and Interval.<footnote><p>
				In some programming languages, "collection types" are understood as
				containers of individually enumerated data items, and thus, an
				interval (low - high) would not be considered a collection. Such
				narrow interpretation of "collection" however is heavily
				representation/implementation dependent. From a data type semantics
				viewpoint, it doesn't matter whether an element of a collection "is
				actually contained in the collection" or not. There is no need for all
				elements in a collection to be individually enumerated.
					</p></footnote> These collection types are defined as generic
				(parameterized) types. The concept of generic types is described in
				<specref ref="generics"/>.
			</p><!-- FIXME: sectionref doesn't exist as an element --><div2 id="dt-SET"><anchor id="SET"/><head>Set (SET) specializes <termref ref="dt-ANY">ANY</termref></head><parameter name="T" type="ANY"/><p><emph role="strong">Definition:</emph>
					A value that contains other distinct values in no particular order.
				</p><exhibit role="dtdl" id="dtdl-SET"><anchor id="dtdl-SET"/><caption/><pre>
template&lt;ANY T&gt;
type Set&lt;T&gt; alias SET&lt;T&gt; specializes ANY {
             BL      contains(T element);
             BL      isEmpty;
             BL      notEmpty;
             BL      contains(SET&lt;T&gt; subset);
             INT     cardinality;
             SET&lt;T&gt;  union(SET&lt;T&gt; otherset);
             SET&lt;T&gt;  union(T element);
             SET&lt;T&gt;  except(T element);
             SET&lt;T&gt;  except(SET&lt;T&gt; otherset);
             SET&lt;T&gt;  intersection(SET&lt;T&gt; otherset);
  literal    ST;
  promotion  SET&lt;T&gt;  (T x);
             IVL&lt;T&gt;  hull;
};</pre></exhibit><div3 id="prop-SET.containsElement"><head>Contains Element : <termref ref="dt-BL">BL</termref></head><argument name="element" type="T"/><p><emph role="strong">Definition:</emph>
							A relation of the set with its elements, true if the given value is an
							element of the set.
						</p><p>
							This is the primitive semantic property of a set, based on which all
							other properties are defined.
						</p><p>
								A set may only contain distinct non-NULL elements. Exceptional values
								(NULL-values) cannot be elements of a set.
							</p><exhibit role="dtdl"><caption/><pre>
invariant(SET&lt;T&gt; s, T n)
      where s.nonNull.and(n.isNull) {
   s.contains(n).not;
};</pre></exhibit></div3><div3 id="prop-SET.containsSet"><head>Contains Subset : <termref ref="dt-BL">BL</termref></head><argument name="subset" type="SET&lt;T&gt;"/><p><emph role="strong">Definition:</emph>
							The relation between a set and its subsets, where each element in the
							subset is also an element of the superset.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(SET&lt;T&gt; superset, subset) 
      where superset.nonNull.and(subset.nonNull)
         superset.contains(subset).equal(
      forall(T element) where subset.contains(element) {
         superset.contains(element);      
	     });
};</pre></exhibit><p>
							This implies that the empty set is a subset of every set including
							itself.
						</p></div3><div3 id="prop-SET.notEmpty"><head>Not-Empty : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph> 
							A predicate indicating that this set contains elements.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(SET&lt;T&gt; set)
      where set.nonNull {
   set.notEmpty.equal(exists(T element) {
      set.contains(element);
      });
};</pre></exhibit></div3><div3 id="prop-SET.isEmpty"><head>The Empty Set : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph>          
							A predicate indicating that this set has no elements (negation of the
							<termref ref="prop-SET.notEmpty">notEmpty</termref>. The
							empty set is a proper set value, <emph>not</emph> an exceptional
							(NULL) value.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(SET&lt;T&gt; set)
      where set.nonNull {
   set.isEmpty.equal(notEmpty.not);
};</pre></exhibit></div3><div3 id="prop-SET.cardinality"><head>Cardinality : <termref ref="dt-INT">INT</termref></head><p><emph role="strong">Definition:</emph>      
							The cardinality of a set is the number of distinct elements in the set.    
						</p><exhibit role="dtdl"><caption/><pre>
invariant(SET&lt;T&gt; set)
      where set.nonNull {
   exists(T element) where set.contains(element) {
      set.cardinality.equal(set.except(element)
                     .cardinality.successor);
         };
};</pre></exhibit><p>
							The cardinality definition is not sufficient since it doesn't converge
							for uncountably infinite sets (<termref ref="dt-REAL">REAL</termref>, <termref ref="dt-PQ">PQ</termref>, 
							etc.) and it doesn't terminate for infinite sets. In
							addition, the definition of integer number type in this specification
							is incomplete for these cases, as it doesn't account for
							infinities. Finally the cardinality value is an example where it would
							be necessary to distinguish the cardinality &#8501;<emph role="sub">0</emph> 
							(<emph>aleph</emph><emph role="sub">0</emph>) of countably infinite sets
							(e.g., <termref ref="dt-INT">INT</termref>) from &#8501;<emph role="sub">1</emph>
							(<emph>aleph</emph><emph role="sub">1</emph>), the cardinality of uncountable sets 
							(e.g., <termref ref="dt-REAL">REAL</termref>, <termref ref="dt-PQ">PQ</termref>).
						</p></div3><div3 id="prop-SET.union"><head>Union : <termref ref="dt-SET">SET</termref>&lt;T&gt;</head><argument name="otherset" type="SET&lt;T&gt;"/><p><emph role="strong">Definition:</emph>          
							A union of two sets (component sets) is a set where each of the
							union's elements also is an element of either one component set.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(SET&lt;T&gt; x, y, z)
      where x.nonNull.and(y.nonNull).and(z.nonNull) {
   x.union(y).equal(z).equal(forall(T e) {
      z.contains(e).equal(x.contains(e).or(y.contains(e)));
      });
};</pre></exhibit></div3><div3 id="prop-SET.unionElement"><head>Include Element : <termref ref="dt-SET">SET</termref>&lt;T&gt;</head><!-- FIXME what, why hide? --><argument name="element" type="T"/><p><emph role="strong">Definition:</emph>          
							A union of a set and an element.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(SET&lt;T&gt; set, singletonset, T element)
      where set.nonNull.and(element.nonNull)
               .and(singletonset.cardinality.isOne)
               .and(singletonset.contains(element)) {
   set.union(element).equal(set.union(singleton));
};</pre></exhibit></div3><div3 id="prop-SET.difference"><head>Set Difference : <termref ref="dt-SET">SET</termref>&lt;T&gt;</head><argument name="set" type="SET&lt;T&gt;"/><p><emph role="strong">Definition:</emph>
							The difference of this set and its subtracting set is the set that
							contains all elements of this set that are not elements of the
							subtracting set.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(SET&lt;T&gt; x, y, z)
      where x.nonNull.and(y.nonNull).and(z.nonNull) {
   x.except(y).equal(z).equal(forall(T e) {
      z.contains(e).equal(x.contains(e).and(y.contains(e).not));
      });
};</pre></exhibit></div3><div3 id="prop-SET.exceptElement"><head>Exclude Element : <termref ref="dt-SET">SET</termref>&lt;T&gt;</head><argument name="element" type="T"/><p><emph role="strong">Definition:</emph>          
							The difference between this set and an element value is the set
							that contains all elements of this set except for the subtracting
							element value. If the element value is not contained in this set,
							the difference is equal to this set.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(SET&lt;T&gt; x, z; T d)
      where z.nonNull.and(z.nonNull).and(d.nonNull) {
   x.except(d).equal(z).equal(forall(T e) {
      z.contains(e).equal(x.contains(e).and(d.equal(e).not));
      });
};</pre></exhibit></div3><div3 id="prop-SET.intersect"><head>Intersection : <termref ref="dt-SET">SET</termref>&lt;T&gt;</head><argument name="otherset" type="SET&lt;T&gt;"/><p><emph role="strong">Definition:</emph>          
							The intersection between two sets is a set containing all and only
							those elements that are contained in both of the operand sets.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(SET&lt;T&gt; x, y, z)
      where x.nonNull.and(y.nonNull).and(z.nonNull) {
   x.intersection(y).equal(z).equal(forall(T e) {
      z.contains(e).equal(x.contains(e).and(y.contains(e)));
      });
};</pre></exhibit></div3><div3 id="prop-SET.literal"><head>Literal Form</head><p>
							When the element type T has a literal form, the set of T elements has
							a literal form, wherein the elements of the set are enumerated within
							curly braces and separated by semicolon characters.
						</p><exhibit role="dtdl"><caption/><pre>
SET&lt;T&gt;.literal ST {
   SET&lt;T&gt;          : "{" elements "}"   { $.equal($2); };
   SET&lt;T&gt; elements : elements ";" T     { $.except($2).equal($1); }
                  | T                   { $.contains($1);
                                          $.except($1).isEmpty; };
};</pre></exhibit><note><p>
								This literal form for sets is only practical for relatively small
								enumerable sets; this does not mean, however, that all sets are
								relatively small enumerations of elements.
							</p></note><table id="table-SET.literal.example"><caption>Example</caption><thead><tr><th rowspan="1" colspan="1">literal</th><th rowspan="1" colspan="1">meaning</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">{1; 3; 5; 7; 19}</td><td rowspan="1" colspan="1">a set of integer numbers or real numbers</td></tr><tr><td rowspan="1" colspan="1">{3; 1; 5; 19; 7}</td><td rowspan="1" colspan="1">the same set of integer numbers or real numbers</td></tr><tr><td rowspan="1" colspan="1">{1.2 m; 2.67 m; 17.8 m}</td><td rowspan="1" colspan="1">a set of discrete physical quantities</td></tr><tr><td rowspan="1" colspan="1">{apple; orange; banana}</td><td rowspan="1" colspan="1">a set of character strings</td></tr></tbody></table><note role="its"><p>
								A character-based ITS <emph>should</emph> choose a different literal
								form for sets if the Implementation Technology has a more native
								literal form for such collections.
							</p></note></div3><div3 id="prop-SET.promotionT"><head>Promotion of Element Values to Sets : <termref ref="dt-SET">SET</termref>&lt;T&gt;</head><argument name="x" type="T"/><p>
							A data value of type T can be promoted into a trivial set of T with
							that data value as its only element.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(T x) {
   ((SET&lt;T&gt;)x).contains(x);
   ((SET&lt;T&gt;)x).except(x).isEmpty;
};</pre></exhibit></div3><div3 id="prop-SET.hull"><head>Convex Hull of Totally Ordered Sets : <termref ref="dt-IVL">IVL</termref>&lt;T&gt;</head><p>
							Sets of quantities may be totally ordered sets when there is an order
							relationship defined between any two elements in the set. Note that
							"ordered set" does not mean the same as Sequence (<termref ref="dt-LIST">LIST</termref>). 
							For example, the set {3; 2; 4; 88; 1} is an ordered
							set. The ordering of the elements in the set notation is still
							irrelevant, but elements can be compared to establish an order (1; 2;
							4; 88).
						</p><p>
							Totally ordered sets have convex hull. A convex hull of a totally
							ordered set <emph>S</emph> is the smallest interval that is a superset
							of <emph>S</emph>. This concept is going to be important later on.
						</p><exhibit role="dtdl"><caption/><pre>
type Set&lt;QTY&gt; alias SET&lt;QTY&gt; {
   BL            totallyOrdered;
   IVL&lt;T&gt;  hull;
};

invariant(SET&lt;QTY&gt; s)
      where s.nonNull {
   s.totallyOrdered.equal(forall(QTY x, y)
         where s.contains(x).and(s.contains(y)) {
      x.compares(y); });
};

invariant(SET&lt;QTY&gt; s)
      where s.totallyOrdered {
   s.hull.contains(s);
   forall(T e)
         where s.contains(e) {
      s.hull.low.lessOrEqual(e);
      e.lessOrEqual(s.hull.high);
      };
};</pre></exhibit><p>
							Note that hull is defined if and only if the <emph>actual</emph> set
							is a totally ordered set. The data type of the elements itself need
							not be totally ordered. For example, the data type <termref ref="dt-PQ">PQ</termref> is 
							only partially ordered (since only quantities of the
							same kind can be compared), but a <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-PQ">PQ</termref>&gt; may
							still be totally ordered (if it contains only
							comparable quantities.) For example, the convex hull of {4 s, 20 s, 55
							s} is [4 s;55 s]; the convex hull of {"apples"; "oranges"; "bananas"}
							is undefined because the elements have no order relationship among
							them; and the convex hull of {2 m; 4 m; 8 s} is likewise undefined,
							because it is not <emph>totally</emph> ordered (seconds are not
							comparable with meters.)
						</p><graphic source="graphics/datyp2fig11.jpg" alt="Convex Hull of a Totally Ordered Set"/></div3></div2><div2 id="dt-LIST"><anchor id="LIST"/><head>Sequence (LIST) specializes <termref ref="dt-ANY">ANY</termref></head><parameter name="T" type="ANY"/><p><emph role="strong">Definition:</emph>
					A value that contains other discrete (but not necessarily distinct) values in a defined sequence. 
				</p><exhibit role="dtdl" id="dtdl-LIST"><anchor id="dtdl-LIST"/><caption/><pre>
template&lt;ANY T&gt;
type Sequence&lt;T&gt; alias LIST&lt;T&gt; specializes ANY {
             T        head;
             LIST&lt;T&gt;  tail;
             BL       isEmpty;
             BL       notEmpty;
             T        item(INT index);
             BL       contains(T item);
             INT      length;
  literal    ST;
  promotion  LIST&lt;T&gt;  (T x);
};</pre></exhibit><p>
					A sequence may contain NULL values as items.
				</p><div3 id="prop-LIST.head"><head>Head Item : T</head><p><emph role="strong">Definition:</emph>
							The first item in this sequence. The <emph>head</emph> is a definitional
							property for the semantics of the sequence.  
						</p></div3><div3 id="prop-LIST.tail"><head>Tail Sequence : <termref ref="dt-LIST">LIST</termref>&lt;T&gt;</head><p><emph role="strong">Definition:</emph>
							The sequence following the first item in this sequence. The
							<emph>tail</emph> is a definitional property for the semantics of the
							sequence.
						</p></div3><div3 id="prop-LIST.isEmpty"><head>Empty Sequence : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph>
							A predicate that is <emph>true</emph> if this sequence is an empty
							sequence, i.e., if it contains no items.
						</p><p>
							Notice the difference between empty-sequence and NULL: an empty
							sequence is a proper sequence, not a null-value.  
							<!-- FIXME: why not?  It seems I'm having a problem with a not-empty
							list consisting only of a single NULL item and distinguishing that
							from an empty list, it seems like empty list could be declared under
							NULL/OTH. --></p><exhibit role="dtdl"><caption/><pre>
invariant(LIST&lt;T&gt; x)
      where x.isEmpty {
   x.head.isNull;
   x.tail.isNull;
};</pre></exhibit><p>
							Notice that head and tail being NULL is only a necessary condition but
							not sufficient for determining an empty list, since a sequence may
							contain NULL-values as items, this condition can mean that this list
							has only a head item that happens to be NULL.
						</p></div3><div3 id="prop-LIST.notEmpty"><head>Not-Empty Sequence : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph>
							A predicate that is <emph>true</emph> if this sequence is
							not-empty. Negation of <termref ref="prop-LIST.isEmpty">isEmpty</termref>.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(LIST&lt;T&gt; x)
      where x.nonNull {
   x.notEmpty.equal(x.isEmpty.not);
};</pre></exhibit></div3><div3 id="prop-LIST.item"><head>Item by Index : T</head><argument name="index" type="INT"/><p><emph role="strong">Definition:</emph>
							The item at the given sequential position (index) in the sequence. The
							index zero refers to the first element (head) of the sequence.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(LIST&lt;T&gt; list; INT index)
      where list.nonNull.and(index.nonNegative) {
   list.isEmpty.implies(list.item(index).isNull);
   list.notEmpty.and(index.isZero)
       .implies(list.item(index).equal(list.head));
   list.notEmpty.and(index.nonZero)
       .implies(list.item(index).equal(
          list.tail.item(index.predecessor)));
};</pre></exhibit></div3><div3 id="prop-LIST.contains"><head>Contains Item : <termref ref="dt-BL">BL</termref></head><argument name="item" type="T"/><p><emph role="strong">Definition:</emph>
							A predicate that is <emph>true</emph> if this sequence contains the
							given item value.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(LIST&lt;T&gt; list; T item)
      where list.nonNull {
   list.isEmpty.implies(list.contains(item).not);
   list.nonEmpty.and(item.nonNull).implies(list.contains(item).equal(
      list.head.equal(item).or(list.tail.contains(item))));
      list.notEmpty.and(item.isNull).implies(list.contains(item).equal(
         list.head.isNull.or(list.tail.contains(item)));
};</pre></exhibit></div3><div3 id="prop-LIST.length"><head>Length : <termref ref="dt-INT">INT</termref></head><p><emph role="strong">Definition:</emph>
							The number of elements in the sequence. NULL elements are counted as
							regular sequence elements.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(LIST&lt;T&gt; list)
      where x.nonNull {
   list.isEmpty.equal(list.length.isZero);
   list.notEmpty.equal(list.length.equal(
      list.tail.length.successor));
};</pre></exhibit></div3><div3 id="prop-LIST.equal"><head>Equality : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref></head><p>
							Two lists are equal if and only if they are both empty, or if both
							their head and their tail are equal.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(LIST&lt;T&gt; x, y)
      where x.nonNull.and(y.nonNull) {
   x.isEmpty.and(y.isEmpty).implies(x.equal(y));
   x.notEmpty.and(y.notEmpty).and(x.head.nonNull)
      .implies(x.equal(y).equal(
         x.head.equal(y.head).and(x.tail.equal(y.tail))));
   x.notEmpty.and(y.notEmpty).and(x.head.isNull)
             .implies(x.equal(y).equal(
                y.heas.isNull.and(x.tail.equal(y.tail))));
};</pre></exhibit></div3><div3 id="prop-LIST.literal"><head>Literal Form</head><p>
							When the element type T has a literal form, the sequence <emph>LIST</emph>
							has a literal form. List elements
							are enumerated, separated by semicolon, and enclosed in parentheses.
						</p><exhibit role="dtdl"><caption/><pre>
LIST&lt;T&gt;.literal ST {
   LIST&lt;T&gt; : "(" elements ")"        { $.equal($2); }
           | "(" ")"                 { $.isEmpty; };
   LIST&lt;T&gt; elements
           : T ";" elements          { $.head.equal($1);
                                       $.tail.equal($3); }
           | T                       { $.head.equal($1);
                                       $.tail.isEmpty; };
};</pre></exhibit><table id="table-LIST.literal.example"><caption>Examples</caption><thead><tr><th rowspan="1" colspan="1">literal</th><th rowspan="1" colspan="1">meaning</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">(1; 3; 5; 7; 19)</td><td rowspan="1" colspan="1">a sequence of integer numbers or real numbers</td></tr><tr><td rowspan="1" colspan="1">(3; 1; 5; 19; 7)</td><td rowspan="1" colspan="1">a different sequence of integer numbers or real numbers</td></tr><tr><td rowspan="1" colspan="1">(1.2 m; 17.8 m; 2.67 m)</td><td rowspan="1" colspan="1">a sequence of discrete physical quantities</td></tr><tr><td rowspan="1" colspan="1">(apple; orange; banana)</td><td rowspan="1" colspan="1">a sequence of character strings</td></tr></tbody></table><note role="its"><p>
								a character-based ITS <emph>should</emph> choose a different literal
								form for sequences if the Implementation Technology has a more native
								literal form for such collections.
							</p></note></div3><div3 id="prop-LIST.promotionT"><head>Promotion of Item Values to Sequences : <termref ref="dt-LIST">LIST</termref>&lt;T&gt;</head><argument name="x" type="T"/><p>
							A data value of type T can be promoted into a trivial sequence of T with
							that data value as its only item.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(T x) {
   ((LIST&lt;T&gt;)x).head.equal(x);
   ((LIST&lt;T&gt;)x).tail.isEmpty;
};</pre></exhibit></div3><!-- NEW: The Generated Sequence and Sampled Sequence --></div2><div2 id="dt-GLIST"><anchor id="GLIST"/><head>GeneratedSequence (GLIST) specializes <termref ref="dt-LIST">LIST</termref></head><parameter name="T" type="QTY"/><p><emph role="strong">Definition:</emph>
					A periodic or monotone sequence of values generated from a few
					parameters, rather than being enumerated. Used to specify regular
					sampling points for biosignals.
				</p><exhibit role="dtdl"><caption/><pre>
type GeneratedSequence&lt;QTY T&gt; alias GLIST specializes LIST&lt;T&gt; {
   T    head;
   QTY  increment;
   INT  period;
   INT  denominator;
};</pre></exhibit><table id="dt-GLIST-prop-summary"><caption>Property Summary of
      GeneratedSequence</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-GLIST.head">head</termref></td><td>T</td><td>
							The first item in this sequence. The <emph>head</emph> is a definitional
							property for the semantics of the sequence.  
						</td></tr><tr><td><termref ref="prop-GLIST.increment">increment</termref></td><td><termref ref="dt-QTY">QTY</termref></td><td>
						The difference between one value and its previous different value.
						For example, to generate the sequence (1; 4; 7; 10; 13; ...) the
						increment is 3; likewise to generate the sequence (1; 1; 4; 4; 7; 7;
						10; 10; 13; 13; ...) the increment is also 3.
					</td></tr><tr><td><termref ref="prop-GLIST.period">period</termref></td><td><termref ref="dt-INT">INT</termref></td><td>
						If non-NULL, specifies that the sequence alternates, i.e., after this
						many increments, the sequence item values roll over to start from the
						initial sequence item value. For example, the sequence (1; 2; 3; 1; 2;
						3; 1; 2; 3; ...) has period 3; also the sequence (1; 1; 2; 2; 3; 3; 1;
						1; 2; 2; 3; 3; ...) has period 3 too.
					</td></tr><tr><td><termref ref="prop-GLIST.denominator">denominator</termref></td><td><termref ref="dt-INT">INT</termref></td><td>
						The the integer by which the index for the sequence is divided,
						effectively the number of times the sequence generates the same
						sequence item value before incrementing to the next sequence item
						value. For example, to generate the sequence (1; 1; 1; 2; 2; 2; 3; 3;
						3; ...)  the denominator is 3.
					</td></tr></tbody></table><p>
					The item at a certain index in the list is calculated by performing an
					integer division on the index (<emph>i</emph>) with the
					<termref ref="prop-GLIST.denominator">denominator</termref> (<emph>d</emph>) and then take that
					value's remainder with the <termref ref="prop-GLIST.period">period</termref>
					(<emph>p</emph>). Multiply this value with the
					<termref ref="prop-GLIST.increment">increment</termref> (<emph>&#916;x</emph>) and add to the
					<termref ref="prop-GLIST.head">head</termref> (<emph>x</emph><emph role="sub">0</emph>.)
				</p><quote><p><emph>x</emph><emph role="sub"><emph>i</emph></emph>=<emph>x</emph><emph role="sub">0</emph>
						+ <emph>&#916;x</emph>  (<emph>i</emph>/<emph>d</emph>)
						mod <emph>p</emph></p></quote><exhibit role="dtdl"><caption/><pre>
invariant(GLIST&lt;T&gt; list, INT index)
      where list.nonNull.and(index.nonNull) {
   list.period.nonNull.implies(list.item(index).equal(
      list.head.plus(item.dividedBy(list.increment.denominator)
          .remainder(list.period)).times(increment)));
   list.period.isNull.implies(list.item(index).equal(
      list.head.plus(item.dividedBy(list.increment.denominator))
          .times(increment)));
};</pre></exhibit><div3 id="prop-GLIST.head"><head>Head Item : T, inherited from <termref ref="dt-LIST">LIST</termref></head><p>
						This is the start-value of the generated list.
					</p><!-- FIXME: This specification will probably have to be extended to
						 separate the head from the reset point of the sequence or else
						 we won't be able to have a GLIST.tail be a GLIST! --></div3><div3 id="prop-GLIST.increment"><head>Increment : <termref ref="dt-QTY">QTY</termref></head><p><emph role="strong">Definition:</emph>
						The difference between one value and its previous different value.
						For example, to generate the sequence (1; 4; 7; 10; 13; ...) the
						increment is 3; likewise to generate the sequence (1; 1; 4; 4; 7; 7;
						10; 10; 13; 13; ...) the increment is also 3.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(GLIST&lt;T&gt; x) {
   x.increment.dataType.implies(T.diffType);
};</pre></exhibit></div3><div3 id="prop-GLIST.period"><head>Period Step Count : <termref ref="dt-INT">INT</termref></head><p><emph role="strong">Definition:</emph>
						If non-NULL, specifies that the sequence alternates, i.e., after this
						many increments, the sequence item values roll over to start from the
						initial sequence item value. For example, the sequence (1; 2; 3; 1; 2;
						3; 1; 2; 3; ...) has period 3; also the sequence (1; 1; 2; 2; 3; 3; 1;
						1; 2; 2; 3; 3; ...) has period 3 too.
					</p><p>
						The period allows to repeatedly sample the same sample space.  The
						"waveform" of this periodic generator is always a "saw", just like the
						x-function of your oscilloscope.<footnote><p>
								Note the difference to the <termref ref="dt-GTS">GTS</termref>. The <termref ref="dt-GTS">GTS</termref> is
								a generator for a <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt; not for a
								<termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;.  A sequence of discrete
								values from a continuous domain makes not much sense other than in sampling
								applications. The <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;, however,
								can be thought of as a sequence of <termref ref="dt-IVL_TS">IVL&lt;TS&gt;</termref>, which still is different from a
								<termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;.
							</p></footnote></p></div3><div3 id="prop-GLIST.denominator"><head>Denominator : <termref ref="dt-INT">INT</termref></head><p><emph role="strong">Definition:</emph>
						The the integer by which the index for the sequence is divided,
						effectively the number of times the sequence generates the same
						sequence item value before incrementing to the next sequence item
						value. For example, to generate the sequence (1; 1; 1; 2; 2; 2; 3; 3;
						3; ...)  the denominator is 3.
					</p><p>
						The use of the denominator is to allow multiple generated sequences to
						periodically scan a multidimensional space. For example, an (abstract)
						TV screen uses 2 such generators for the columns and rows of
						pixels. For instance, if there are 200 scan lines and 320 raster
						colunmns, the column-generator would have denominator 1 and the
						line-generator would have denominator 320.
					</p></div3><table id="table-GLIST.example"><caption>Examples for Generated Sequences</caption><thead><tr><th rowspan="1" colspan="1">head</th><th rowspan="1" colspan="1">increment</th><th rowspan="1" colspan="1">denominator</th><th rowspan="1" colspan="1">period</th><th rowspan="1" colspan="1">meaning</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">&#8734;</td><td rowspan="1" colspan="1">The identity-sequence where each item is equal to its index.</td></tr><tr><td rowspan="1" colspan="1">198706052000</td><td rowspan="1" colspan="1">2 hour</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">&#8734;</td><td rowspan="1" colspan="1">
								Sequence starting on June 5, 1987 at 7 PM and
								incrementing every two hours: 9 PM, 11 PM, 1 AM (June 6), 3
								AM, 5 AM, and so on.
							</td></tr><tr><td rowspan="1" colspan="1">0 V</td><td rowspan="1" colspan="1">1 mV</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">100</td><td rowspan="1" colspan="1">
								The x-wave of a digital oscillograph scanning between
								0 and 100 mV in 100 steps of 1 mV. The frequency is unknown
								from these data as we do not know how much time elapses
								between each step of the index.
							</td></tr><tr><td rowspan="1" colspan="1">2002072920300</td><td rowspan="1" colspan="1">100 us</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">&#8734;</td><td rowspan="1" colspan="1">
								A timebase from June 29,
								2002 at 8:30 PM with 100 us between each steps of the
								index. If combined with the previous generator as a second
								sampling dimension this would now describe our digital
								oscilloscope's x-timebase as 1 mV per 100 us. At 100 steps
								per period, the period is 10 ms, which is equal to a
								frequency of 100 Hz.
							</td></tr><tr><td rowspan="1" colspan="1">0 V</td><td rowspan="1" colspan="1">1 mV</td><td rowspan="1" colspan="1">100</td><td rowspan="1" colspan="1">100</td><td rowspan="1" colspan="1">
								Combining this generator to the previous two generators
								could describe a three-dimensional sampling space with two
								voltages and time. This generator also steps at 1 mV and has
								100 steps per period, however, it only steps every 100 index
								increments, so, the first voltage generator makes one full
								cycle before this generator is incremented. One can think of
								the two voltages as "rows" and "columns" of a "sampling
								frame". With the previous generator as the timebase, this
								results in a scan of sampling frames of 100 mV  100
								mV with a framerate of 1 Hz.
							</td></tr></tbody></table></div2><div2 id="dt-SLIST"><anchor id="SLIST"/><head>SampledSequence (SLIST) specializes <termref ref="dt-LIST">LIST</termref></head><parameter name="T" type="QTY"/><p><emph role="strong">Definition:</emph>
					A sequence of sampled values scaled and translated from a list of
					integer values.  Used to specify sampled biosignals.
				</p><exhibit role="dtdl"><caption/><pre>
type SampledSequence&lt;QTY T&gt; alias SLIST specializes LIST&lt;T&gt; {
   T          origin;
   QTY        scale;
   LIST&lt;INT&gt;  digits;
};</pre></exhibit><table id="dt-SLIST-prop-summary"><caption>Property Summary of
      SampledSequence</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-SLIST.origin">origin</termref></td><td>T</td><td>
						The origin of the list item value scale, i.e., the physical quantity
						that a zero-digit in the sequence would represent.
					</td></tr><tr><td><termref ref="prop-SLIST.scale">scale</termref></td><td><termref ref="dt-QTY">QTY</termref></td><td>
						A ratio-scale quantity that is factored out of the digit sequence.
					</td></tr><tr><td><termref ref="prop-SLIST.digits">digits</termref></td><td><termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-INT">INT</termref>&gt;</td><td>
						A sequence of raw digits for the sample values. This is typically the
						raw output of an A/D converter.
					</td></tr></tbody></table><p>
					The item at a certain index (<emph>i</emph>) in the list is calculated
					by multiplying the item at the same index in the
					<termref ref="prop-SLIST.digits">digits</termref> sequence
					(<emph>d</emph><emph role="sub"><emph>i</emph></emph>) with the
					<termref ref="prop-SLIST.scale">scale</termref> (<emph>s</emph>)
					and then add that value to the <termref ref="prop-SLIST.origin">origin</termref>
					(<emph>x</emph><emph role="sub"><emph>o</emph></emph>).
				</p><quote><p><emph>x</emph><emph role="sub"><emph>i</emph></emph>=<emph>x</emph><emph role="sub"><emph>o</emph></emph> + <emph>s</emph>
						 <emph>d</emph><emph role="sub"><emph>i</emph></emph></p></quote><exhibit role="dtdl"><caption/><pre>
invariant(SLIST&lt;T&gt; list, INT index)
      where list.nonNull.and(index.nonNegative) {
   list.item(index).equal(
      list.scale.times(digits.item(index))
          .plus(list.origin));
};</pre></exhibit><div3 id="prop-SLIST.origin"><head>Scale Origin : T</head><p><emph role="strong">Definition:</emph>
						The origin of the list item value scale, i.e., the physical quantity
						that a zero-digit in the sequence would represent.
					</p></div3><div3 id="prop-SLIST.scale"><head>Scale Factor : <termref ref="dt-QTY">QTY</termref></head><p><emph role="strong">Definition:</emph>
						A ratio-scale quantity that is factored out of the digit sequence.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(SLIST&lt;T&gt; x) {
   x.scale.dataType.implies(T.diffType);
};</pre></exhibit></div3><div3 id="prop-SLIST.digits"><head>Sampled Digits : <termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-INT">INT</termref>&gt;</head><p><emph role="strong">Definition:</emph>
						A sequence of raw digits for the sample values. This is typically the
						raw output of an A/D converter.
					</p></div3></div2><div2 id="dt-BAG"><anchor id="BAG"/><head>Bag (BAG) specializes <termref ref="dt-ANY">ANY</termref></head><parameter name="T" type="ANY"/><p><emph role="strong">Definition:</emph>
					An unordered collection of values, where each value can be contained
					more than once in the collection.
				</p><exhibit role="dtdl" id="dtdl-BAG"><anchor id="dtdl-BAG"/><caption/><pre>
template&lt;ANY T&gt;
type Bag&lt;T&gt; alias BAG&lt;T&gt; specializes ANY {
              INT     contains(T kind);
              BL      isEmpty;
              BL      notEmpty;
              BAG&lt;T&gt;  plus(BAG&lt;T&gt; x);
              BAG&lt;T&gt;  minus(BAG&lt;T&gt; x);
   promotion  BAG&lt;T&gt;  (T x);
};</pre></exhibit><note role="its"><p>
						A <emph>BAG</emph> can be represented in two ways. Either as a simple enumeration
						of elements, including repeated elements, or as a "compressed bag"
						whereby the content of the <emph>BAG</emph> is listed in pairs of element value and
						number. A histogram showing absolute frequencies is a <emph>BAG</emph> represented
						in compressed form. <emph>BAG</emph> is therefore useful to communicate raw
						statistical data samples.
						</p></note><div3 id="prop-BAG.contains"><head>Contains Item : <termref ref="dt-INT">INT</termref></head><argument name="kind" type="T"/><p><emph role="strong">Definition:</emph>  
							The number of items in this bag with the given item value.
						</p><p>
							This is the primitive semantic property of a <emph>BAG</emph>, on which all
							other properties are defined. 
						</p><exhibit role="dtdl"><caption/><pre>
invariant(BAG&lt;T&gt; bag; T item)
      where bag.nonNull.and(item.nonNull) {
   bag.contains(item).nonNegative;
   bag.isEmpty.equal(bag.contains(item).isZero);
};</pre></exhibit></div3><div3 id="prop-BAG.notEmpty"><head>Not-Empty : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph> 
							A predicate indicating that this <emph>BAG</emph> contains item.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(BAG&lt;T&gt; bag)
      where bag.nonNull {
   bag.notEmpty.equal(exists(T item) {
      bag.contains(item);
      });
};</pre></exhibit></div3><div3 id="prop-BAG.isEmpty"><head>The Empty Bag : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph>          
							A predicate indicating that this <emph>BAG</emph> has no elements (negation of the
							<termref ref="prop-BAG.notEmpty">notEmpty</termref> predicate. The empty <emph>BAG</emph> is a
							proper value, <emph>not</emph> an exceptional (NULL) value.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(BAG&lt;T&gt; bag)
      where bag.nonNull {
   bag.isEmpty.equal(notEmpty.not);
};</pre></exhibit></div3><div3 id="prop-BAG.plus"><head>Addition : <termref ref="dt-BAG">BAG</termref>&lt;T&gt;</head><argument name="x" type="BAG&lt;T&gt;"/><p><emph role="strong">Definition:</emph>          
							A <emph>BAG</emph> that contains all items of the operand <emph>BAG</emph>s, i.e. the number of
							items of each item value are added.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(BAG&lt;T&gt; x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.plus(y).equal(z).equal(
      forall(T e)
            where e.nonNull {
         z.contains(e).equal(x.contains(e)
                      .plus(y.contains(e)));
         });
};</pre></exhibit></div3><div3 id="prop-BAG.minus"><head>Subtraction : <termref ref="dt-BAG">BAG</termref>&lt;T&gt;</head><argument name="x" type="BAG&lt;T&gt;"/><p><emph role="strong">Definition:</emph>          
							A <emph>BAG</emph> that contains all items of this <emph>BAG</emph> (minuend) diminished by the
							items in the other <emph>BAG</emph> (subtrahend). <emph>BAG</emph>s cannot carry deficits. When
							the subtrahend contains more items of one value than the minuend, the
							difference contais zero items of that value.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(BAG&lt;T&gt; x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.minus(y).equal(z).equal(
      forall(T e)
            where e.nonNull {
               exists(INT n)
                  where n.equal(x.contains(e).minus(y.contains(e)) {
         n.nonNegative.equal(z.contains(e));
         n.isNegative.equal(z.contains(e).isZero);
         };
      });
};</pre></exhibit></div3><div3 id="prop-BAG.promotionT"><head>Promotion of Item Values to Bags : <termref ref="dt-BAG">BAG</termref>&lt;T&gt;</head><argument name="x" type="T"/><p>
							A data value of type T can be promoted into a trivial <emph>BAG</emph> of type T
							with that data value as its only item.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(T x) {
   ((BAG&lt;T&gt;)x).contains(x).equal(1);
   forall(T y) {
      ((BAG&lt;T&gt;)x).contains(y)
                 .implies(x.equal(y)) };
};</pre></exhibit></div3></div2><div2 id="dt-IVL"><anchor id="IVL"/><head>Interval (IVL) specializes <termref ref="dt-SET">SET</termref></head><parameter name="T" type="QTY"/><p><emph role="strong">Definition:</emph>
					A set of consecutive values of an ordered base data type.
				</p><p>
					Any ordered type can be the basis of an <emph>IVL</emph>; it does not matter
					whether the base type is discrete or continuous. If the base data type
					is only partially ordered, all elements of the <emph>IVL</emph> must be
					elements of a totally ordered subset of the partially ordered data
					type.
				</p><p>
					For example, <termref ref="dt-PQ">PQ</termref> is considered ordered. However the
					ordering of <termref ref="dt-PQ">PQ</termref>s is only partial; a total order is only
					defined among comparable quantities (quantities of the same physical
					dimension.)  While <emph>IVL</emph>s between 2 and 4 meter exists, there is no
					<emph>IVL</emph> between 2 meters and 4 seconds.
				</p><p><emph>IVL</emph>s are <termref ref="dt-SET">SET</termref>s and have all the properties of
					<termref ref="dt-SET">SET</termref>s. However, union and difference of <termref ref="dt-SET">SET</termref>s
					may not be <termref ref="dt-SET">SET</termref>s, since the elements of these union and
					difference <termref ref="dt-SET">SET</termref>s might not be
					contiguous. Intersections of <termref ref="dt-SET">SET</termref>s are always <termref ref="dt-SET">SET</termref>s.
				</p><exhibit role="dtdl" id="dtdl-IVL"><anchor id="dtdl-IVL"/><caption/><pre>
template&lt;QTY T&gt;
type Interval&lt;T&gt; alias IVL&lt;T&gt; specializes SET&lt;T&gt; {
              T       low;
              BL      lowClosed;
              T       high;
              BL      highClosed;
              QTY     width;
              T       center;
              IVL&lt;T&gt;  hull;
              IVL&lt;T&gt;  hull(IVL&lt;T&gt; x);
   literal    ST;
   promotion  IVL&lt;T&gt;  (T x);
   demotion   T;
};</pre></exhibit><div3 id="prop-IVL.low"><head>Low Boundary : T</head><p><emph role="strong">Definition:</emph>
							This is the low limit.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(IVL&lt;T&gt; x; T e)
      where x.nonNull.and(x.contains(e)) {
   x.low.lessOrEqual(e);
};</pre></exhibit></div3><div3 id="prop-IVL.high"><head>High Boundary : T</head><p><emph role="strong">Definition:</emph>
							This is the high limit.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(IVL&lt;T&gt; x; T e)
      where x.nonNull.and(x.contains(e)) {
   e.lessOrEqual(x.high);
};</pre></exhibit></div3><div3 id="prop-IVL.width"><head>Width : <termref ref="dt-QTY">QTY</termref></head><p><emph role="strong">Definition:</emph>
							The difference between <termref ref="prop-IVL.high">high</termref> and <termref ref="prop-IVL.low">low</termref>
							boundary. The purpose of distinguishing <emph>width</emph> is to handle all cases of incomplete
							information symmetrically. In any <termref ref="dt-SET">SET</termref> representation only two of
							the three properties <termref ref="prop-IVL.high">high</termref>, <termref ref="prop-IVL.low">low</termref>,
							and <emph>width</emph> need to be stated and the third can be derived.
						</p><p>
							When both boundaries are known, <emph>width</emph> can be derived as
							<termref ref="prop-IVL.high">high</termref> minus <termref ref="prop-IVL.low">low</termref>.
							When one boundary and <emph>width</emph> is known, the other boundary is
							also known. When no boundary is known, <emph>width</emph> may still be
							known. For example, one knows that an activity takes about 30 minutes,
							but one may not yet know when that activity is started.
						</p><p>
							Note that the data type of <emph>width</emph> is not always the same as for the
							boundaries. For ratio scale quantities (<termref ref="dt-REAL">REAL</termref>,
							<termref ref="dt-PQ">PQ</termref>, <termref ref="dt-MO">MO</termref>) it is the same. For
							difference scale quantities (e.g., <termref ref="dt-TS">TS</termref>) is
							the data type of the difference (e.g., <termref ref="dt-PQ">PQ</termref> in
							the dimension of time for <termref ref="dt-TS">TS</termref>). For discrete
							elements (<termref ref="dt-INT">INT</termref>) the width may be a
							<termref ref="dt-REAL">REAL</termref> indicating the number of elements in
							the interval divided by 2.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(IVL&lt;T&gt; x) {
   x.low.lessOrEqual(x.high);
   x.width.equal(x.high.minus(x.low));
};

invariant(IVL&lt;T&gt; x) {
   x.width.dataType.implies(T.diffType);
};</pre></exhibit></div3><div3 id="prop-IVL.center"><head>Central Value : T</head><p><emph role="strong">Definition:</emph>
							The arithmetic mean of the <emph>IVL</emph>
							(<termref ref="prop-IVL.low">low</termref> plus <termref ref="prop-IVL.high">high</termref> divided by 2). The
							purpose of distinguishing <emph>center</emph> as a semantic property is for
							conversions of <emph>IVL</emph>s to and from point values.
						</p><p>
							Note that <emph>center</emph> doesn't always exist for every <emph>IVL</emph>.
							Notably <emph>IVL</emph>s that are infinite on one side do not have
							<emph>center</emph>. Also <emph>IVL</emph>s of discrete base types with an
							even number of elements do not have a <emph>center</emph>. If an <emph>IVL</emph>
							is unknown on one (or both) boundaries, <emph>center</emph> can still
							be asserted. In fact, the main use case for <emph>center</emph> is
							to be asserted when no boundary is known.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(IVL&lt;T&gt; x)
      where x.low.nonNull.and(x.high.nonNull) {
   x.center.equal(x.low.plus(x.width.times(0.5))));
};

invariant(IVL&lt;T&gt; x)
      where x.low.isNull.or(x.high.isNull) {
   x.center.notApplicable;
};</pre></exhibit></div3><div3 id="prop-IVL.lowClosed"><head>Low Boundary Closed : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph>
							Specifies whether <termref ref="prop-IVL.low">low</termref> is included in the <emph>IVL</emph>
							(is closed) or excluded from the <emph>IVL</emph> (is open).
						</p><exhibit role="dtdl"><caption/><pre>
invariant(IVL&lt;T&gt; x)
      where x.nonNull {
   x.low.nonNull.implies(x.lowClosed.equal(x.contains(x.low)));
   x.low.isNull.implies(x.lowClosed.not);
};</pre></exhibit></div3><div3 id="prop-IVL.highClosed"><head>High Boundary Closed : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph>
							Specifies whether <termref ref="prop-IVL.high">high</termref> is included in the <emph>IVL</emph>
							(is closed) or excluded from the <emph>IVL</emph> (is open).
						</p><exhibit role="dtdl"><caption/><pre>
invariant(IVL&lt;T&gt; x)
      where x.nonNull {
   x.high.nonNull.implies(x.highClosed.equal(x.contains(x.high)));
   x.high.isNull.implies(x.highClosed.not);
};</pre></exhibit></div3><div3 id="prop-IVL.literal"><head>Literal Form</head><p>
							The literal form for <emph>IVL</emph> is defined such that it is
							as intuitive to humans as possible. Five different forms are
							defined:<footnote><p>
									The presence of so many options deserves explanation. In principle,
									the interval form together with the width-only form would be
									sufficient. However, the interval form is felt alien to many in the
									field of medical informatics. One important purpose of the literal
									forms is to eradicate non-compliance through making compliance easy,
									without compromising on the soundness of the concepts.
								</p><p>
									Furthermore, the different literal forms all have strength and
									weaknesses. The interval and center-width forms' strength is that they
									are most exact, showing closed and open boundaries. The interval
									form's weakness, however, is that infinite boundaries require special
									symbols for infinities, not necessary in the "comparator" form. The
									center-width form cannot specify intervals with an infinite boundary
									at all. The "comparator" form, however, can only represent
									single-bounded intervals (i.e., where the other boundary is infinite
									or unknown.)  The dash form, while being the weakest of all, is the
									most intuitive form for double bounded intervals.
								</p></footnote></p><list role="ordered"><item>
								the interval form using square brackets, e.g., "[3.5; 5.5[";
							</item><item>
								the dash-form, e.g., "3.5-5.5";
							</item><item>
								the "comparator" form, using relational operator symbols, e.g., "&lt;5.5";
							</item><item>
								the center-width form, e.g., "4.5[2.0[".
							</item><item>
								the width-only form using square brackets, e.g., "[2.0[".
							</item></list><exhibit role="dtdl"><caption/><pre>
IVL&lt;T&gt;.literal ST {
   IVL&lt;T&gt; range : interval                { $.equal($1); }
                | dash                    { $.equal($1); }
                | comparator              { $.equal($1); }
                | center_width            { $.equal($1); }
                | width                   { $.equal($1); };

   IVL&lt;T&gt; interval
                : open T ";" T close;     { $.low.equal($2);
                                            $.high.equal($4);
                                            $.lowClosed.equal($1);
                                            $.highClosed.equal($5); };
   BL open      : "["                     { $.equal(true); }
                | "]"                     { $.equal(false); };
   BL close     : "]"                     { $.equal(true); }
                | "["                     { $.equal(false); };
   IVL&lt;T&gt; width
                : open T.diffType close   { $.width.equal($2);
                                            $.lowClosed.equal($1);
                                            $.highClosed.equal($3); };
   IVL&lt;T&gt; center_width
                : T width                 { $.center.equal($1);
                                            $.width.equal($2.width);
                                            $.lowClosed.equal($2.lowClosed);
                                            $.highClosed.equal($2.highClosed); };
   IVL&lt;T&gt; dash  : T "-" T;                { $.low.equal($2);
                                            $.high.equal($4);
                                            $.lowClosed.equal(true);
                                            $.highClosed.equal(true); };
   IVL&lt;TS&gt; comparator
                : "&lt;"  T                  { $.high.equal(T);
                                            $.high.closed(false);
                                            $.low.negativelyInfinite; }
                | "&gt;"  T                  { $.low.equal(T);
                                            $.low.closed(false);
                                            $.high.positivelyInfinite; }
                | "&lt;=" T                  { $.high.equal(T);
                                            $.high.closed(true);
                                            $.low.negativelyInfinite; }
                | "&gt;=" T                  { $.low.equal(T);
                                            $.low.closed(true);
                                            $.high.positivelyInfinite; };
};</pre></exhibit><!-- FIXME!!! &IVL-literal-examples; --></div3><div3 id="prop-IVL.promotionT"><head>Promotion of Element Values to Intervals : <termref ref="dt-IVL">IVL</termref>&lt;T&gt;</head><argument name="x" type="T"/><p>
							A quantity of type T can be promoted into a trivial <emph>IVL</emph>
							where <termref ref="prop-IVL.low">low</termref> and <termref ref="prop-IVL.high">high</termref>
							are equal and boundaries closed.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(T x) {
   ((IVL&lt;T&gt;)x).low.equal(x);
   ((IVL&lt;T&gt;)x).high.equal(x);
   ((IVL&lt;T&gt;)x).highClosed;
   ((IVL&lt;T&gt;)x).lowClosed;
};</pre></exhibit></div3><div3 id="prop-IVL.demotionT"><head>Demotion of Intervals to a Representative Element Value : T</head><p>
							An <emph>IVL</emph> can be demoted to a simple quantity of type T that is
							representative for the whole <emph>IVL</emph>. If both boundaries are finite,
							this is the <termref ref="prop-IVL.center">center</termref>. If one boundary is
							infinite, the representative value is the other boundary. If both
							boundaries are infinite, the conversion to a point value is not
							applicable.
							</p><exhibit role="dtdl"><caption/><pre>
invariant(IVL&lt;T&gt; x)
      where x.nonNull {
   x.low.nonNull.and(x.high.nonNull).implies(((T)x).equal(x.center));
   x.high.nonNull.and(x.low.isNull).implies(((T)x).equal(x.high));
   x.low.nonNull.and(x.high.isNull).implies(((T)x).equal(x.low));
   x.low.isNull.and(x.high.isNull).implies(((T)x).notApplicable);
};</pre></exhibit></div3><div3 id="prop-IVL.hull"><head>Convex Hull : <termref ref="dt-IVL">IVL</termref>&lt;T&gt;, inherited from <termref ref="dt-SET">SET</termref></head><p><emph role="strong">Definition:</emph>
							A convex hull or "interval hull" of two <emph>IVL</emph>s is the least
							<emph>IVL</emph> that is a superset of its operands.
							<!-- pvb: 20050811: forward ptr is bad form --><!-- This concept will play an
							important role later on. --></p><graphic source="graphics/datyp2fig12.jpg" alt="Convex Hull of two Intervals"/><exhibit role="dtdl"><caption/><pre>
invariant(IVL&lt;T&gt; h, IVL&lt;T&gt; i, j)
      where h.equal(i.hull(j)) {
   i.low.lessOrEqual(j.low).implies(h.low.equal(i.low));
   j.low.lessOrEqual(i.low).implies(h.low.equal(j.low));
   i.high.lessOrEqual(j.high).implies(h.high.equal(j.high));
   j.high.lessOrEqual(i.high).implies(h.high.equal(i.high));
};</pre></exhibit></div3></div2><div2 id="dt-IVL_PQ"><anchor id="IVL&lt;PQ&gt;"/><head>Interval of Physical Quantities (IVL&lt;PQ&gt;) specializes <termref ref="dt-IVL">IVL</termref></head><p><emph role="strong">Definition:</emph>
					A set of consecutive values of physical quantities.
				</p><p>
					An interval of physical quantities is constructed from the generic
					interval type. However, recognizing that the unit can be factored from
					the boundaries, we add additional semantics and a separate literal
					form. The additional view of an interval of physical quantities is an
					interval of real numbers with one unit.
				</p><exhibit role="dtdl" id="dtdl-IVL_PQ"><anchor id="dtdl-IVL_PQ"/><caption/><pre>
type Interval&lt;PQ&gt; alias IVL&lt;PQ&gt; {
   IVL&lt;REAL&gt; value;
   CS  unit;
};</pre></exhibit><p>
					The unit applies to both low and high boundary.
				</p><exhibit role="dtdl"><caption/><pre>
invariant(IVL&lt;PQ&gt; x)
      where x.nonNull {
   x.value.nonNull;
   x.low.value.equal(x.value.low);
   x.low.unit.equal(x.unit);
   x.lowClosed.equal(x.value.lowClosed);
   x.high.value.equal(x.value.high);
   x.high.unit.equal(x.unit);
   x.highClosed.equal(x.value.highClosed);
};</pre></exhibit><p>
					The special literal form is simply an interval of real numbers a space
					and the unit.
				</p><exhibit role="dtdl"><caption/><pre>
IVL&lt;PQ&gt;.literal ST {
   IVL&lt;PQ&gt;  : IVL&lt;REAL&gt; " " unit    { $.value($1);
                                      $.unit.equal($3); }
            | IVL&lt;REAL&gt;             { $.equal($1); };
   CS unit  : ST                    { $.value.equal($1);
                                      $.codeSystem(2.16.840.1.113883.3.2); };
};</pre></exhibit><p>
					For example: "[0;5] mmol/L" or "&lt;20 mg/dL" are valid literal forms
					of intervals of physical quantities. The generic interval form, e.g.,
					"[50 nm; 2 m]" is also allowed.
				</p></div2><div2 id="dt-IVL_TS"><anchor id="IVL&lt;TS&gt;"/><head>Interval of Point in Time (IVL&lt;TS&gt;) specializes <termref ref="dt-IVL">IVL</termref></head><p><emph role="strong">Definition:</emph>
					A set of consecutive values of time-stamps.
				</p><p>
					The generic interval data type defines the interval of points in time
					too. However, there are some special considerations about literal
					representations and conversions of intervals of point in time, which
					are specified in this section.
				</p><exhibit role="dtdl" id="dtdl-IVL_TS"><anchor id="dtdl-IVL_TS"/><caption/><pre>
type Interval&lt;TS&gt; alias IVL&lt;TS&gt; {
   literal    ST;
   promotion  IVL&lt;TS&gt; (TS x);
};</pre></exhibit><div3 id="prop-IVL_TS.promotionTS"><head>Promotion of Points in Time Values to Intervals : <termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;, inherited from <termref ref="dt-IVL">IVL</termref></head><argument name="x" type="TS"/><p>
						A <termref ref="dt-TS">TS</termref> can be promoted to an <termref ref="dt-IVL_TS">IVL&lt;TS&gt;</termref>
						whereby the low boundary is
						the <termref ref="dt-TS">TS</termref> value itself, and the width is inferred from
						the precision of the <termref ref="dt-TS">TS</termref> and the duration of the
						least significant calendar period specified. The high boundary is
						open. For example, the <termref ref="dt-TS">TS</termref> literal "200009" is
						converted to an <termref ref="dt-IVL_TS">IVL&lt;TS&gt;</termref> with low
						boundary 200009 and width 30 days, which is the interval
						"[200009;200010[".
					</p></div3><div3 id="prop-IVL_TS.literal"><head>Literal Form</head><p>
						The literal form for interval of point in time is exceptional.
					</p><list role="unordered"><item>
							The "dash form" is not allowed for intervals of point in time
						</item><item>
							A "hull form" is defined instead
						</item></list><p>
						In order to avoid syntactic conflicts with the timezone and slightly
						different usage profiles of the ISO 8601 that occur on some ITS
						platforms, <emph role="strong">the dash form of the interval is not
						permitted for</emph><termref ref="dt-IVL_TS">IVL&lt;TS&gt;</termref>. The
						interval-form using square brackets is preferred.
					</p><p>
						Example: May 12, 1987 from 8 to 9:30 PM is 
						"<code>[198705122000;198705122130]</code>".
					</p><note><p>
							The precision of a stated interval boundary is irrelevant for the
							interval. One might wrongly assume that the interval
							"[19870901;19870930]" stands for the entire September 1987 until end
							of the day of September 30. However, this is not so! The proper way to
							denote an entire calendar cycle (e.g., hour, day, month, year, etc.)
							in the interval notation with is to use an open high boundary. For
							example, all of September 1987 is denoted as
							"[198709;198710[".<footnote><p>
									This statement seems to directly contradict the ruling about the
									promotion of <termref ref="dt-TS">TS</termref> to <termref ref="dt-IVL_TS">IVL&lt;TS&gt;</termref>.
									However, there is no contradiction. The
									precision of a boundary does not have any relevance, but the precision
									of a simple timestamp (not as an interval boundary) is relevant, when that
									timestamp is promoted to an interval.
								</p></footnote></p></note><p>
						The "hull-form" of the literal is defined as the convex hull (see
						<termref ref="prop-IVL.hull">IVL.hull</termref>) of interval-promotions from two time
						stamps.
					</p><exhibit role="dtdl"><caption/><pre>
   IVL&lt;TS&gt; hull : TS ".." TS     { $.equal(((IVL&lt;TS&gt;)$1)
                                    .hull((IVL&lt;TS&gt;)$3));
};</pre></exhibit><p>
						For example, "<code>19870901..19870930</code>" is a valid literal
						using the hull form. The value is equivalent to the interval form
						"<code>[19870901;19871001[</code>".<footnote><p>
								The hull form may appear superfluous for the simple interval all by
								itself. However, the hull form will become important for the periodic
								interval notation as it shortens the notation and (perhaps arguably)
								makes the notation of more complex timing structures more intuitive.
							</p></footnote></p><p>
						The hull-form further allows an abbreviation, where the higher
						timestamp literal does not need to repeat digits on the left that are
						the same as for the lower timestamp literal. The two timestamps are
						right-aligned and the digits to the left copied from the lower to the
						higher timestamp literal. This is a simple string operation and is not
						formally defined here.
					</p><p>
						Example: May 12, 1987 to May, 23, 1987 is
						"<code>19870512..23</code>". However, note that May 12, 1987 to June
						2, 1987 is "<code>19870512..0602</code>", and not
						"<code>20000512..02</code>".
					</p></div3></div2></div1>
			<div1 id="datyp2gentex"  ballotStatus="NormativeStandard"><head>Generic Type Extensions</head><p>
				Generic type extensions are generic types with one parameter type, and
				that extend (specialize) their parameter type. In the formal data type
				definition language, generic type extensions follow the pattern:
				<emph role="strong">template</emph>&lt;ANY T&gt; <emph role="strong">type</emph><emph>GenericTypeExtensionName</emph><emph role="strong">specializes</emph> T
				{ ... }; These generic type extensions inherit most properties of their
				base type and add some specific	feature to it. The generic type extension
				is a specialization of the base type, thus a value of the extension data
				type can be used instead of its base data type.
			</p><note role="its"><p>
					Values of extended types can be substituted for their base
					type. However, an ITS may make some constraints as to what extensions
					to accommodate. Particularly, extensions need not be defined for those
					components carrying the values of data value properties. Thus, while
					any data value can be annotated outside the data type specification,
					and ITS may not provide for a way to annotate the value of a data
					value property.
				</p><p><emph role="strong">At this time HL7 does not permit use of generic
					type extensions, except where explicitly enabled (in this or another
					HL7 specification) for such use cases where this advanced
					functionality is important. In these cases, instances of these generic
					type extensions must be specifically and explicitly reflected in the
					HL7 RIM, MIM, RMIM and HMD (as applicable), as a result of balloted
					Technical Committee content.</emph><footnote><p>
							This specification
							imposes a self-restraint upon itself to allow existing systems a
							graceful transition. However, the formal specification keeps the
							generic type extensions as substitutable for their base types. This
							self-restraint may be omitted in the future. New implementations are
							advised to accommodate some generalizable support for these generic
							data type extensions.
						</p></footnote></p></note><div2 id="dt-HXIT"><anchor id="HXIT"/><head>History Item (HXIT) specializes T</head><parameter name="T" type="ANY"/><p><emph role="strong">Definition:</emph>
					A generic data type extension that tags a time range to any data value
					of any data type.  The time range is the time in which the information
					represented by the value is (was) valid.
				</p><p>
					If the base type T does not possess a validTime property, the
					<termref ref="dt-HXIT">HXIT</termref> adds that property to the base type. If, however,
					the base type T does have a valid time property (currently only <termref ref="dt-EN">EN</termref>),
					that property is mapped to the valid time property of the
					<termref ref="dt-HXIT">HXIT</termref><footnote>.
						<p>
							Note that data types are specifications of abstract properties of
							values. This specification does not mandate how these values are
							represented in an ITS or implemented in an application. Specifically,
							it does not mandate how the represented components are named or
							positioned. In addition, the semantic generalization hierarchy may be
							different from a class hierarchy chosen for implementation (if the
							implementation technology has inheritance.)  Keep the distinction
							between a type (interface) and an implementation (concrete data
							structure, class) in mind. The ITS must contain a mapping of ITS
							defined features of any data type to the semantic properties defined
							here.
						</p></footnote></p><exhibit role="dtdl" id="dtdl-HXIT"><anchor id="dtdl-HXIT"/><caption/><pre>
template&lt;ANY T&gt;
type HistoryItem&lt;T&gt; alias HXIT&lt;T&gt; specializes T {
   IVL&lt;TS&gt; validTime;
};</pre></exhibit><div3 id="prop-HXIT.validTime"><head>Valid Time : <termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;</head><p><emph role="strong">Definition:</emph>
						The time interval during which the given information was, is, or is
						expected to be valid. The interval can be open or closed infinite or
						undefined on either side.
					</p></div3></div2><div2 id="dt-HIST"><anchor id="HIST"/><head>History (HIST) specializes <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-HXIT">HXIT</termref>&gt;</head><parameter name="T" type="ANY"/><p><emph role="strong">Definition:</emph>
					A set of data values that have a valid-time property and thus
					conform to the <termref ref="dt-HXIT">HXIT</termref> type. The history information is
					not limited to the past; expected future values can also appear.
				</p><p>
					The intent of the <emph>HIST</emph> data type is to capture the true historical
					(and future) values of an item, rather than the audit trail of
					values any given system has held for the item.
				</p><exhibit role="dtdl" id="dtdl-HIST"><anchor id="dtdl-HIST"/><caption/><pre>
template&lt;ANY T&gt;
type History&lt;T&gt; alias HIST&lt;T&gt; specializes SET&lt;HXIT&lt;T&gt;&gt; {
            HXIT&lt;T&gt;  earliest;
            HIST     exceptEarliest;
            HXIT&lt;T&gt;  latest;
            HIST     exceptLatest;
  demotion  HXIT&lt;T&gt;;
};</pre></exhibit><p>
						The semantics does not principally forbid the time intervals to
						overlap. However, if two history items have the same
						<termref ref="prop-IVL.low">IVL.low</termref> and <termref ref="prop-IVL.high">IVL.high</termref>
						boundaries in the valid time interval, it is undefined which one is
						considered the earliest (latest).
					</p><exhibit role="dtdl"><caption/><pre>
invariant(HIST x)
      where x.nonNull {
   x.notEmpty;
   ((T)x).equal(x.latest);
};</pre></exhibit><div3 id="prop-HIST.earliest"><head>Earliest Item : <termref ref="dt-HXIT">HXIT</termref>&lt;T&gt;</head><p><emph role="strong">Definition:</emph>
							The item in the set whose <termref ref="prop-IVL.low">IVL.low</termref> boundary
							(validity start	time) is less than or equal to (i.e. before)
							that of any other history item in the set.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(HIST x; HXIT&lt;T&gt; e)
      where x.contains(e) {
   x.earliest.validTime.low.lessOrEqual(e.validTime.low);
};</pre></exhibit></div3><div3 id="prop-HIST.latest"><head>Latest Item : <termref ref="dt-HXIT">HXIT</termref>&lt;T&gt;</head><p><emph role="strong">Definition:</emph>
							The item in the set whose <termref ref="prop-IVL.high">IVL.high</termref> boundary (validity end
							time) is greater than or equal to (i.e. after) that of any other history item
							in the set.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(HIST x; HXIT&lt;T&gt; e)
      where x.contains(e) {
   x.latest.validTime.high.greaterOrEqual(e.validTime.high);
};</pre></exhibit></div3><div3 id="prop-HIST.exceptEarliest"><head>Except Earliest Item : <termref ref="dt-HIST">HIST</termref>&lt;T&gt;</head><p><emph role="strong">Definition:</emph>	  
							The derived history that has the earliest item excluded.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(HIST x)
      where x.nonNull {
   x.exceptEarliest.equal(x.except(x.earliest));
};</pre></exhibit></div3><div3 id="prop-HIST.exceptLatest"><head>Except Latest Item : <termref ref="dt-HIST">HIST</termref>&lt;T&gt;</head><p><emph role="strong">Definition:</emph>	  
							The derived history that has the latest item excluded.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(HIST x)
      where x.nonNull {
   x.exceptLatest.equal(x.except(x.latest));
};</pre></exhibit></div3><div3 id="prop-HIST.demotionHXIT"><head>Demotion of a History to a Single History Item : <termref ref="dt-HXIT">HXIT</termref>&lt;T&gt;</head><p>
							A type conversion between an entire history <termref ref="dt-HIST">HIST</termref>
							and a single history item <termref ref="dt-HIST">HIST</termref>. This conversion
							takes the latest data from the history.
						</p><p>
							The purpose of this conversion is to allow an information producer to
							produce a history of any value instead of sending just one value. An
							information-consumer, who does not expect a history but a simple
							value, will convert the history to the latest value.
						</p><p>
							Note, from the definition of <termref ref="dt-HXIT">HXIT</termref>, that
							<termref ref="dt-HXIT">HXIT</termref> semantically specializes T. This means, that the
							information-consumer expecting a T but given an <termref ref="dt-HXIT">HXIT</termref>
							will not recognize any difference (substitutability of
							specializations.)
						</p></div3></div2><div2 id="dt-UVP"><anchor id="UVP"/><head>Uncertain Value - Probabilistic (UVP) specializes T</head><parameter name="T" type="ANY"/><p><emph role="strong">Definition:</emph>
					A generic data type extension used to specify a probability expressing
					the information producer's belief that the given value holds.
				</p><p>
					How the probability number was arrived at is outside the scope of this
					specification.
				</p><p>
					Probabilities are subjective and (as any data value) must be
					interpreted in their individual context, for example, when new
					information is found the probability might change. Thus, for any
					message (document, or other information representation) the
					information &#8212; and particularly the probabilities &#8212; reflect
					what the information producer believed was appropriate for the purpose
					and at the time the message (document) was created.
				</p><p>
					For example, at the beginning of the 2000 baseball season (May), the
					Las Vegas odds makers may have given the New York Yankees a
					probability of 1 in 10 (0.100) of winning the World Series. At the
					time of this writing, the Yankees and Mets have won their respective
					pennants, but the World Series has yet to begin. The probability of
					the Yankees winning the World Series is obviously significantly
					greater at this point in time, perhaps 6 in 10 (0.600). The context,
					and in particular the time of year, made all the difference in the
					world.
				</p><p>
					Since probabilities are subjective measures of belief, they can be
					stated without being "correct" or "incorrect" per se, let alone
					"precise" or "imprecise". Notably, one does not have to conduct
					experiments to measure a frequency of some outcome in order to specify
					a probability. In fact, whenever statements about individual people or
					events are made, it is not possible to confirm such probabilities with
					"frequentists" experiments.
				</p><p>
					Returning to our example, the Las Vegas odds makers can not insist on
					the Yankees and Mets playing 1000 trial games prior to the Series;
					even if they could, they would not have the fervor of the real Series
					and therefore not be accurate. Instead, the odds makers must derive
					the probability from past history, player statistics, injuries, etc.
				</p><exhibit role="dtdl" id="dtdl-UVP"><anchor id="dtdl-UVP"/><caption/><pre>
template&lt;ANY T&gt;
type UncertainValueProbabilistic&lt;T&gt; alias UVP&lt;T&gt; specializes T {
   REAL  probability;
};</pre></exhibit><p>
					The type T is not formally constrained. In theory, discrete
					probabilities can only be stated for discrete data values. Thus,
					generally <emph>UVP</emph> should not be used with <termref ref="dt-REAL">REAL</termref>,
					<termref ref="dt-PQ">PQ</termref>, or <termref ref="dt-MO">MO</termref> values. 
				</p><div3 id="prop-UVP.probability"><head>Probability : <termref ref="dt-REAL">REAL</termref></head><p><emph role="strong">Definition:</emph>
							The probability assigned to the value, a decimal number between 0
							(very uncertain) and 1 (certain), inclusive.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(UVP&lt;T&gt; x)
      where x.nonNull.and(x.probability.nonNull) {
   ((IVL&lt;REAL&gt;)[0;1]).contains(x.probability);
};</pre></exhibit><p>
							There is no "default probability" that one can assume when the
							probability is unstated. Therefore, it is impossible to make any
							semantic difference between an <emph>UVP</emph> without probability and
							a simple T. <emph>UVP</emph> does not mean "uncertain", and a simple T
							does not mean "certain". In fact, the probability of the <emph>UVP</emph>
							could be 0.999 or 1, which is quite certain, where a simple T value
							could be a very vague guess.
						</p></div3></div2><div2 id="dt-NPPD"><anchor id="NPPD"/><head>Non-Parametric Probability Distribution (NPPD) specializes <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-UVP">UVP</termref>&gt;</head><p><emph role="strong">Definition:</emph>
					A set of <termref ref="dt-UVP">UVP</termref> with probabilities (also known as
					a histogram.) All the elements in the set are considered alternatives
					and are rated each with its probability expressing the belief (or
					frequency) that each given value holds.
				</p><p>
					The purpose of <emph>NPPD</emph> is chiefly
					to support statistical data reporting as it occurs in measurements
					taken from many subjects and consolidated in a histogram. This occurs
					in epidemiology, veterinary medicine, laboratory medicine, but also in
					cost controlling and business process engineering.
				</p><p>
					Semantically, the information of a stated value exists in contrast to
					the complement set of unstated possible values. Thus, semantically, an
					<emph>NPPD</emph> contains <emph>all</emph>
					possible values and assigns probabilities to each of them.
				</p><p>
					The easiest way to visualize this is a bar chart as shown in
				</p><graphic source="graphics/DT-NPPD-ex1.gif" alt="Example of a Histogram"/><p>
					This example illustrates the probability of selected major league
					baseball teams winning the World Series (prior to the season
					start). Each team is mutually exclusive, and were we to include all of
					the teams, the sum of the probabilities would equal 1 (i.e., it is
					certain that one of the teams will win).
				</p><note role="its"><p>
						Even though semantically <emph>NPPD</emph> assigns probabilities to all
						possible values, not all values need to be represented
						explicitly. Those possible values that are not mentioned
						will have the remaining probability distributed equally over
						all unmentioned values. For example, if the value set is {A; B; C; D}
						but the <emph>NPPD</emph> value states just {(B; 0.5); (C; 0.25)} then the
						remaining probability is 1 - 0.75 = 0.25, which is distributed evenly over
						the complement set: {(A; 0.125); (D; 0.125)}. Semantically, the <emph>NPPD</emph>
						is the union of the stated probability distribution and the unstated
						complement with the remaining probability distributed evenly.
					</p></note><exhibit role="dtdl" id="dtdl-NPPD"><anchor id="dtdl-NPPD"/><caption/><pre>
template&lt;ANY T&gt;
type NonParametricProbabilityDistribution&lt;T&gt; alias NPPD&lt;T&gt;
      specializes SET&lt;UVP&lt;T&gt;&gt; {
   SET&lt;UVP&lt;T&gt;&gt; mostLikely(INT n);
};</pre></exhibit><p>
					Just as with <termref ref="dt-UVP">UVP</termref>, the type T is not formally
					constrained, even though there are reasonable and unreasonable
					uses. Typically one would use <emph>NPPD</emph> for unordered types, if
					only a "small" set of possible values is assigned explicit
					probabilities, or if the probability distribution cannot (or should
					not) be approximated with parametric methods. For other cases, one may
					prefer <termref ref="dt-PPD">PPD</termref>.
				</p><div3 id="prop-NPPD"><head>Most Likely : <termref ref="dt-UVP">UVP</termref></head><exhibit role="dtdl"><caption/><pre>
invariant(NPPD&lt;T&gt; x)
      where x.nonNull {
   x.notEmpty;
   x.contains(x.mostLikely(n));
   x.mostLikely(n).
   forall(UVP&lt;T&gt; d, e; SET&lt;UVP&lt;T&gt;&gt; m; INT n)
         where x.contains(d).and(m.equal(x.mostLikely(n)))
                .and(m.contains(e)) {
      e.greaterOrEqual(d).or(m.contains(d));
      };
};</pre></exhibit></div3></div2></div1>
<div1 id="datyp2timspec"  ballotStatus="NormativeStandard"><head>Timing Specification</head><graphic source="graphics/dtUML-Timing.gif" alt="Overview of Timing Specification Data Types"/><p>
				The timing specification suite of data types is used to specify the
				complex timing of events and actions such as those that occur in order
				management and scheduling systems. It also supports the cyclical
				validity patterns that may exist for certain kinds of information,
				such as phone numbers (evening, daytime), office hours, and addresses
				of so called "snowbirds" (i.e. people who choose to reside closer to
				the equator during winter and farther from the equator during summer.)
			</p><p>
				The timing specification data types include point in time (<termref ref="dt-TS">TS</termref>)
				and the interval of time (<termref ref="dt-IVL_TS">IVL&lt;TS&gt;</termref>)
				and add types that are specifically suited to repeated
				schedules. These additional types include <termref ref="dt-PIVL">PIVL</termref>, <termref ref="dt-EIVL">EIVL</termref>,
				and finally <termref ref="dt-GTS">GTS</termref> type
				itself. All these timing types describe the time distribution of
				repeating states or events.
			</p><div2 id="dt-PIVL"><anchor id="PIVL"/><head>Periodic Interval of Time (PIVL) specializes <termref ref="dt-SET">SET</termref></head><parameter name="T" type="TS"/><p><emph role="strong">Definition:</emph>
					An interval of time that recurs periodically. <emph>PIVL</emph> has
					two properties, <termref ref="prop-PIVL.phase">phase</termref> and <termref ref="prop-PIVL.period">period</termref>.
					<termref ref="prop-PIVL.phase">phase</termref> specifies the "interval
					prototype" that is repeated every <termref ref="prop-PIVL-period">.</termref>.
				</p><table id="dt-PIVL-prop-summary"><caption>Property Summary of
      Periodic Interval of Time</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-PIVL.phase">phase</termref></td><td><termref ref="dt-IVL">IVL</termref>&lt;T&gt;</td><td>
							A prototype of the repeating interval, specifying the duration of
							each occurrence and anchors the <emph>PIVL</emph> sequence at a
							certain point in time.
						</td></tr><tr><td><termref ref="prop-PIVL.period">period</termref></td><td><termref ref="dt-T.diff">T.diff</termref></td><td>
							A time duration specifying as a reciprocal measure of the frequency at
							which the <emph>PIVL</emph> repeats.
						</td></tr><tr><td><termref ref="prop-PIVL.alignment">alignment</termref></td><td><termref ref="dt-CS">CS</termref></td><td>
							Specifies if and how the repetitions are aligned to the cycles 
							of the underlying calendar (e.g., to distinguish every 30 days
							from "the 5th of every month".) A non-aligned <emph>PIVL</emph> recurs
							independently from the calendar. An aligned <emph>PIVL</emph> is
							synchronized with the calendar.
						</td></tr><tr><td><termref ref="prop-PIVL.institutionSpecified">institutionSpecified</termref></td><td><termref ref="dt-BL">BL</termref></td><td>
							Indicates whether the exact timing is up to the party executing the
							schedule (e.g., to distinguish "every 8 hours" from "3 times a day".)
						</td></tr></tbody></table><p>
					For example, "every eight hours for two minutes" is a <emph>PIVL</emph>
					where the interval's <termref ref="prop-IVL.width">IVL.width</termref> equals 2
					minutes and the <termref ref="prop-PIVL.period">period</termref>
					at which the interval recurs equals 8 hours.
				</p><p><termref ref="prop-PIVL.phase">phase</termref> also marks the anchor point
					in time for the entire series of periodically recurring intervals.
					The recurrence of a <emph>PIVL</emph> has no
					beginning or ending, but is infinite in both future and past.
				</p><exhibit role="dtdl" id="dtdl-PIVL"><anchor id="dtdl-PIVL"/><caption/><pre>
template&lt;TS T&gt;
protected type PeriodicInterval&lt;T&gt; alias PIVL&lt;T&gt;
            specializes  SET&lt;T&gt; {
            T.diff       period;
            IVL&lt;T&gt;       phase;
            CS           alignment;
            BL           institutionSpecifiedTime;
            BL           contains(TS);
   literal  ST;
};</pre></exhibit><p>
					A <emph>PIVL</emph> is fully specified when both <termref ref="prop-PIVL.period">period</termref>
					and <termref ref="prop-PIVL.phase">phase</termref> are fully specified.
					The interval may be only partially specified where either
					only <termref ref="prop-IVL.width">IVL.width</termref> or only one boundary is
					specified.
				</p><p>
					For example: "every eight hours for two minutes" specifies only
					<termref ref="prop-PIVL.period">period</termref> and <termref ref="prop-IVL.width">IVL.width</termref>
					of <termref ref="prop-PIVL.phase">phase</termref> but no boundary of the
					<termref ref="prop-PIVL.phase">phase</termref>. Conversely,
					"every eight hours starting at 4 o'clock" specifies only
					<termref ref="prop-PIVL.period">period</termref>
					and <termref ref="prop-IVL.low">IVL.low</termref> of <termref ref="prop-PIVL.phase">phase</termref>
					but not <termref ref="prop-IVL.high">IVL.high</termref> of <termref ref="prop-PIVL.phase">phase</termref>.
					"Every eight hours for two minutes starting at 4 o'clock" is fully specified
					since <termref ref="prop-PIVL.period">period</termref>, and both <termref ref="prop-IVL.low">IVL.low</termref>
					and <termref ref="prop-IVL.width">IVL.width</termref> of <termref ref="prop-PIVL.phase">phase</termref>
					are	specified.
				</p><p><emph>PIVL</emph> is a generic type extension whose type
					parameter T is restricted to a <termref ref="dt-TS">TS</termref>
					and its extensions. <termref ref="dt-PPD_TS&gt;">PPD&lt;TS&gt;&gt;</termref> is
					an extension of <termref ref="dt-TS">TS</termref> and therefore can be used to form
					<termref ref="dt-PIVL">PIVL</termref>&lt;<termref ref="dt-PPD_TS">PPD&lt;TS&gt;</termref>&gt; values.
				</p><p>
					Often times, repeating schedules are only approximately specified. For
					instance "three times a day for ten minutes each" does not usually
					mean a <termref ref="prop-PIVL.period">period</termref> of precisely 8 hours and does
					often not mean exactly 10 minutes intervals. Rather the distance
					between each occurrence may	vary as much as between 3 and 12 hours
					and the <termref ref="prop-IVL.width">IVL.width</termref> of the interval
					may be less than 5 minutes or more than 15 minutes.
					<termref ref="dt-PIVL">PIVL</termref>&lt;<termref ref="dt-PPD_TS">PPD&lt;TS&gt;</termref>&gt; can be used to indicate how much
					leeway is allowed or how "timing-critical" the specification is.
				</p><div3 id="prop-PIVL.phase"><head>Phase : <termref ref="dt-IVL">IVL</termref>&lt;T&gt;</head><p><emph role="strong">Definition:</emph>
							A prototype of the repeating interval, specifying the duration of
							each occurrence and anchors the <emph>PIVL</emph> sequence at a
							certain point in time.
						</p><p><emph>phase</emph> also marks the anchor point in time for the entire series of
							periodically recurring intervals. The recurrence of a <emph>PIVL</emph>
							has no begin or end but is infinite in both future and
							past. <termref ref="prop-IVL.width">IVL.width</termref> of <emph>phase</emph> must
							be less than or equal to <termref ref="prop-PIVL.period">period</termref>.
						</p><exhibit role="dtdl"><caption/><pre>
invariant (PIVL&lt;T&gt; x)
      where x.nonNull {
   x.phase.nonNull.implies(x.phase.width.lessOrEqual(x.period));
};</pre></exhibit></div3><div3 id="prop-PIVL.period"><head>Period : <termref ref="dt-T.diff">T.diff</termref></head><p><emph role="strong">Definition:</emph>
							A time duration specifying as a reciprocal measure of the frequency at
							which the <emph>PIVL</emph> repeats.
						</p><p><emph>period</emph> is a <termref ref="dt-QTY">QTY</termref> in the dimension of time
							(T.diff).
							For an uncertain <emph>PIVL</emph><emph>period</emph> is a probability
							distribution over elapsed time.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(PIVL&lt;T&gt; x)
      where x.nonNull {
   x.period.nonNull;
};

invariant(PIVL x) {
   x.period.dataType.implies(PQ);
};</pre></exhibit></div3><div3 id="prop-PIVL.alignment"><head>Alignment to the Calendar : <termref ref="dt-CS">CS</termref></head><p><emph role="strong">Definition:</emph>
							Specifies if and how the repetitions are aligned to the cycles 
							of the underlying calendar (e.g., to distinguish every 30 days
							from "the 5th of every month".) A non-aligned <emph>PIVL</emph> recurs
							independently from the calendar. An aligned <emph>PIVL</emph> is
							synchronized with the calendar.
						</p><p>
							For example, "every 5th of the month" is a calendar aligned <emph>PIVL</emph>.
							<termref ref="prop-PIVL.period">period</termref> varies from 28 to 31 days depending
							on the calendar month. Conversely, "every 30 days" is an independent
							<termref ref="prop-PIVL.period">period</termref> that will
							fall on a different date each month.
						</p><p>
							The calendar alignment specifies a calendar cycle to which the
							<emph>PIVL</emph> is aligned. The even flow of time will then be
							partitioned by the calendar cycle. The partitioning is called the
							calendar "grid" generated by the aligned-to calendar cycle. The
							boundaries of each occurrence interval will then have equal distance
							from the earliest point in each partition. In other words, the
							distance from the next lower grid-line to the beginning of the
							interval is constant.
						</p><p>
							For example, with "every 5th of the month" the alignment
							calendar cycle would be month of the year (<code>MY</code>).  The even
							flow of time is partitioned in months of the year. The distance
							between the beginning of each month and the beginning of its
							occurrence interval is 4 days (4 days because day of month (DM) starts
							counting with 1.)  Thus, as months differ in their number of days, the
							distances between the recurring intervals will vary slightly, so that
							the interval occurs always on the 5th.
						</p></div3><div3 id="prop-PIVL.institutionSpecified"><head>Institution Specified Timing : <termref ref="dt-BL">BL</termref></head><p><emph role="strong">Definition:</emph>
							Indicates whether the exact timing is up to the party executing the
							schedule (e.g., to distinguish "every 8 hours" from "3 times a day".)
						</p><p>
							For example, with a schedule "three times a day" the average time
							between repetitions is 8 hours, however, with institution specified
							time indicator equal to <emph>true</emph>, the timing could follow some rule
							made by the executing person or organization ("institution"), that,
							e.g., three times a day schedules are executed at 7 am, noon, and 7
							pm.
						</p></div3><div3 id="prop-PIVL.literal"><head>Literal Form</head><p><emph role="strong">Generic Literal Form</emph>. The generic 
							literal form for periodic intervals of time is as follows:
						</p><p>
							(<emph>phase</emph> : IVL&lt;T&gt;( <emph role="strong">/</emph>
							(<emph>period</emph> : QTY  ( [ <emph role="strong">@</emph>
							(<emph>alignment</emph>( ] [ <emph role="strong">IST</emph> ].
						</p><exhibit role="dtdl"><caption/><pre>
PIVL&lt;T&gt;.literal ST {
   PIVL&lt;T&gt;    : S2                  { $.equal($1); }
              | S2 "IST"            { $.phase.equal($1.phase);
                                      $.period.equal($1.period);
                                      $.institutionSpecified.equal(true); };
   PIVL&lt;T&gt; S2 : S1                  { $.equal($1); }
              | S1 "@" "(" ST ")"   { $.phase.equal($1.phase);
                                      $.period.equal($1.period);
                                      $.alignment.equal($4); };
   PIVL&lt;T&gt; S1 :
      IVL&lt;T&gt; "/" "(" QTY ")"        { $.phase.equal($1);
                                      $.period.equal($3); }
              | "/" "(" QTY ")"     { $.period.equal($2); };
};</pre></exhibit><p>
							For example, "<code>[200004181100;200004181110]/(7 d)@DW</code>"
							specifies every Tuesday from 11:00 to 11:10 AM. Conversely,
							"<code>[200004181100;200004181110]/(1 mo)@DM</code>" specifies every
							18th of the month 11:00 to 11:10 AM.
						</p><p>
							See <tabref ref="domain-CalendarCycle"/> for calendar-period codes
							defined for the Gregorian calendar. There are 1-character and
							2-character symbols. The 2-character symbols are preferred for the
							<termref ref="prop-PIVL.alignment">alignment</termref>.
						</p><p><emph role="strong">Calendar Pattern Form</emph>. This form is
							used to specify calendar-aligned timing more intuitively using "calendar
							patterns."  The calendar pattern syntax is (semi-formally) defined as
							follows:
						</p><p>
							(<emph>anchor</emph>( [ (<emph>calendar digits</emph>(
							 [ <emph role="strong">..</emph> (<emph>calendar digits</emph>( ]]
							<emph role="strong">/</emph> (<emph>number</emph>
							 : INT( [ <emph role="strong">IST</emph> ]
						</p><p>
							A calendar pattern is a calendar date where the higher significant
							digits (e.g., year and month) are omitted. In order to interpret the
							digits, a period identifier is prefixed that identifies the calendar
							period of the left-most digits. This calendar period identifier
							<emph>anchors</emph> the calendar digits following to the right.
						</p><p>
							See <tabref ref="domain-CalendarCycle"/> for calendar-period codes
							defined for the Gregorian calendar. There are 1-character and
							2-character symbols. The 1-character symbols are preferred for the
							calendar pattern anchor.
						</p><p>
							For example: "<code>M0219</code>" is February 19 the entire day every
							year. This periodic interval has the February 19 of any year as its
							phase (e.g., "<code>[19690219;19690220[</code>" ), a period of one
							year, and alignment month of the year (M). The alignment
							calendar-cycle is the same as the anchor (e.g., in this example, month
							of the year.)
						</p><p>
							The calendar digits may also omit digits on the right. When digits are
							omitted on the right, this means the interval from lowest to highest
							for these digits. For example, "<code>M0219</code>" is February 19 the
							entire day; "<code>M021918</code>" is February 19, the entire hour
							between 6 and 7 PM.
						</p><p>
							In absence of a formal definition for this, the rules for parsing a
							calendar pattern are as follows (example is "<code>M021918..21</code>"):
						</p><list role="ordered"><item>
								read the anchoring period identifier (e.g. "<code>M</code>")
							</item><item>
								alignment is equal to this calendar period (e.g. month of
								the year)
							</item><item>
								use the current point in time and format a literal exact to the next
								higher significant calendar period from the anchoring calendar period
								(e.g. year, "<code>2000</code>", constructing
								"<code>2000021918</code>"); this is the "stem literal"
							</item><item>
								read this constructed literal (e.g., "<code>2000021918</code>") into a
								<termref ref="dt-TS">TS</termref> value and convert that value to an interval
								according to <termref ref="prop-IVL_TS.promotionTS">IVL_TS.promotionTS</termref> (e.g.,
								"[2000021918;2000021919[") this is the "low interval."
							</item><item>
								if the hull-operator token ".." follows, read the following calendar
								digits (e.g., "21")
							</item><item>
								right-align the stem literal and the calendar digits just read
								<pre>
     "2000021918"
     "        21"
								</pre></item><item>
								and copy all digits from the stem literal that are missing to the left
								of the calendar digits just read (e.g., yields "<code>2000021921</code>".)
							</item><item>
								read this constructed literal (e.g., "<code>2000021918</code>") into a
								<termref ref="dt-TS">TS</termref> value and convert that value to an <termref ref="dt-IVL_TS">IVL&lt;TS&gt;</termref>
								according to <termref ref="prop-IVL_TS.promotionTS">IVL_TS.promotionTS</termref>
								(e.g., "<code>[2000021921;2000021922[</code>") this is the "high interval."
							</item><item><termref ref="prop-PIVL.phase">phase</termref> is the convex hull of the low interval and the high
								interval (e.g., "<code>[2000021918;2000021922[</code>").
							</item><item>
								if the hull-operator was not present, <termref ref="prop-PIVL.phase">phase</termref> is simply the low interval.
							</item></list><p><emph role="strong">Interleave.</emph> A calendar pattern
							followed by a slash and an integer number <emph>n</emph> indicates that the
							given calendar pattern is to apply every nth time.
						</p><p>
							For example: "<code>D19/2</code>" is the 19th of every second month.
						</p><p>
							A calendar pattern expression is evaluated at the time the pattern is
							first encountered. At this time, the calendar digits missing from the left
							are completed using the earliest date matching the pattern (and
							following a preceding pattern in a combination of time sets).
						</p><p>
							For example: "<code>D19/2</code>" is the 19th of every second
							month. If this expression is evaluated on March 14, 2000 
							<termref ref="prop-PIVL.phase">phase</termref> is
							completed to: "<code>[20000319;20000320[/(2 mo)@DM</code>" and thus
							the two-months cycle begins with March 19, followed by May 19, etc. If
							the expression were evaluated by March 20, the cycle would begin at
							April 19, followed by June 19, etc.
						</p><p>
							If no calendar digits follow after the calendar period identifier, the
							pattern matches any date. The integer number following the slash
							indicates the length of the cycle. <termref ref="prop-PIVL.phase">phase</termref>
							in these cases
							has only the width specified to be the duration of the anchoring
							calendar-cycle (e.g., in this example 1 day.)
						</p><p>
							For example: "<code>CD/2</code>" is every other day,
							"<code>H/8</code>" is every 8th hour, for the duration of one hour.
						</p><p><emph role="strong">Institution Specified Time.</emph> Both a 
							<emph>PIVL</emph> literal and a calendar pattern may be followed by
							the three letters "IST" to indicate that within the larger calendar
							cycle (e.g., for "hour of the day" the larger calendar cycle is "day")
							the repeating events are to be appointed at institution specified
							times. This is used to specify such schedules as "three times a day"
							where the periods between two subsequent events may vary well between
							4 hours (between breakfast and lunch) and 10 hours (over night.)
							</p><table id="examples-PIVL.literal"><caption>
								Examples for literal expressions for <emph>PIVL</emph>s
              				</caption><col width="2.58" span="1"/><col width="1.37" span="1"/><col width="5.13" span="1"/><thead><tr><th rowspan="1" colspan="1">Generic Form</th><th rowspan="1" colspan="1">Calendar Pattern Form</th><th rowspan="1" colspan="1">Description</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">[198709;198710[/(1 a)@MY</td><td rowspan="1" colspan="1">M09</td><td rowspan="1" colspan="1">
										September, the entire month, every year (note that in 
										the year 1987 in the generic form is irrelevant since the
										periodic interval recurs every year past and future.)
									</td></tr><tr><td rowspan="1" colspan="1">[19870915;19870916[/(1 a)@DM</td><td rowspan="1" colspan="1">M0915</td><td rowspan="1" colspan="1">September 15, the entire day, every year</td></tr><tr><td rowspan="1" colspan="1">[1987091516;1987091517[/(1 a)@DM</td><td rowspan="1" colspan="1">M091516</td><td rowspan="1" colspan="1">September 15 at 4 PM, the entire hour, every year</td></tr><tr><td rowspan="1" colspan="1">[198709151630;198709151710]/(1 a)@DM</td><td rowspan="1" colspan="1">M09151630..1710</td><td rowspan="1" colspan="1">September 15 at 4:30 5:10 PM, every year</td></tr><tr><td rowspan="1" colspan="1">[1987091516;[/(1 a)@DM</td><td rowspan="1" colspan="1"></td><td rowspan="1" colspan="1">September 15 at 4 PM, end time explicitly unknown, every year</td></tr><tr><td rowspan="1" colspan="1">[198709151630;198709151631[/(1 a)@DM</td><td rowspan="1" colspan="1">M09151630</td><td rowspan="1" colspan="1">September 15 at 4:30 PM, the entire minute, every year</td></tr><tr><td rowspan="1" colspan="1">[1987091516;1987091517[/(1 mo)@DM</td><td rowspan="1" colspan="1">D1516..17</td><td rowspan="1" colspan="1">every 15th day of the month at 4 to 5 PM</td></tr><tr><td rowspan="1" colspan="1">[1987091516;1987091517[/(1 mo)</td><td rowspan="1" colspan="1"></td><td rowspan="1" colspan="1">
										September 15, 1987 from 4 to 5 PM and then every 730.5 
										hours continuously (this example has little practical value 
										beyond comparing the unaligned with the aligned form in the 
										preceding row.)
									</td></tr><tr><td rowspan="1" colspan="1">[1987091516;1987091517[/(1 mo)@HD</td><td rowspan="1" colspan="1"></td><td rowspan="1" colspan="1">
										September 15, 1987 from 4 to 5 PM and then every 30.4375
										days, but aligned to the hour of the day.
									</td></tr><tr><td rowspan="1" colspan="1">[1 mo]/(2 mo)@MY</td><td rowspan="1" colspan="1">M/2</td><td rowspan="1" colspan="1">
										every other month of the year; (Jan, Mar, ...) vs. (Feb, 
										Apr, ...) is undefined
									</td></tr><tr><td rowspan="1" colspan="1">[198701;197502[/(2 mo)@MY</td><td rowspan="1" colspan="1">M01..12/2</td><td rowspan="1" colspan="1">every other month of the year, Jan, Mar, ...</td></tr><tr><td rowspan="1" colspan="1">[198702;197503[/(2 mo)@MY</td><td rowspan="1" colspan="1">M02..12/2</td><td rowspan="1" colspan="1">every other month of the year, Feb, Apr, ...</td></tr><tr><td rowspan="1" colspan="1">[19870401;19870930[/(1 a)@DM</td><td rowspan="1" colspan="1">M04..09</td><td rowspan="1" colspan="1">April 1until (and including) September 30</td></tr><tr><td rowspan="1" colspan="1">19870401-0930/(1 a)@DM</td><td rowspan="1" colspan="1">M0401..0930</td><td rowspan="1" colspan="1">
										April 1 to September 30 (the generic form uses the 
										dash-form for the phase interval)
									</td></tr><tr><td rowspan="1" colspan="1">[20001202;20001203[/(1 wk)@DW</td><td rowspan="1" colspan="1">J6</td><td rowspan="1" colspan="1">every Saturday</td></tr><tr><td rowspan="1" colspan="1">[20001202;20001203[/(2 wk)@DW</td><td rowspan="1" colspan="1">J6/2</td><td rowspan="1" colspan="1">every other Saturday</td></tr><tr><td rowspan="1" colspan="1">[20001202;20001203[/(3 wk)@DW</td><td rowspan="1" colspan="1">J6/3</td><td rowspan="1" colspan="1">every third Saturday</td></tr><tr><td rowspan="1" colspan="1">[1 d]/(2 d)@DW</td><td rowspan="1" colspan="1">J/2</td><td rowspan="1" colspan="1">
										every other day of the week; (Mon, Wed, Fri, ...) vs. 
										(Tue, Thu, Sat, ...)  is undefined
									</td></tr><tr><td rowspan="1" colspan="1">[20001204;20001205[/(2 d)@DW</td><td rowspan="1" colspan="1">J2..6/2</td><td rowspan="1" colspan="1">
										every other day of the week (Tue, Thu, Sat, Tue, Thu, 
										Sat, ...)
									</td></tr><tr><td rowspan="1" colspan="1">[20001204;20001205[/(2 d)</td><td rowspan="1" colspan="1">D/2</td><td rowspan="1" colspan="1">
										every other day (Tue, Thu, Sat, Mon, Wed, Fri, Sun, 
										Tue, ...)
									</td></tr><tr><td rowspan="1" colspan="1">[19870601;19870606[/(1 wk)@DW</td><td rowspan="1" colspan="1">J1..5</td><td rowspan="1" colspan="1">Monday to Friday every week</td></tr><tr><td rowspan="1" colspan="1">[19870601;19870608[/(2 wk)</td><td rowspan="1" colspan="1">W/2</td><td rowspan="1" colspan="1">every other week (continuous)</td></tr><tr><td rowspan="1" colspan="1">[19870101;19870105[/(2 wk)@WY</td><td rowspan="1" colspan="1">WY/2</td><td rowspan="1" colspan="1">
										every other week of the year (a blunt example on the 
										impact of the calendar alignment: the phase interval spans 
										only 4 days and yet it represents an entire week in the 
										calendar alignment "week of the year".)
									</td></tr><tr><td rowspan="1" colspan="1">[19870406;19870413[/(1 a)@WY</td><td rowspan="1" colspan="1">WY15</td><td rowspan="1" colspan="1">the 15th calendar week of every year</td></tr><tr><td rowspan="1" colspan="1">[19870105;19870112[/(1 mo)@WM</td><td rowspan="1" colspan="1">WM2</td><td rowspan="1" colspan="1">the second week of the month, every month</td></tr><tr><td rowspan="1" colspan="1">[19870508;19870509[/(1 a)@DY</td><td rowspan="1" colspan="1">DY128</td><td rowspan="1" colspan="1">the 128th day of the year, every year</td></tr><tr><td rowspan="1" colspan="1">[10 min]/(2 d)</td><td rowspan="1" colspan="1"></td><td rowspan="1" colspan="1">
										every other day for 10 minutes (only width of repeating 
										interval is known)
									</td></tr><tr><td rowspan="1" colspan="1">[1 h]/(8 h)</td><td rowspan="1" colspan="1">H/8</td><td rowspan="1" colspan="1">every eighth hour (each time a 60 minutes interval)</td></tr><tr><td rowspan="1" colspan="1">[1 h]/(8 h) IST</td><td rowspan="1" colspan="1">H/8 IST</td><td rowspan="1" colspan="1">
										three times a day at institution specified times (each 
										time a 60 minutes interval)
									</td></tr><tr><td rowspan="1" colspan="1">/(8 h) IST</td><td rowspan="1" colspan="1"></td><td rowspan="1" colspan="1">
										three times a day at institution specified times. 
										Nothing about the repeating interval is known i.e., this 
										includes only a period (frequency), while the phase is left 
										undefined
									</td></tr></tbody></table></div3><div3><head>Periodic Intervals as Sets</head><p>
						The essential property of a set is that it contains elements. For
						non-aligned <emph>PIVL</emph>s, the <emph>contains</emph>-property is
						defined as follows. A <termref ref="dt-TS">TS</termref><emph>t</emph> is
						contained in the <emph>PIVL</emph> if and only if there is an integer
						<emph>i</emph> for which <emph>t</emph> plus <termref ref="prop-PIVL.period">period</termref>
						times <emph>i</emph> is an element of <termref ref="prop-PIVL.phase">phase</termref>.
					</p><exhibit role="dtdl"><caption/><pre>
invariant (PIVL&lt;TS&gt; x, TS t)
      where x.nonNull.and(x.alignment.isNull) {
   x.contains(t).equal(exists(INT i) {
      x.phase.contains(t.plus(x.period.times(i)));
      });
};</pre></exhibit><p>
						For calendar-aligned <emph>PIVL</emph>s the <emph>contains</emph>
						property is defined using the calendar-cycle's sum(<emph>t</emph>,
						<emph>n</emph>) property that adds <emph>n</emph> such calendar cycles
						to the time <emph>t</emph>.
					</p><exhibit role="dtdl"><caption/><pre>
invariant (PIVL&lt;TS&gt; x, TS t, CalendarCycle c)
      where x.nonNull.and(c.equal(x.alignment)) {
   x.contains(t).equal(exists(INT i) {
      x.phase.contains(c.sum(t, i));
      });
};</pre></exhibit></div3></div2><div2 id="dt-EIVL"><anchor id="EIVL"/><head>Event-Related Periodic Interval of Time (EIVL) specializes <termref ref="dt-SET">SET</termref></head><parameter name="T" type="TS"/><p><emph role="strong">Definition:</emph>
					Specifies a periodic interval of time where the recurrence is based on
					activities of daily living or other important events that are
					time-related but not fully determined by time.
				</p><p>
					For example, "one hour after breakfast" specifies the beginning of the
					interval at one hour after breakfast is finished. Breakfast is assumed
					to occur before lunch but is not determined to occur at any specific
					time.
				</p><exhibit role="dtdl" id="dtdl-EIVL"><anchor id="dtdl-EIVL"/><caption/><pre>
template&lt;TS T&gt;
protected type EventRelatedPeriodicInterval&lt;T&gt; alias EIVL&lt;T&gt;
           specializes  SET&lt;T&gt;{
           CS           event;
           IVL&lt;PQ&gt;      offset;
           IVL&lt;T&gt;       occurrenceAt(TS eventTime);
           BL           contains(TS);
  literal  ST;
};</pre></exhibit><div3 id="prop-EIVL.event"><head>Event : <termref ref="dt-CS">CS</termref></head><p><emph role="strong">Definition:</emph>
							A code for a common (periodical) activity of daily living based on
							which the event related periodic interval is specified.
						</p><p>
							Such events qualify for being adopted in the domain of this
							attribute for which all of the following is true:
						</p><list role="unordered"><item>
								the event commonly occurs on a regular basis
							</item><item>
								the event is being used for timing activities, and
							</item><item>
								the event is not entirely determined by time
							</item></list><table id="domain-TimingEvent"><caption>Domain TimingEvent</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><td>AC</td><td>AC</td><td>before meal (from lat. ante cibus)</td></tr><tr valign="top"><td>ACD</td><td>ACT</td><td>before lunch (from lat. ante cibus diurnus)</td></tr><tr valign="top"><td>ACM</td><td>ACM</td><td>before breakfast (from lat. ante cibus matutinus)</td></tr><tr valign="top"><td>ACV</td><td>ACV</td><td>before dinner (from lat. ante cibus vespertinus)</td></tr><tr valign="top"><td>HS</td><td>HS</td><td>the hour of sleep</td></tr><tr valign="top"><td>IC</td><td>IC</td><td>between meals (from lat. inter cibus)</td></tr><tr valign="top"><td>ICD</td><td>ICD</td><td>between lunch and dinner</td></tr><tr valign="top"><td>ICM</td><td>ICM</td><td>between breakfast and lunch</td></tr><tr valign="top"><td>ICV</td><td>ICV</td><td>between dinner and the hour of sleep</td></tr><tr valign="top"><td>PC</td><td>PC</td><td>after meal (from lat. post cibus)</td></tr><tr valign="top"><td>PCD</td><td>PCD</td><td>after lunch (from lat. post cibus diurnus)</td></tr><tr valign="top"><td>PCM</td><td>PCM</td><td>after breakfast (from lat. post cibus matutinus)</td></tr><tr valign="top"><td>PCV</td><td>PCV</td><td>after dinner (from lat. post cibus vespertinus)</td></tr></table></div3><div3 id="prop-EIVL.offset"><head>Offset : <termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-PQ">PQ</termref>&gt;</head><p><emph role="strong">Definition:</emph>
							An interval of elapsed time (duration, not absolute point in time)
							that marks the offsets for the beginning, width and end of
							the <emph>EIVL</emph> measured from the time each such
							event actually occurred.
						</p><p>
							For example: if the specification is "one hour before breakfast for 10
							minutes" <termref ref="prop-IVL.low">IVL.low</termref> of <emph>offset</emph> is 1 h
							and the <termref ref="prop-IVL.width">IVL.width</termref> of <emph>offset</emph> is
							10 min.
						</p></div3><div3 id="prop-EIVL.literal"><head>Literal Form</head><p>
							The literal form for an <emph>EIVL</emph> begins with the event
							code followed by an optional interval of the time-difference.
						</p><exhibit role="dtdl"><caption/><pre>
EIVL&lt;TS&gt;.literal ST {
   EIVL&lt;TS&gt; : event          { $.event.equal($1); }
            | event offset   { $.event.equal($1);
                               $.offset.equal($2); };
   CS event : ST             { $.code.equal($1);
                               $.codeSystem.equal(2.16.840.1.113883.5.1019); }
   IVL&lt;PQ&gt; offset
            : "+" IVL&lt;PQ&gt;    { $.equal($2); }
            | "-" IVL&lt;PQ&gt;    { $.low.equal($2.high.negate);
                               $.high.equal($2.low.negate);
                               $.width.equal($2.width);
                               $.lowClosed($2.highClosed);
                               $.highClosed($2.lowClosed); };
};</pre></exhibit><p>
							For example, one hour after meal would be
							"<code>PC+[1h;1h]</code>". One hour before bedtime for 10 minutes:
							"<code>HS-[50min;1h]</code>".
						</p></div3><div3><head>Resolving the Event-Relatedness</head><p>
						An <emph>EIVL</emph> is a set of time, that is,
						one can test whether a particular time or time interval is an element
						of the set. Whether an <emph>EIVL</emph>
						contains a given interval of time is decided using a relation event
						&#967; <emph>time</emph> referred to as EVENT(<emph>event</emph>,
						<emph>time</emph>). The property occurrenceAt(<emph>t</emph>) is the
						occurrence interval that would exist if the event occurred at time
						<emph>t</emph>.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(EIVL&lt;T&gt; x, T eventTime, IVL&lt;T&gt; v)
      where v.equal(x.occurrenceAt(eventTime)) {
   v.low.equal(eventTime.plus(x.offset.low));
   v.high.equal(eventTime.plus(x.offset.high));
   v.lowClosed.equal(x.offset.lowClosed);
   v.highClosed.equal(x.offset.highClosed);
};</pre></exhibit><p>
						Thus, an <emph>EIVL</emph> contains a <termref ref="dt-TS">TS</termref>
						<emph>t</emph> if there is an event time <emph>e</emph> with an
						occurrence interval <emph>v</emph> such that <emph>v</emph> contains
						<emph>t</emph>.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(EIVL&lt;T&gt; x, T y) {
   x.contains(y).equal(exists(T e, IVL&lt;T&gt; v)
      where EVENT(x.event, y).and(v.resolvedAt(y)) {
         v.contains(y);
         });
};</pre></exhibit></div3></div2><div2 id="dt-GTS"><anchor id="GTS"/><head>General Timing Specification (GTS) specializes <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;</head><p><emph role="strong">Definition:</emph>
					A <termref ref="dt-"/>&lt;<termref ref="dt-dt-TS">dt-TS</termref>&gt;, specifying the timing of events and actions
					and the cyclical validity-patterns that may exist for certain kinds of
					information, such as phone numbers (evening, daytime), addresses (so
					called "snowbirds," residing closer to the equator during winter and
					farther from the equator during summer) and office hours.
				</p><p><emph>GTS</emph> has the following aspects:
				</p><list role="unordered"><item><emph>GTS</emph> as a general <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;.
						From this aspect <emph>GTS</emph> answers whether any given
						<termref ref="dt-TS">TS</termref> falls in the schedule described by the
						<emph>GTS</emph> value.
					</item><item><emph>GTS</emph> as the combination of multiple <termref ref="dt-PIVL">PIVL</termref>s. This
						aspect describes how both simple and complex repeat-patterns are
						specified with the <emph>GTS</emph>.
					</item><item><emph>GTS</emph> as a generator of a <termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-IVL_TS">IVL&lt;TS&gt;</termref>&gt;.
						From this aspect, <emph>GTS</emph> can generate all occurrence
						intervals of an event or action, or all validity periods for a fact.
					</item><item><emph>GTS</emph> as an expression-syntax defined for a calendar. This aspect is the
						<emph>GTS</emph> literal form.
					</item></list><p>
					In all cases <emph>GTS</emph> is defined as a <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;.
					Using <termref ref="prop-SET.union">SET.union</termref>, <termref ref="prop-SET.intersect">SET.intersect</termref>
					and <termref ref="prop-SET.difference">SET.difference</termref>,
					more complex <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;s can be
					constructed from simpler ones. Ultimately the building blocks from
					which all <emph>GTS</emph> values are constructed are <termref ref="dt-IVL">IVL</termref>,
					<termref ref="dt-PIVL">PIVL</termref>,
					and <termref ref="dt-EIVL">EIVL</termref>. The construction of the <emph>GTS</emph> value can
					be specified in the literal form. No special data type structure is
					defined that would generate a combination of simpler time-sets from a
					given <emph>GTS</emph> value. While any implementation would have to contain such a
					structured representation, it is not needed in order to exchange <emph>GTS</emph>
					values given the literal form.<footnote><p><emph>GTS</emph> is an example of a data type that is only defined
							algebraically without giving any definition of a data structure that
							might implement the behavior of such a data type. The algebraic
							definition looks extremely simple, so that one might assume it is
							incomplete. Since at this point we are relying entirely on the literal
							form to represent <emph>GTS</emph> values, all the definition of data structur
						</p></footnote></p><exhibit role="dtdl" id="dtdl-GTS"><anchor id="dtdl-GTS"/><caption/><pre>
type GeneralTimingSpecification alias GTS specializes SET&lt;TS&gt; {
            IVL&lt;TS&gt;   hull;
            IVL&lt;TS&gt;   nextTo(TS x)
            IVL&lt;TS&gt;   nextAfter(TS x)
            GTS       periodicHull(GTS x);
            BL        interleaves(GTS x);
  demotion  LIST&lt;IVL&lt;TS&gt;&gt;;
  literal   ST;
};</pre></exhibit><!--
				<p>
					<dtname/> is defined using intervals, periodic intervals,
					and event-related periodic intervals. Intervals of time have been
					defined above.
				</p>
  --><div3><head>Convex Hull</head><p>
						A convex hull is the least interval that is a superset of all
						occurrence intervals. As noted in <termref ref="prop-SET.hull">SET.hull</termref>, all
						totally ordered sets have a convex hull. Because <emph>GTS</emph> is a
						<termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;, which is totally ordered,
						all <emph>GTS</emph> values have a convex hull.
					</p><p>
						The convex hull of a <emph>GTS</emph> can less formally be called the "outer bound
						interval". Thus, the convex hull of a <emph>GTS</emph> describes the absolute
						beginning and end of the repeating schedule. For infinite repetitions
						(e.g., a <termref ref="dt-PIVL">PIVL</termref>) the convex hull has infinite
						bounds.
					</p><graphic source="graphics/datyp2fig14.jpg" alt="Convex Hull of a Schedule"/></div3><div3><head>GTS as a Sequence of Occurrence Intervals</head><p>
						A <emph>GTS</emph> value is a generator of a sequence of time
						intervals during which an event or activity occurs, or during which a
						state is effective.
					</p><p>
						The <emph role="strong">nextTo</emph>-property maps to every point in
						time <emph>t</emph> the greatest continuous subset (an "occurrence
						interval") <emph>v</emph> of the <emph>GTS</emph> value
						<emph>S</emph>, where <emph>v</emph> is the interval closest to
						<emph>t</emph> that begins later than <emph>t</emph> or that contains
						<emph>t</emph>.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(GTS S, TS t, IVL&lt;TS&gt; v) {
   v.equal(S.nextTo(t)).equal(
      S.contains(o).and(
         forall(IVL&lt;TS&gt; u) where x.contains(u) {
            u.contains(v).implies(u.equal(v));
            })
         .and(v.contains(t).or(forall(TS i) where t.lessOrEqual(i)
               .and(i.lessThan(v.low)) {
            S.conatins(i).not; })));
};</pre></exhibit><p>
						The <emph role="strong">nextAfter</emph>-property maps to every point
						in time <emph>t</emph> the greatest continuous subset (an "occurrence
						interval") <emph>v</emph> of the<emph>GTS</emph> value
						<emph>S</emph>, where <emph>v</emph> is the interval closest to
						<emph>t</emph> that begins later than <emph>t</emph>.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(GTS S, TS t) {
   S.contains(t).not.implies(S.nextAfter(t).equal(S.nextTo(t)));
   S.contains(t).implies(S.nextAfter(t).equal(
               S.except(nextTo(t)).nextTo(t)));
};</pre></exhibit><p>
						A <emph>GTS</emph> value can be converted into a <termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-IVL_TS">IVL&lt;TS&gt;</termref>&gt;.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(GTS x)
      where x.isEmpty {
   ((LIST&lt;IVL&lt;TS&gt;&gt;)x).isEmpty; };

invariant(GTS x, IVL&lt;TS&gt; first)
      where x.notEmpty.and(x.hull.low.nonNull)
                      .and(first.equal(x.nextTo(x.hull.low)) {
   ((LIST&lt;IVL&lt;TS&gt;&gt;)x).head.equal(first);
   ((LIST&lt;IVL&lt;TS&gt;&gt;)x).tail.equal(
      (LIST&lt;IVL&lt;TS&gt;&gt;)x.except(first));
};</pre></exhibit></div3><div3><head>Interleaving Schedules and Periodic Hull</head><graphic source="graphics/datyp2fig15.jpg" alt="Interleaving Schedules and Periodic Hull"/><p>
						For two <emph>GTS</emph> values <emph>A</emph> and <emph>B</emph> we
						say that <emph>A</emph> interleaves <emph>B</emph> if their occurrence
						intervals interleave on the time line. This concept is visualized in
						Figure above.
					</p><p>
						For <emph>GTS</emph> values <emph>A</emph> and <emph>B</emph>
						to interleave the occurrence intervals of both groups can be arranged
						in pairs of corresponding occurrence intervals. It must further hold
						that for all corresponding occurrence intervals <emph>a</emph>
						&#8838; <emph>A</emph> and <emph>b</emph> &#8838; <emph>B</emph>,
						<emph>a</emph> starts before <emph>b</emph> starts (or at the same
						time) and <emph>b</emph> ends after <emph>a</emph> ends (or at the
						same time).
					</p><p>
						The interleaves-relation holds when two schedules have the same
						average frequency, and when the second schedule never "outpaces" the
						first schedule. That is, no occurrence interval in the second schedule
						may start before its corresponding occurrence interval in the first
						schedule.
					</p><p>
						With two interleaving <emph>GTS</emph> values, one can derive a
						periodic hull such that the occurrence intervals of the periodic hull
						is the convex hull of the corresponding occurrence intervals.
					</p><p>
						The periodic hull is important to construct two schedules by combining
						<termref ref="dt-GTS">GTS</termref> expressions. For example, to construct the periodic
						interval from Memorial Day to Labor Day every year, one first needs to
						set up the schedules <emph>M</emph> for Memorial Day (the last Monday
						in May) and <emph>L</emph> for Labor Day (the first Monday in
						September) and then combine these two schedules using the periodic
						hull of <emph>M</emph> and <emph>L</emph>.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(GTS A, B)
      where x.nonNull.and(y.nonNull) {
   A.interleaves(B).equal(
      forall(IVL&lt;TS&gt; a, b, c; TS t)
         where a.equal(A.nextTo(t))
                .and(b.equal(B.nextTo(a.low)))
                .and(c.equal(A.nextTo(b.high))) {
            b.equal(B.nextTo(a.high));
            a.low.lessOrEqual(b.low);
            c.equal(A.nextTo(b.high));
            c.equal(a).or(c.equal(A.nextAfter(a.high)));
            });
};</pre></exhibit><p>
						For two <emph>GTS</emph> values <emph>A</emph> and <emph>B</emph>
						where <emph>A</emph> interleaves <emph>B</emph>, a periodic hull is
						defined as the pair wise convex hull of the corresponding occurrence
						intervals of <emph>A</emph> and <emph>B</emph>.
					</p><exhibit role="dtdl"><caption/><pre>
invariant(GTS A, B, C)
      where A.interleaves(B) {
   A.periodicHull(B).equal(C).equal(
      forall(IVL&lt;TS&gt; a, b; TS t)
         where a.equal(A.nextTo(t))
                .and(b.equal(B.nextTo(a.low))) {
            C.contains(c).equal(c.equal(a.hull(b)));
            });
};</pre></exhibit><p>
						The interleaves-relation is reflexive, asymmetric, and
						intransitive. The periodic hull operation is non-commutative and
						non-associative.<footnote><p>
								The interleaves property may appear overly constrained. However, these
								constraints are reasonable for the use case for which the interleaves
								and periodic hull properties are defined. To safely and predictably
								combine two schedules one would want to know which of the operands
								sets the start points and which sets the endpoints of the periodic
								hull's occurrence intervals.
							</p></footnote></p></div3><div3 id="prop-GTS.literal"><head>Literal Form</head><p>
						The <emph>GTS</emph> literal allows specifying combinations of
						<termref ref="dt-IVL_TS">IVL&lt;TS&gt;</termref>, <termref ref="dt-PIVL">PIVL</termref>, and <termref ref="EIVL"/>
						using the set operations union and intersection.<footnote><p>
								This literal specification again looks surprisingly simple, so one
								might assume it is incomplete. However, the <emph>GTS</emph>
								literal is based on the <termref ref="dt-TS">TS</termref>, <termref ref="dt-IVL">IVL</termref>,
								<termref ref="dt-PIVL">PIVL</termref>, and <termref ref="dt-EIVL">EIVL</termref> literals
								and also implies the
								literals for the extensions of <termref ref="dt-TS">TS</termref>, notably the
								<termref ref="dt-PPD_TS">PPD&lt;TS&gt;</termref>. The <emph>GTS</emph> literal 
								specification itself only needs to tie the other literal
								forms together, which is indeed a fairly simple task by itself.
							</p></footnote></p><p>
						Unions are speecified by a semicolon-separated list. Intersections
						are specified by a whitespace separated list. Intersection has higher
						priority than union. Set difference can be specified
						using a backslash; differences have an intermediate priority,
						i.e. weaker than intersection but stronger than union.
						Also parentheses can be used to overcome operator precedence when
						necessary.
					</p><!-- XXX: WHY IS THIS EVEN HERE? It's unrelated! Get it out!
					<domain table="SetOperator"/>
  --><exhibit role="dtdl"><caption/><pre>
GTS.literal ST {
   GTS symbol : union                      { $.equal($1); }
              | exclusion                  { $.equal($1); };
   SET&lt;TS&gt; union
              : symbol ";" intersection    { $.equal($1.union($3)); }
              | intersection               { $.equal($1); };
   SET&lt;TS&gt; exclusion
              : symbol "\" intersection    { $.equal($1.except($3)); }
              | intersection               { $.equal($1); };
   SET&lt;TS&gt; intersection
              : hull intersection          { $.equal($1.intersection($2)); }
              | hull                       { $.equal($1); };
   SET&lt;TS&gt; hull
              : hull ".." factor           { $.equal($1.periodicHull($3)); }
              | factor                     { $.equal($1); };
   SET&lt;TS&gt; factor
              : IVL&lt;TS&gt;                    { $.equal($1); }
              | PIVL&lt;TS&gt;                   { $.equal($1); }
              | EIVL&lt;TS&gt;                   { $.equal($1); }
              | "(" GTS ")"                { $.equal($1); };
};</pre></exhibit><p>
						The following table contains paradigmatic examples for complex
						<emph>GTS</emph> literals. For simpler examples refer to the literal
						forms of <termref ref="dt-IVL">IVL</termref>, <termref ref="dt-PIVL">PIVL</termref>,
						and <termref ref="dt-EIVL">EIVL</termref>.
					</p><table id="examples-GTS.literal"><caption>
							Examples for Literal Expressions for Generic Timing
							Specifications
						</caption><col width="1.68" span="1"/><col width="4.07" span="1"/><thead><tr><th rowspan="1" colspan="1">Literal Expression</th><th rowspan="1" colspan="1">Meaning</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">M09 D15 H16 N30 S34.12</td><td rowspan="1" colspan="1">
									September 15 at 4:30:34.12 PM as the intersection of
									multiple periodic intervals of times (calendar patterns)
								</td></tr><tr><td rowspan="1" colspan="1">M0915163034.12</td><td rowspan="1" colspan="1">
									September 15 at 4:30:34.12 PM as one simple periodic
									interval of time (calendar pattern)
								</td></tr><tr><td rowspan="1" colspan="1">M01; M03; M07</td><td rowspan="1" colspan="1">
									January, March, and July (a union of three periodic 
									intervals of time)
								</td></tr><tr><td rowspan="1" colspan="1">M04..09 M/2</td><td rowspan="1" colspan="1">
									Every second month from April to September (April, June, 
									August)
								</td></tr><tr><td rowspan="1" colspan="1">J1; J2; J4</td><td rowspan="1" colspan="1">Monday, Tuesday, Thursday</td></tr><tr><td rowspan="1" colspan="1">W/2 J2</td><td rowspan="1" colspan="1">
									every other Tuesday (intersection of every other week and 
									every Tuesday)
								</td></tr><tr><td rowspan="1" colspan="1">1999 WY15</td><td rowspan="1" colspan="1">
									the 15th calendar week in 1999 (period code is optional 
									for the highest calendar unit)
								</td></tr><tr><td rowspan="1" colspan="1">WM2 J6</td><td rowspan="1" colspan="1">Saturday of the 2nd week of the month</td></tr><tr><td rowspan="1" colspan="1">M05 WM2 J6</td><td rowspan="1" colspan="1">Saturday of the 2nd week of May</td></tr><tr><td rowspan="1" colspan="1">M05 DM08..14 J7</td><td rowspan="1" colspan="1">Mother's day (second Sunday in May.)</td></tr><tr><td rowspan="1" colspan="1">J1..5 H0800..1600</td><td rowspan="1" colspan="1">Monday to Friday from 8 AM to 4 PM</td></tr><tr><td rowspan="1" colspan="1">
									J1..4 H0800..1600;<br/>
									J5    H0800..1200
								</td><td rowspan="1" colspan="1">Monday to Thursday 8 AM to 4 PM and Friday 8 AM to 12 noon.</td></tr><tr><td rowspan="1" colspan="1">[10 d] H/8</td><td rowspan="1" colspan="1">Three times a day over 10 days (each time a 60 minutes interval).</td></tr><tr><td rowspan="1" colspan="1">H0800..1600 \J3</td><td rowspan="1" colspan="1">Every day from 8 AM to 4 PM, except Wednesday.</td></tr><tr><td rowspan="1" colspan="1">(M0825..31 J1)..M0831</td><td rowspan="1" colspan="1">The last calendar week of August.</td></tr><tr><td rowspan="1" colspan="1">JHNUSMEM..JHNUSLBR</td><td rowspan="1" colspan="1">The season from the U.S. holidays Memorial Day to Labor Day</td></tr></tbody></table><div4 id="datyp2gtslitsym"><head>Symbolic Abbreviations for GTS expressions.</head><p>
							Table <tabref ref="domain-GTSAbbreviation"/> defines symbolic
							abbreviations for <emph>GTS</emph> values that can be used in
							literals instead of their equivalent term. Abbreviations
							are defined for common periods of the day (AM, PM),
							for periods of the week (business day, weekend), and for holidays.
							The computation for the dates of some holidays, namely
							the Easter holiday, involve some sophistication that goes beyond what
							one would represent in a <emph>GTS</emph> literal. It is
							assumed that the dates of these holidays are drawn from some table or
							some generator module that is outside the scope of this specification.
						</p><p>
							These abbreviations are named <emph>GTS</emph> values and they
							can in turn be a factor of a <emph>GTS</emph> literal. For example,
							one can say "JHCHRXME H08..12" to indicate that the office hours on
							Christmas Eve is from 8 AM to 1PM only. And one can say
							"JHNUSMEM..JHNUSLBR" for the typical midwestern swimming pool season
							from Memorial Day to Labor Day.
						</p><table id="domain-GTSAbbreviation"><caption>Domain GTSAbbreviation</caption><thead><tr valign="bottom"><th>code</th><th>definition</th><th width="20%">formal def.</th></tr></thead><tbody><tr valign="top"><td>AM</td><td>Every morning at institution specified times.</td><td>H00..11 IST</td></tr><tr valign="top"><td>PM</td><td>Every afternoon at institution specified times.</td><td>H12..23 IST</td></tr><tr valign="top"><td>BID</td><td>Two times a day at institution specified time</td><td>/(12 h) IST</td></tr><tr valign="top"><td>TID</td><td>Three times a day at institution specified time</td><td>/(8 h) IST</td></tr><tr valign="top"><td>QID</td><td>Four times a day at institution specified time</td><td>/(6 h) IST</td></tr><tr valign="top"><td>JB</td><td>Regular business days (Monday to Friday excluding holidays)</td><td>J1..5 \JH</td></tr><tr valign="top"><td>JE</td><td>Regular weekends (Saturday and Sunday excluding holidays)</td><td>J6..7</td></tr><tr valign="top"><td>JH</td><td>Holidays</td><td></td></tr><tr valign="top"><td>GTSAbbreviationHolidaysChristianRoman</td><td></td><td></td></tr><tr valign="top"><td>JHCHRXME</td><td></td><td>M1224</td></tr><tr valign="top"><td>JHCHRXMS</td><td></td><td>M1225</td></tr><tr valign="top"><td>JHCHRNEW</td><td></td><td>M0101</td></tr><tr valign="top"><td>JHCHREAS</td><td></td><td></td></tr><tr valign="top"><td>JHCHRGFR</td><td></td><td></td></tr><tr valign="top"><td>JHCHRPEN</td><td></td><td></td></tr><tr valign="top"><td>JHNUS</td><td>United States National Holidays (public holidays for federal employees established by U.S. Federal law 5 U.S.C. 6103).</td><td></td></tr><tr valign="top"><td>JHNUSMLK</td><td>Dr. Martin Luther King, Jr. Day, the third Monday in January.</td><td>M0115..21 J1</td></tr><tr valign="top"><td>JHNUSPRE</td><td>Washington's Birthday (Presidential Day) the third Monday in February.</td><td>M0215..21 J1</td></tr><tr valign="top"><td>JHNUSMEM</td><td>Memorial Day, the last Monday in May.</td><td>M0525..31 J1</td></tr><tr valign="top"><td>JHNUSMEM5</td><td>Friday before Memorial Day Weekend</td><td>M0522..28 J5</td></tr><tr valign="top"><td>JHNUSMEM6</td><td>Saturday of Memorial Day Weekend</td><td>M0523..29 J6</td></tr><tr valign="top"><td>JHNUSIND</td><td>Independence Day (4th of July)</td><td>M0704</td></tr><tr valign="top"><td>JHNUSIND5</td><td>Alternative Friday before 4th of July Weekend [5 U.S.C. 6103(b)].</td><td>M0703 J5</td></tr><tr valign="top"><td>JHNUSIND1</td><td>Alternative Monday after 4th of July Weekend [5 U.S.C. 6103(b)].</td><td>M0705 J1</td></tr><tr valign="top"><td>JHNUSLBR</td><td>Labor Day, the first Monday in September.</td><td>M0901..07 J1</td></tr><tr valign="top"><td>JHNUSCLM</td><td>Columbus Day, the second Monday in October.</td><td>M1008..14 J1</td></tr><tr valign="top"><td>JHNUSVET</td><td>Veteran's Day, November 11.</td><td>M1111</td></tr><tr valign="top"><td>JHNUSTKS</td><td>Thanksgiving Day, the fourth Thursday in November.</td><td>M1122..28 J4</td></tr><tr valign="top"><td>JHNUSTKS5</td><td>Friday after Thanksgiving.</td><td>M1123..29 J5</td></tr></tbody></table><note><p>
								This table is not complete, nor does it include religious holidays
								other than Christian (of the Gregorian [Western] tradition) or
								national holidays countries other than those of the US. This
								is a limitation to be remedied by subsequent additions.
							</p></note><note><p>
								Holidays are locale-specific. Exactly which religious holidays are
								subsumed under JH depends on the locale and other tradition. For
								global interoperability, using constructed <emph>GTS</emph>
								expressions is safer than named holidays. However, some holidays that
								depend on moon phases (e.g., Easter) or ad-hoc decree cannot be easily
								expressed in a <emph>GTS</emph> literal.
							</p></note></div4></div3></div2></div1></body><back>
						<div1  ballotStatus="Reference"><head>Informative Types</head><p>
				These types are currently marked as informative while known issues 
				relating to their design are being resolved.
			</p><div2 id="dt-PPD"><anchor id="PPD"/><head>Parametric Probability Distribution (PPD) specializes T</head><parameter name="T" type="QTY"/><p><emph role="strong">Definition:</emph>
					A generic data type extension specifying uncertainty of quantitative
					data using a distribution function and its parameters. Aside from the 
					specific parameters of the distribution, a mean (expected value) and 
					standard deviation is always given to help maintain a minimum layer
					of interoperability if receiving applications cannot deal with a
					certain probability distribution.
				</p><table id="dt-PPD-prop-summary"><caption>Property Summary of
      Parametric Probability Distribution</caption><col width="79"/><col width="60"/><col width="413"/><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><termref ref="prop-PPD.standardDeviation">standardDeviation</termref></td><td><termref ref="dt-QTY">QTY</termref></td><td>
							The primary measure of variance/uncertainty of the value (the square
							root of the sum of the squares of the differences between all data
							points and the mean). <emph>standardDeviation</emph> is used to normalize the
							data for computing the distribution function. Applications that cannot
							deal with probability distributions can still get an idea about the
							confidence level by looking at <emph>standardDeviation</emph>.
						</td></tr><tr><td><termref ref="prop-PPD.distributionType">distributionType</termref></td><td><termref ref="dt-CE">CE</termref></td><td>
							A code specifying the type of probability distribution. Possible
							values are as shown in the attached table. The NULL value (unknown)
							for the type code indicates that the probability distribution type is
							unknown. In that case, <termref ref="prop-PPD.standardDeviation">standardDeviation</termref>
							has the meaning of an informal guess.
						</td></tr></tbody></table><exhibit role="dtdl" id="dtdl-PPD"><anchor id="dtdl-PPD"/><caption/><pre>
template&lt;QTY T&gt;
type ParametricProbabilityDistribution&lt;T&gt; alias PPD&lt;T&gt; specializes T {
   QTY     standardDeviation;
   CS      distributionType;
   IVL&lt;T&gt;  confidenceInterval(REAL p);
   REAL    probability(IVL&lt;T&gt; x);
   PPD&lt;T&gt;  times(REAL x);
};</pre></exhibit><p>
					For example, the most common college entrance exam in the United
					States is the SAT, which is comprised of two parts: verbal and
					math. Each part has a minimum score of 400 (no questions answered
					correctly) and a perfect score of 800. In 1998, according to the
					College Board, 1,172,779 college-bound seniors took the test. The mean
					score for the math portion of the test was 512, and the standard
					deviation 112. These parameter values (512, 112), tagged as the normal
					distribution parameters, paint a pretty good picture of test score
					distribution. In most cases, there is no need to specify all
					1-million+ points of data when just 2 parameters will do!
				</p><graphic source="graphics/DT-PPD-ex1.gif" alt="Example for a parametric probability distribution"/><p>
					Note that the normal distribution is only one of several distributions
					defined for HL7.
				</p><p>
					Since a <emph>PPD</emph> specializes T, a simple T value is
					the mean (expected value or first moment) of the probability
					distribution. Applications that cannot deal with distributions will
					take the simple T value neglecting the uncertainty. That simple value
					of type T is also used to standardize the data for computing the
					distribution.
					</p><p>
					Probability distributions are defined over integer or real numbers and
					normalized to a certain reference point (typically zero) and reference
					unit (e.g., <termref ref="prop-PPD.standardDeviation">standardDeviation</termref> = 1).
					When other quantities defined in
					this specification are used as base types, the mean and the
					<termref ref="prop-PPD.standardDeviation">standardDeviation</termref> are used to scale the
					probability distribution. For example,
					if a <termref ref="dt-PPD_PQ">PPD&lt;PQ&gt;</termref> for a length is given with mean 20 ft
					and a <termref ref="prop-PPD.standardDeviation">standardDeviation</termref> of 2 in,
					the normalized distribution function
					<emph>f</emph>(<emph>x</emph>) that maps a real number <emph>x</emph>
					to a probability density would be translated to
					<emph>f</emph>&#8242;(<emph>x</emph>&#8242;) that maps
					a length <emph>x</emph>&#8242; to a probability density as
					<emph>f</emph>&#8242;(<emph>x</emph>&#8242;) =
					<emph>f</emph>((<emph>x</emph>&#8242; - &#956;) / &#963;).
				</p><p>
					Where applicable, <emph>PPD</emph> conforms to
					the ISO <emph>Guide to the Expression of Uncertainty in
					Measurement</emph> (GUM) as reflected by NIST publication 1297
					<emph>Guidelines for Evaluating and Expressing the Uncertainty of NIST
					Measurement Results</emph>. <emph>PPD</emph> does not
					describe how uncertainty is to be evaluated but only how it is
					expressed. The concept of "standard uncertainty" as set forth by the
					ISO GUM corresponds to <termref ref="prop-PPD.standardDeviation">standardDeviation</termref>.
				</p><div3 id="prop-PPD.standardDeviation"><head>Standard Deviation : <termref ref="dt-QTY">QTY</termref></head><p><emph role="strong">Definition:</emph>
							The primary measure of variance/uncertainty of the value (the square
							root of the sum of the squares of the differences between all data
							points and the mean). <emph>standardDeviation</emph> is used to normalize the
							data for computing the distribution function. Applications that cannot
							deal with probability distributions can still get an idea about the
							confidence level by looking at <emph>standardDeviation</emph>.
						</p><p><emph>standardDeviation</emph> is
							a specialisation of <termref ref="dt-QTY">QTY</termref> (from T.diffType)
							that expresses differences between values of type T. If T is
							<termref ref="dt-REAL">REAL</termref> or <termref ref="dt-INT">INT</termref>,
							T.diffType is also <termref ref="dt-REAL">REAL</termref> or <termref ref="dt-INT">INT</termref>
							respectively. However if T is <termref ref="dt-TS">TS</termref>,
							T.diffType is a <termref ref="dt-PQ">PQ</termref> in the dimension
							of time.
						</p><exhibit role="dtdl"><caption/><pre>
invariant(PPD x) {
   x.standardDeviation.dataType.implies(T.diffType);
};</pre></exhibit><!--
						<p>
							The standard deviation is what ISO GUM calls "standard uncertainty."
						</p>
  --></div3><div3 id="prop-PPD.distributionType"><head>Probability Distribution Type : <termref ref="dt-CE">CE</termref></head><p><emph role="strong">Definition:</emph>
							A code specifying the type of probability distribution. Possible
							values are as shown in the attached table. The NULL value (unknown)
							for the type code indicates that the probability distribution type is
							unknown. In that case, <termref ref="prop-PPD.standardDeviation">standardDeviation</termref>
							has the meaning of an informal guess.
						</p><p><tabref ref="domain-ProbabilityDistributionType"/> 
							lists the defined
							probability distributions. Many distribution types are defined in
							terms of special parameters (e.g., the parameters &#945; and &#946;
							for the &#947;-distribution, number of degrees of freedom for the
							<emph>t</emph>-distribution, etc.)  For all distribution types,
							however, the mean and standard deviation are defined. 
							<!-- FIXME: Paul Schluter has shown that this doesn't work:
							The PPD data type is specified with the parameters mean and standard
							distribution only. The definition column contains the relationship
							between the special parameters and the mean &mu; and standard
							deviation &sigma;. --></p><table id="domain-ProbabilityDistributionType"><caption>Domain ProbabilityDistributionType</caption><thead><tr valign="bottom"><th>code</th><th>name</th><th>definition</th></tr></thead><tr valign="top"><td>(NULL)</td><td>(NULL)</td><td>
									Used to indicate that the mean is estimated without any closer
									consideration of its probability distribution. In this case, the
									meaning of the standard deviation is not crisply defined. However,
									interpretation should be along the lines of the normal distribution,
									e.g., the interval covered by the mean 1 standard 
									deviation should be at the level of about two thirds confidence.
								</td></tr><tr valign="top"><td>U</td><td>uniform</td><td>
									The uniform distribution assigns a constant probability over the
									entire interval of possible outcomes, while all outcomes outside this
									interval are assumed to have zero probability. The width of this
									interval is 2 &#963; &#8730;3. Thus, the uniform distribution assigns
									the probability densities <emph>f</emph>(x) = (2 &#963; &#8730;3)<emph role="sup">-1</emph>
									to values &#956; - &#963; &#8730;3 &#8805; x &#8804; &#956; + &#963; &#8730;3 and <emph>f</emph>(x) = 0 otherwise.
								</td></tr><tr valign="top"><td>N</td><td>normal (Gaussian)</td><td>
									This is the well-known bell-shaped normal distribution. Because of the
									central limit theorem, the normal distribution is the distribution of
									choice for an unbounded random variable that is an outcome of a
									combination of many stochastic processes. Even for values bounded on a
									single side (i.e. greater than 0) the normal distribution may be
									accurate enough if the mean is "far away" from the bound of the scale
									measured in terms of standard deviations.
								</td></tr><tr valign="top"><td>LN</td><td>log-normal</td><td>
									The logarithmic normal distribution is used to transform skewed random
									variable X into a normally distributed random variable <emph>U</emph>
									= log <emph>X</emph>. The log-normal distribution can be specified
									with the properties mean &#956; and standard deviation &#963;. Note
									however that mean &#956; and standard deviation &#963; are the
									parameters of the raw value distribution, not the transformed
									parameters of the lognormal distribution that are conventionally
									referred to by the same letters. Those log-normal parameters &#956;<emph role="sub">
									log</emph> and &#963;<emph role="sub">log</emph> relate to
									the mean &#956; and standard deviation &#963; of the data value through
									&#963;<emph role="sub">log</emph><emph role="sup">2</emph> = log
									(&#963;<emph role="sup">2</emph>/&#956;<emph role="sup">2</emph> + 1)
									and &#956;log = log &#956; - &#963;<emph role="sub">log</emph><emph role="sup">2</emph>/2.
								</td></tr><tr valign="top"><td>G</td><td>&#947; (gamma)</td><td>
									The gamma-distribution used for data that is skewed and bounded to the
									right, i.e. where the maximum of the distribution curve is located
									near the origin. The &#947;-distribution has two parameters &#945;
									and &#946;. The relationship to mean &#956; and variance &#963;<emph role="sup">2</emph> 
									is &#956; = &#945; &#946; and &#963;<emph role="sup">2</emph> = &#945; &#946;<emph role="sup">2</emph>.
								</td></tr><tr valign="top"><td>E</td><td>exponential</td><td>
									Used for data that describes extinction. The exponential distribution
									is a special form of &#947;-distribution where &#945; = 1, hence,
									the relationship to mean &#956; and variance &#963;<emph role="sup">2</emph> are &#956; = &#946; 
									and &#963;<emph role="sup">2</emph> = &#946;<emph role="sup">2</emph>.
								</td></tr><tr valign="top"><td>X2</td><td>&#967;</td><td>
									Used to describe the sum of squares of random variables that occurs
									when a variance is estimated (rather than presumed) from the
									sample. The only parameter of the &#967;<emph role="sup">2</emph>-distribution 
									is &#965;, so called the
									<emph>number of degrees of freedom</emph> (which is the number of
									independent parts in the sum). The &#967;<emph role="sup">2</emph>-distribution is 
									a special type of &#947;-distribution with parameter &#945; = &#965; /2 and &#946;
									= 2. Hence, &#956; = &#965; and &#963;<emph role="sup">2</emph> = 2 &#965;.
								</td></tr><tr valign="top"><td>T</td><td>t (Student)</td><td>
									Used to describe the quotient of a normal random variable and the
									square root of a &#967;<emph role="sup">2</emph> random variable. The
									<emph>t</emph>-distribution has one parameter &#965;, the number of
									degrees of freedom. The relationship to mean &#956; and variance
									&#963;<emph role="sup">2</emph> are: &#956; = 0 and &#963;<emph role="sup">2</emph> 
									= &#965; / (&#965; - 2)
								</td></tr><tr valign="top"><td>F</td><td>F</td><td>
									Used to describe the quotient of two &#967;<emph role="sup">2</emph>
									random variables. The <emph>F</emph>-distribution has two parameters
									&#965;<emph role="sub">1</emph> and &#965;<emph role="sub">2</emph>, which are the
									numbers of degrees of freedom of
									the numerator and denominator variable respectively. The relationship
									to mean &#956; and variance &#963;<emph role="sup">2</emph> are: &#956; =
									&#965;<emph role="sub">2</emph> / (&#965;<emph role="sub">2</emph> - 2) and &#963;
									<emph role="sup">2</emph> = (2 &#965;<emph role="sub">2</emph> (&#965;<emph role="sub">
									2</emph> + &#965;<emph role="sub">1</emph> - 2)) / (&#965;<emph role="sub">1</emph>
									(&#965;<emph role="sub">2</emph> - 2)<emph role="sup">2</emph>
									(&#965;<emph role="sub">2</emph> - 4)).
									</td></tr><tr valign="top"><td>B</td><td>&#946; (beta)</td><td>
									The beta-distribution is used for data that is bounded on both sides
									and may or may not be skewed (e.g., occurs when probabilities are
									estimated.)  Two parameters &#945; and &#946; are available to adjust
									the curve. The mean &#956; and variance &#963;<emph role="sup">2</emph>
									relate as follows: &#956; = &#945; / (&#945; + &#946;) and
									(&#963;<emph role="sup">2</emph> = &#945; &#946;/((&#945; +
									&#946;)<emph role="sup">2</emph> (&#945; + &#946; + 1)).
								</td></tr></table><p>
							The three distribution-types <emph>unknown</emph> (NULL),
							<emph>uniform</emph> and <emph>normal</emph> must be supported by
							every system that claims to support <emph>PPD</emph>. All other distribution
							types are optional. When a system interpreting a <emph>PPD</emph>
							representation encounters a distribution type that it does not
							recognize, it maps this type to the unknown (NULL) distribution-type.
						</p></div3><div3 id="prop-PPD.literal"><head>Literal Form</head><p>
							 The general syntax of the literal form for <emph>PPD</emph> is as follows:
						</p><exhibit role="dtdl"><caption/><pre>
PPD&lt;T&gt;.literal ST {
   PPD&lt;T&gt;  : T "(" type QTY ")"  { ((T)$).equal($1);
                                   $.distributionType.equal($3);
                                   $.standardDeviation.equal($4); };
   CV type : ST                  { $.value.equal($1);
                                   $.codeSystem.equal(2.16.840.1.113883.5.1020); };
};</pre></exhibit><p>
							Examples: an example for a <termref ref="dt-PPD_REAL">PPD&lt;REAL&gt;</termref>
							is "1.23(N0.005)" for a normal <termref ref="prop-PPD.distributionType">distributionType</termref>
							around 1.23 with a <termref ref="prop-PPD.standardDeviation">standardDeviation</termref> of 0.005.
							An example for a <termref ref="dt-PPD_PQ">PPD&lt;PQ&gt;</termref> is "1.23 m (5 mm)" for
							an unknown <termref ref="prop-PPD.distributionType">distributionType</termref> around the
							length 1.23 meter with a <termref ref="prop-PPD.standardDeviation">standardDeviation</termref>
							of 5 millimeter. An example for a <termref ref="dt-PPD_TS">PPD&lt;TS&gt;</termref>
							is "2000041113(U4 h)" for a	uniform
							<termref ref="prop-PPD.distributionType">distributionType</termref> around April 11, 2000
							at 1pm with <termref ref="prop-PPD.standardDeviation">standardDeviation</termref> of 4 hours.
						</p></div3><!-- FIXME!!! --></div2><div2 id="dt-PPD_REAL"><anchor id="PPD&lt;REAL&gt;"/><head>Probability Distribution over Real Numbers (PPD&lt;REAL&gt;) specializes <termref ref="dt-PPD">PPD</termref></head><exhibit role="dtdl" id="dtdl-PPD_REAL"><anchor id="dtdl-PPD_REAL"/><caption/><pre>
type ParametricProbabilityDistribution&lt;REAL&gt; alias PPD&lt;REAL&gt;;</pre></exhibit><p>
					The parametric probability distribution of real numbers is fully defined by
					the generic data type.
					However, there are some special considerations about literal representations
					and conversions of probability distributions over <termref ref="dt-REAL">REAL</termref>s, which are
					specified in this section.
				</p><div3><head>
						Converting a real number (REAL) to an uncertain real number
						(PPD&lt;REAL&gt;)
					</head><p>
						When converting a <termref ref="dt-REAL">REAL</termref> into a <termref ref="dt-PPD_REAL">PPD&lt;REAL&gt;</termref>,
						<termref ref="prop-PPD.standardDeviation">PPD.standardDeviation</termref> is calculated from the
						<termref ref="dt-REAL">REAL</termref> value's order of magnitude and
						<termref ref="prop-REAL.precision">REAL.precision</termref>
						(number of significant digits).
						Let <emph>x</emph> be a <termref ref="dt-REAL">REAL</termref> with
						<termref ref="prop-REAL.precision">REAL.precision</termref><emph>n</emph>. We can
						determine the order of magnitude <emph>e</emph> of <emph>x</emph> as
						<emph>e</emph> = log10 |<emph>x</emph>| where <emph>e</emph> is rounded to
						the next integer that is closer to zero (special case: if <emph>x</emph>
						is zero, <emph>e</emph> is zero.)  The value of the least significant digit
						<emph>l</emph> is then <emph>l</emph> = 10<emph role="sup">e-n</emph>
						and the <termref ref="prop-PPD.standardDeviation">PPD.standardDeviation</termref> &#963; = <emph>l</emph> /
						<emph>2</emph>.
					</p><table id="PPD-standard-deviation-examples"><caption>Examples of standard deviations computed from precision p and order of magnitude e</caption><thead><tr><th rowspan="1" colspan="1">Representation</th><th rowspan="1" colspan="1">x</th><th rowspan="1" colspan="1">e</th><th rowspan="1" colspan="1">p</th><th rowspan="1" colspan="1">e - p + 1</th><th rowspan="1" colspan="1">l</th><th rowspan="1" colspan="1">&#963;</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">(0)</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">0.5</td></tr><tr><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">0.5</td></tr><tr><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">0.5</td></tr><tr><td rowspan="1" colspan="1">9</td><td rowspan="1" colspan="1">9</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">0.5</td></tr><tr><td rowspan="1" colspan="1">10</td><td rowspan="1" colspan="1">10</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">0.5</td></tr><tr><td rowspan="1" colspan="1">100</td><td rowspan="1" colspan="1">100</td><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">3</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">0.5</td></tr><tr><td rowspan="1" colspan="1">1e+1</td><td rowspan="1" colspan="1">10</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">10</td><td rowspan="1" colspan="1">5</td></tr><tr><td rowspan="1" colspan="1">1e+2</td><td rowspan="1" colspan="1">100</td><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">100</td><td rowspan="1" colspan="1">50</td></tr><tr><td rowspan="1" colspan="1">10e+1</td><td rowspan="1" colspan="1">100</td><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">10</td><td rowspan="1" colspan="1">5</td></tr><tr><td rowspan="1" colspan="1">1.1</td><td rowspan="1" colspan="1">1.1</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">-1</td><td rowspan="1" colspan="1">0.1</td><td rowspan="1" colspan="1">0.05</td></tr><tr><td rowspan="1" colspan="1">10.1</td><td rowspan="1" colspan="1">10.1</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">3</td><td rowspan="1" colspan="1">-1</td><td rowspan="1" colspan="1">0.1</td><td rowspan="1" colspan="1">0.05</td></tr><tr><td rowspan="1" colspan="1">1.1e+2</td><td rowspan="1" colspan="1">110</td><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">10</td><td rowspan="1" colspan="1">5</td></tr><tr><td rowspan="1" colspan="1">1.1e-2</td><td rowspan="1" colspan="1">0.011</td><td rowspan="1" colspan="1">-2</td><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">-3</td><td rowspan="1" colspan="1">0.001</td><td rowspan="1" colspan="1">0.0005</td></tr><tr><td rowspan="1" colspan="1">1.1e-4</td><td rowspan="1" colspan="1">0.00011</td><td rowspan="1" colspan="1">-4</td><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">-5</td><td rowspan="1" colspan="1">0.00001</td><td rowspan="1" colspan="1">0.000005</td></tr><tr><td rowspan="1" colspan="1">10.1e-4</td><td rowspan="1" colspan="1">0.00101</td><td rowspan="1" colspan="1">-3</td><td rowspan="1" colspan="1">3</td><td rowspan="1" colspan="1">-5</td><td rowspan="1" colspan="1">0.00001</td><td rowspan="1" colspan="1">0.000005</td></tr><tr><td rowspan="1" colspan="1">0.1e-1</td><td rowspan="1" colspan="1">0.01</td><td rowspan="1" colspan="1">-2</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">-2</td><td rowspan="1" colspan="1">0.01</td><td rowspan="1" colspan="1">0.005</td></tr><tr><td rowspan="1" colspan="1">0.01e-1</td><td rowspan="1" colspan="1">0.001</td><td rowspan="1" colspan="1">-3</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">-3</td><td rowspan="1" colspan="1">0.001</td><td rowspan="1" colspan="1">0.0005</td></tr><tr><td rowspan="1" colspan="1">0.01e-2</td><td rowspan="1" colspan="1">0.0001</td><td rowspan="1" colspan="1">-4</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">-4</td><td rowspan="1" colspan="1">0.0001</td><td rowspan="1" colspan="1">0.00005</td></tr><tr><td rowspan="1" colspan="1">0.00</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">(0)</td><td rowspan="1" colspan="1">3</td><td rowspan="1" colspan="1">-2</td><td rowspan="1" colspan="1">0.01</td><td rowspan="1" colspan="1">0.005</td></tr></tbody></table></div3><div3 id="prop-PPD_REAL.literal"><head>Concise Literal Form</head><p>
						Besides the generic literal form of <emph>PPD&lt;REAL&gt;</emph>, a
						concise literal form is defined for <emph>PPD&lt;REAL&gt;</emph> over real
						numbers. This concise literal form is defined such that
						<termref ref="prop-PPD.standardDeviation">PPD.standardDeviation</termref> can be expressed
						in terms of the least significant digit in the mantissa.
						This literal is defined as an extension of the <termref ref="dt-REAL">REAL</termref> literal:
					</p><exhibit role="dtdl"><caption/><pre>
PPD&lt;REAL&gt;.literal ST {
   PPD&lt;REAL&gt; mantissa
           : REAL.mantissa "(" type QTY ")"  { ((T)$).equal($1);
                                                   $.distributionType.equal($3);
                                                   $.standardDeviation.equal($4); }
           | REAL.mantissa                   { $.equal($1);
                                               $.distributionType.equal($3);
                                               $.standardDeviation.equal(
                                                  $1.leastSignificantDigit.times(0.5)); };
   CS type : ST                              { $.value.equal($1);
                                               $.system.equal(2.16.840.1.113883.5.1019); };
};</pre></exhibit><p>
						Examples: "1.23e-3 (U5e-6)" is the uniform
						<termref ref="prop-PPD.distributionType">PPD.distributionType</termref> around 1.23
						 10<emph role="sup">-3</emph> with 5  10<emph role="sup">-6</emph>
						<termref ref="prop-PPD.standardDeviation">PPD.standardDeviation</termref> in generic
						literal form. "1.230(U5)e-3" is the same value in
						concise literal form.
					</p></div3></div2><div2 id="dt-PPD_PQ"><anchor id="PPD&lt;PQ&gt;"/><head>Parametric Probability Distributions over Physical  Quantities (PPD&lt;PQ&gt;) specializes <termref ref="dt-PPD">PPD</termref></head><p><emph>PPD&lt;PQ&gt;</emph> is constructed from <termref ref="dt-PPD">PPD</termref>. However,
					recognizing that the <termref ref="prop-PQ.unit">PQ.unit</termref> can be factored
					from the boundaries, we add additional semantics and a
					separate literal form. The additional view of a <emph>PPD&lt;PQ&gt;</emph>
					is a probability distribution over real numbers with one unit.
				</p><exhibit role="dtdl" id="dtdl-PPD_PQ"><anchor id="dtdl-PPD_PQ"/><caption/><pre>
type ParametricProbabilityDistribution&lt;PQ&gt; alias PPD&lt;PQ&gt; {
   PPD&lt;REAL&gt; value;
   CS  unit;
};</pre></exhibit><p>
					The unit applies to both mean and <termref ref="prop-PPD.standardDeviation">PPD.standardDeviation</termref>.
				</p><exhibit role="dtdl"><caption/><pre>
invariant(PPD&lt;PQ&gt; x)
      where x.nonNull {
   x.value.nonNull;
   ((REAL)x.value).equal(((PQ)x).value);
   x.unit.equal(((PQ)x).unit);
   x.value.standardDeviation.equal(x.standardDeviation.value);
   x.standardDeviation.unit.equal(x.unit);
};</pre></exhibit><div3 id="prop-PPD_PQ.literal"><head>Concise Literal Form</head><p>
						A concise literal form for <emph>PPD&lt;PQ&gt;</emph> is defined based on
						the concise literal form of <termref ref="dt-PPD_REAL">PPD&lt;REAL&gt;</termref>
						where <termref ref="dt-REAL">REAL</termref> is the value. This
						literal is defined as an extension of the <termref ref="dt-PQ">PQ</termref> literal.
					</p><exhibit role="dtdl"><caption/><pre>
PPD&lt;PQ&gt;.literal ST {
   PPD&lt;PQ&gt; : PPD&lt;REAL&gt; " " unit  { $.value.equal($1);
                                   $.unit.equal($3); }
};</pre></exhibit><p>
						Examples: "1.23e-3 m (N5e-6 m)" is the normal-distributed length of
						1.23  10<emph role="sup">-3</emph> m with 5  10<emph role="sup">-6</emph> m
						<termref ref="prop-PPD.standardDeviation">PPD.standardDeviation</termref> in generic literal
						form. "1.230(N5)e-3 m" is the same value in concise literal
						form. "1.23e-3(N0.005e-3) m " is also valid; it is the concise literal
						form for <emph>PPD&lt;PQ&gt;</emph> combined with the
						generic literal form for <termref ref="dt-PPD_REAL">PPD&lt;REAL&gt;</termref>.
					</p></div3></div2><div2 id="dt-PPD_TS"><anchor id="PPD&lt;TS&gt;"/><head>Probability Distribution over Time Points (PPD&lt;TS&gt;) specializes <termref ref="dt-PPD">PPD</termref></head><exhibit role="dtdl" id="dtdl-PPD_TS"><anchor id="dtdl-PPD_TS"/><caption/><pre>
type ParametricProbabilityDistribution&lt;TS&gt; alias PPD&lt;TS&gt;;</pre></exhibit><p><emph>PPD&lt;TS&gt;</emph> is fully defined by the generic data type.
					<termref ref="prop-PPD.standardDeviation">PPD.standardDeviation</termref> is of type TS.diffType, which is a duration (a
					<termref ref="dt-PQ">PQ</termref> in the dimension of time.)
				</p><div3><head>Converting <termref ref="dt-TS">TS</termref> to <emph>PPD&lt;TS&gt;</emph></head><p>
						When converting a <termref ref="dt-TS">TS</termref> into a <emph>PPD&lt;TS&gt;</emph>,
						<termref ref="prop-PPD.standardDeviation">PPD.standardDeviation</termref> is
						calculated from the <termref ref="dt-TS">TS</termref> value's order of magnitude
						and precision (number of significant digits) such that two
						<termref ref="prop-PPD.standardDeviation">PPD.standardDeviation</termref>s span the maximal time range of the digits not
						specified. For example, in 20000609 the unspecified digits are hour of
						the day and lower. All these digits together span a duration of 24
						hours, and thus, <termref ref="prop-PPD.standardDeviation">PPD.standardDeviation</termref> ( is( = 12 h from
						20000609000000.0000... up to 20000609999999.9999... (= 20000610)
					</p><p>
						This rule is different from that specified for <termref ref="dt-REAL">REAL</termref>
						in that the range of uncertainty lies 
						above the time value specified. This is to go with the common sense judgment 
						that June 9th spans all day of June 9th with noon as the center, not midnight.
					</p></div3></div2></div1></back></spec>